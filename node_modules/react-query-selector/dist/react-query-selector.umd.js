(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = global || self, factory(global.reactSelect = {}));
}(this, (function (exports) { 'use strict';

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
  }

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
  }

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
  }

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
  }

  function _iterableToArrayLimit(arr, i) {
    if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }

  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

    return arr2;
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function findFiber(hostNode) {
    var hook = window.__REACT_DEVTOOLS_GLOBAL_HOOK__;
    var renderers = hook.renderers ? Array.from(hook.renderers.values()) : Object.values(hook._renderers);
    return renderers.reduce(function (prev, renderer) {
      return prev || renderer.findFiberByHostInstance(hostNode);
    }, undefined);
  }
  function fiberRoots() {
    var _ref2;

    var hook = window.__REACT_DEVTOOLS_GLOBAL_HOOK__;

    if (hook.renderers) {
      var _ref;
      return (_ref = []).concat.apply(_ref, _toConsumableArray(Array.from(hook.renderers.keys()).map(function (renderer) {
        return Array.from(hook.getFiberRoots(renderer));
      })));
    }

    return (_ref2 = []).concat.apply(_ref2, _toConsumableArray(Object.values(hook._fiberRoots).map(function (root) {
      return Array.from(root);
    })));
  }
  var ReactTypeOfWork;

  function setupReactDom(_ref3) {
    var version = _ref3.version;

    // **********************************************************
    // The section below is copy-pasted from files in React DevTools repo.
    // Keep it in sync, and add version guards if it changes.
    // https://github.com/facebook/react-devtools/blob/master/backend/attachRendererFiber.js
    // **********************************************************
    // The section below is copy-pasted from files in React repo.
    // Keep it in sync, and add version guards if it changes.
    // **********************************************************
    if (!version.startsWith('16.')) {
      throw new Error('Only react 16 is supported');
    }

    var versionNumber = parseFloat(version.replace(/^16\./, ''));

    if (versionNumber >= 6.0) {
      ReactTypeOfWork = {
        FunctionalComponent: 0,
        ClassComponent: 1,
        IndeterminateComponent: 2,
        HostRoot: 3,
        HostPortal: 4,
        HostComponent: 5,
        HostText: 6,
        Fragment: 7,
        Mode: 8,
        ContextConsumer: 9,
        ContextProvider: 10,
        ForwardRef: 11,
        Profiler: 12,
        SuspenseComponent: 13,
        MemoComponent: 14,
        SimpleMemoComponent: 15,
        LazyComponent: 16,
        IncompleteClassComponent: 17,
        // Warn tracked here, but may not not necessarily implemented
        // correctly as these are new and unstable APIs. May need to
        // be revisited in the future.
        DehydratedFragment: 18,
        SuspenseListComponent: 19,
        FundamentalComponent: 20,
        ScopeComponent: 21,
        CoroutineComponent: -1,
        // Removed
        CoroutineHandlerPhase: -1,
        // Removed
        YieldComponent: -1 // Removed

      };
    } else if (versionNumber >= 4.3) {
      ReactTypeOfWork = {
        FunctionalComponent: 0,
        FunctionalComponentLazy: 1,
        ClassComponent: 2,
        ClassComponentLazy: 3,
        IndeterminateComponent: 4,
        HostRoot: 5,
        HostPortal: 6,
        HostComponent: 7,
        HostText: 8,
        Fragment: 9,
        Mode: 10,
        ContextConsumer: 11,
        ContextProvider: 12,
        ForwardRef: 13,
        ForwardRefLazy: 14,
        Profiler: 15,
        PlaceholderComponent: 16
      };
    } else {
      ReactTypeOfWork = {
        IndeterminateComponent: 0,
        FunctionalComponent: 1,
        FunctionalComponentLazy: -1,
        // Doesn't exist yet
        ClassComponent: 2,
        ClassComponentLazy: -1,
        // Doesn't exist yet
        HostRoot: 3,
        HostPortal: 4,
        HostComponent: 5,
        HostText: 6,
        CoroutineComponent: 7,
        CoroutineHandlerPhase: 8,
        YieldComponent: 9,
        Fragment: 10,
        Mode: 11,
        ContextConsumer: 12,
        ContextProvider: 13,
        ForwardRef: 14,
        ForwardRefLazy: -1,
        // Doesn't exist yet
        Profiler: 15,
        Placeholder: 16
      };
    }
  }

  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined') {
    Object.values(__REACT_DEVTOOLS_GLOBAL_HOOK__.renderers || __REACT_DEVTOOLS_GLOBAL_HOOK__._renderers).forEach(setupReactDom);

    __REACT_DEVTOOLS_GLOBAL_HOOK__.on('renderer', function (_ref4) {
      var renderer = _ref4.renderer;
      return setupReactDom(renderer);
    });
  } else {
    // Provide our own hook implementation if not running in a devtools environment
    var hook;
    window.__REACT_DEVTOOLS_GLOBAL_HOOK__ = hook = {
      renderers: [],
      _fiberRoots: [],
      getFiberRoots: function getFiberRoots(rendererId) {
        return hook._fiberRoots[rendererId];
      },
      inject: function inject(instance) {
        hook.renderers.push(instance);

        hook._fiberRoots.push([]);

        setupReactDom(instance);
        return hook.renderers.length - 1;
      },
      onCommitFiberRoot: function onCommitFiberRoot(rendererId, root) {
        var mountedRoots = hook._fiberRoots[rendererId];
        var current = root.current;
        var isKnownRoot = mountedRoots.includes(root);
        var isUnmounting = current.memoizedState == null || current.memoizedState.element == null; // Keep track of mounted roots so we can hydrate when DevTools connect.

        if (!isKnownRoot && !isUnmounting) {
          hook._fiberRoots[rendererId].push(root);
        } else if (isKnownRoot && isUnmounting) {
          hook.onCommitFiberUnmount(rendererId, root);
        }
      },
      onCommitFiberUnmount: function onCommitFiberUnmount(rendererId, root) {
        hook._fiberRoots[rendererId] = hook._fiberRoots[rendererId].filter(function (current) {
          return current !== root;
        });
      },
      supportsFiber: true
    };
  }

  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function unwrapExports (x) {
  	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
  }

  function createCommonjsModule(fn, module) {
  	return module = { exports: {} }, fn(module, module.exports), module.exports;
  }

  function getCjsExportFromNamespace (n) {
  	return n && n['default'] || n;
  }

  //Types of elements found in the DOM
  var domelementtype = {
  	Text: "text", //Text
  	Directive: "directive", //<? ... ?>
  	Comment: "comment", //<!-- ... -->
  	Script: "script", //<script> tags
  	Style: "style", //<style> tags
  	Tag: "tag", //Any tag
  	CDATA: "cdata", //<![CDATA[ ... ]]>
  	Doctype: "doctype",

  	isTag: function(elem){
  		return elem.type === "tag" || elem.type === "script" || elem.type === "style";
  	}
  };

  var lib = createCommonjsModule(function (module, exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  /**
   * Tests whether an element is a tag or not.
   *
   * @param elem Element to test
   */
  function isTag(elem) {
      return (elem.type === "tag" /* Tag */ ||
          elem.type === "script" /* Script */ ||
          elem.type === "style" /* Style */);
  }
  exports.isTag = isTag;
  // Exports for backwards compatibility
  exports.Text = "text" /* Text */; //Text
  exports.Directive = "directive" /* Directive */; //<? ... ?>
  exports.Comment = "comment" /* Comment */; //<!-- ... -->
  exports.Script = "script" /* Script */; //<script> tags
  exports.Style = "style" /* Style */; //<style> tags
  exports.Tag = "tag" /* Tag */; //Any tag
  exports.CDATA = "cdata" /* CDATA */; //<![CDATA[ ... ]]>
  exports.Doctype = "doctype" /* Doctype */;
  });

  unwrapExports(lib);
  var lib_1 = lib.isTag;
  var lib_2 = lib.Text;
  var lib_3 = lib.Directive;
  var lib_4 = lib.Comment;
  var lib_5 = lib.Script;
  var lib_6 = lib.Style;
  var lib_7 = lib.Tag;
  var lib_8 = lib.CDATA;
  var lib_9 = lib.Doctype;

  var Aacute = "Á";
  var aacute = "á";
  var Abreve = "Ă";
  var abreve = "ă";
  var ac = "∾";
  var acd = "∿";
  var acE = "∾̳";
  var Acirc = "Â";
  var acirc = "â";
  var acute = "´";
  var Acy = "А";
  var acy = "а";
  var AElig = "Æ";
  var aelig = "æ";
  var af = "⁡";
  var Afr = "𝔄";
  var afr = "𝔞";
  var Agrave = "À";
  var agrave = "à";
  var alefsym = "ℵ";
  var aleph = "ℵ";
  var Alpha = "Α";
  var alpha = "α";
  var Amacr = "Ā";
  var amacr = "ā";
  var amalg = "⨿";
  var amp = "&";
  var AMP = "&";
  var andand = "⩕";
  var And = "⩓";
  var and = "∧";
  var andd = "⩜";
  var andslope = "⩘";
  var andv = "⩚";
  var ang = "∠";
  var ange = "⦤";
  var angle = "∠";
  var angmsdaa = "⦨";
  var angmsdab = "⦩";
  var angmsdac = "⦪";
  var angmsdad = "⦫";
  var angmsdae = "⦬";
  var angmsdaf = "⦭";
  var angmsdag = "⦮";
  var angmsdah = "⦯";
  var angmsd = "∡";
  var angrt = "∟";
  var angrtvb = "⊾";
  var angrtvbd = "⦝";
  var angsph = "∢";
  var angst = "Å";
  var angzarr = "⍼";
  var Aogon = "Ą";
  var aogon = "ą";
  var Aopf = "𝔸";
  var aopf = "𝕒";
  var apacir = "⩯";
  var ap = "≈";
  var apE = "⩰";
  var ape = "≊";
  var apid = "≋";
  var apos = "'";
  var ApplyFunction = "⁡";
  var approx = "≈";
  var approxeq = "≊";
  var Aring = "Å";
  var aring = "å";
  var Ascr = "𝒜";
  var ascr = "𝒶";
  var Assign = "≔";
  var ast = "*";
  var asymp = "≈";
  var asympeq = "≍";
  var Atilde = "Ã";
  var atilde = "ã";
  var Auml = "Ä";
  var auml = "ä";
  var awconint = "∳";
  var awint = "⨑";
  var backcong = "≌";
  var backepsilon = "϶";
  var backprime = "‵";
  var backsim = "∽";
  var backsimeq = "⋍";
  var Backslash = "∖";
  var Barv = "⫧";
  var barvee = "⊽";
  var barwed = "⌅";
  var Barwed = "⌆";
  var barwedge = "⌅";
  var bbrk = "⎵";
  var bbrktbrk = "⎶";
  var bcong = "≌";
  var Bcy = "Б";
  var bcy = "б";
  var bdquo = "„";
  var becaus = "∵";
  var because = "∵";
  var Because = "∵";
  var bemptyv = "⦰";
  var bepsi = "϶";
  var bernou = "ℬ";
  var Bernoullis = "ℬ";
  var Beta = "Β";
  var beta = "β";
  var beth = "ℶ";
  var between = "≬";
  var Bfr = "𝔅";
  var bfr = "𝔟";
  var bigcap = "⋂";
  var bigcirc = "◯";
  var bigcup = "⋃";
  var bigodot = "⨀";
  var bigoplus = "⨁";
  var bigotimes = "⨂";
  var bigsqcup = "⨆";
  var bigstar = "★";
  var bigtriangledown = "▽";
  var bigtriangleup = "△";
  var biguplus = "⨄";
  var bigvee = "⋁";
  var bigwedge = "⋀";
  var bkarow = "⤍";
  var blacklozenge = "⧫";
  var blacksquare = "▪";
  var blacktriangle = "▴";
  var blacktriangledown = "▾";
  var blacktriangleleft = "◂";
  var blacktriangleright = "▸";
  var blank = "␣";
  var blk12 = "▒";
  var blk14 = "░";
  var blk34 = "▓";
  var block = "█";
  var bne = "=⃥";
  var bnequiv = "≡⃥";
  var bNot = "⫭";
  var bnot = "⌐";
  var Bopf = "𝔹";
  var bopf = "𝕓";
  var bot = "⊥";
  var bottom = "⊥";
  var bowtie = "⋈";
  var boxbox = "⧉";
  var boxdl = "┐";
  var boxdL = "╕";
  var boxDl = "╖";
  var boxDL = "╗";
  var boxdr = "┌";
  var boxdR = "╒";
  var boxDr = "╓";
  var boxDR = "╔";
  var boxh = "─";
  var boxH = "═";
  var boxhd = "┬";
  var boxHd = "╤";
  var boxhD = "╥";
  var boxHD = "╦";
  var boxhu = "┴";
  var boxHu = "╧";
  var boxhU = "╨";
  var boxHU = "╩";
  var boxminus = "⊟";
  var boxplus = "⊞";
  var boxtimes = "⊠";
  var boxul = "┘";
  var boxuL = "╛";
  var boxUl = "╜";
  var boxUL = "╝";
  var boxur = "└";
  var boxuR = "╘";
  var boxUr = "╙";
  var boxUR = "╚";
  var boxv = "│";
  var boxV = "║";
  var boxvh = "┼";
  var boxvH = "╪";
  var boxVh = "╫";
  var boxVH = "╬";
  var boxvl = "┤";
  var boxvL = "╡";
  var boxVl = "╢";
  var boxVL = "╣";
  var boxvr = "├";
  var boxvR = "╞";
  var boxVr = "╟";
  var boxVR = "╠";
  var bprime = "‵";
  var breve = "˘";
  var Breve = "˘";
  var brvbar = "¦";
  var bscr = "𝒷";
  var Bscr = "ℬ";
  var bsemi = "⁏";
  var bsim = "∽";
  var bsime = "⋍";
  var bsolb = "⧅";
  var bsol = "\\";
  var bsolhsub = "⟈";
  var bull = "•";
  var bullet = "•";
  var bump = "≎";
  var bumpE = "⪮";
  var bumpe = "≏";
  var Bumpeq = "≎";
  var bumpeq = "≏";
  var Cacute = "Ć";
  var cacute = "ć";
  var capand = "⩄";
  var capbrcup = "⩉";
  var capcap = "⩋";
  var cap = "∩";
  var Cap = "⋒";
  var capcup = "⩇";
  var capdot = "⩀";
  var CapitalDifferentialD = "ⅅ";
  var caps = "∩︀";
  var caret = "⁁";
  var caron = "ˇ";
  var Cayleys = "ℭ";
  var ccaps = "⩍";
  var Ccaron = "Č";
  var ccaron = "č";
  var Ccedil = "Ç";
  var ccedil = "ç";
  var Ccirc = "Ĉ";
  var ccirc = "ĉ";
  var Cconint = "∰";
  var ccups = "⩌";
  var ccupssm = "⩐";
  var Cdot = "Ċ";
  var cdot = "ċ";
  var cedil = "¸";
  var Cedilla = "¸";
  var cemptyv = "⦲";
  var cent = "¢";
  var centerdot = "·";
  var CenterDot = "·";
  var cfr = "𝔠";
  var Cfr = "ℭ";
  var CHcy = "Ч";
  var chcy = "ч";
  var check = "✓";
  var checkmark = "✓";
  var Chi = "Χ";
  var chi = "χ";
  var circ = "ˆ";
  var circeq = "≗";
  var circlearrowleft = "↺";
  var circlearrowright = "↻";
  var circledast = "⊛";
  var circledcirc = "⊚";
  var circleddash = "⊝";
  var CircleDot = "⊙";
  var circledR = "®";
  var circledS = "Ⓢ";
  var CircleMinus = "⊖";
  var CirclePlus = "⊕";
  var CircleTimes = "⊗";
  var cir = "○";
  var cirE = "⧃";
  var cire = "≗";
  var cirfnint = "⨐";
  var cirmid = "⫯";
  var cirscir = "⧂";
  var ClockwiseContourIntegral = "∲";
  var CloseCurlyDoubleQuote = "”";
  var CloseCurlyQuote = "’";
  var clubs = "♣";
  var clubsuit = "♣";
  var colon = ":";
  var Colon = "∷";
  var Colone = "⩴";
  var colone = "≔";
  var coloneq = "≔";
  var comma = ",";
  var commat = "@";
  var comp = "∁";
  var compfn = "∘";
  var complement = "∁";
  var complexes = "ℂ";
  var cong = "≅";
  var congdot = "⩭";
  var Congruent = "≡";
  var conint = "∮";
  var Conint = "∯";
  var ContourIntegral = "∮";
  var copf = "𝕔";
  var Copf = "ℂ";
  var coprod = "∐";
  var Coproduct = "∐";
  var copy = "©";
  var COPY = "©";
  var copysr = "℗";
  var CounterClockwiseContourIntegral = "∳";
  var crarr = "↵";
  var cross = "✗";
  var Cross = "⨯";
  var Cscr = "𝒞";
  var cscr = "𝒸";
  var csub = "⫏";
  var csube = "⫑";
  var csup = "⫐";
  var csupe = "⫒";
  var ctdot = "⋯";
  var cudarrl = "⤸";
  var cudarrr = "⤵";
  var cuepr = "⋞";
  var cuesc = "⋟";
  var cularr = "↶";
  var cularrp = "⤽";
  var cupbrcap = "⩈";
  var cupcap = "⩆";
  var CupCap = "≍";
  var cup = "∪";
  var Cup = "⋓";
  var cupcup = "⩊";
  var cupdot = "⊍";
  var cupor = "⩅";
  var cups = "∪︀";
  var curarr = "↷";
  var curarrm = "⤼";
  var curlyeqprec = "⋞";
  var curlyeqsucc = "⋟";
  var curlyvee = "⋎";
  var curlywedge = "⋏";
  var curren = "¤";
  var curvearrowleft = "↶";
  var curvearrowright = "↷";
  var cuvee = "⋎";
  var cuwed = "⋏";
  var cwconint = "∲";
  var cwint = "∱";
  var cylcty = "⌭";
  var dagger = "†";
  var Dagger = "‡";
  var daleth = "ℸ";
  var darr = "↓";
  var Darr = "↡";
  var dArr = "⇓";
  var dash = "‐";
  var Dashv = "⫤";
  var dashv = "⊣";
  var dbkarow = "⤏";
  var dblac = "˝";
  var Dcaron = "Ď";
  var dcaron = "ď";
  var Dcy = "Д";
  var dcy = "д";
  var ddagger = "‡";
  var ddarr = "⇊";
  var DD = "ⅅ";
  var dd = "ⅆ";
  var DDotrahd = "⤑";
  var ddotseq = "⩷";
  var deg = "°";
  var Del = "∇";
  var Delta = "Δ";
  var delta = "δ";
  var demptyv = "⦱";
  var dfisht = "⥿";
  var Dfr = "𝔇";
  var dfr = "𝔡";
  var dHar = "⥥";
  var dharl = "⇃";
  var dharr = "⇂";
  var DiacriticalAcute = "´";
  var DiacriticalDot = "˙";
  var DiacriticalDoubleAcute = "˝";
  var DiacriticalGrave = "`";
  var DiacriticalTilde = "˜";
  var diam = "⋄";
  var diamond = "⋄";
  var Diamond = "⋄";
  var diamondsuit = "♦";
  var diams = "♦";
  var die = "¨";
  var DifferentialD = "ⅆ";
  var digamma = "ϝ";
  var disin = "⋲";
  var div = "÷";
  var divide = "÷";
  var divideontimes = "⋇";
  var divonx = "⋇";
  var DJcy = "Ђ";
  var djcy = "ђ";
  var dlcorn = "⌞";
  var dlcrop = "⌍";
  var dollar = "$";
  var Dopf = "𝔻";
  var dopf = "𝕕";
  var Dot = "¨";
  var dot = "˙";
  var DotDot = "⃜";
  var doteq = "≐";
  var doteqdot = "≑";
  var DotEqual = "≐";
  var dotminus = "∸";
  var dotplus = "∔";
  var dotsquare = "⊡";
  var doublebarwedge = "⌆";
  var DoubleContourIntegral = "∯";
  var DoubleDot = "¨";
  var DoubleDownArrow = "⇓";
  var DoubleLeftArrow = "⇐";
  var DoubleLeftRightArrow = "⇔";
  var DoubleLeftTee = "⫤";
  var DoubleLongLeftArrow = "⟸";
  var DoubleLongLeftRightArrow = "⟺";
  var DoubleLongRightArrow = "⟹";
  var DoubleRightArrow = "⇒";
  var DoubleRightTee = "⊨";
  var DoubleUpArrow = "⇑";
  var DoubleUpDownArrow = "⇕";
  var DoubleVerticalBar = "∥";
  var DownArrowBar = "⤓";
  var downarrow = "↓";
  var DownArrow = "↓";
  var Downarrow = "⇓";
  var DownArrowUpArrow = "⇵";
  var DownBreve = "̑";
  var downdownarrows = "⇊";
  var downharpoonleft = "⇃";
  var downharpoonright = "⇂";
  var DownLeftRightVector = "⥐";
  var DownLeftTeeVector = "⥞";
  var DownLeftVectorBar = "⥖";
  var DownLeftVector = "↽";
  var DownRightTeeVector = "⥟";
  var DownRightVectorBar = "⥗";
  var DownRightVector = "⇁";
  var DownTeeArrow = "↧";
  var DownTee = "⊤";
  var drbkarow = "⤐";
  var drcorn = "⌟";
  var drcrop = "⌌";
  var Dscr = "𝒟";
  var dscr = "𝒹";
  var DScy = "Ѕ";
  var dscy = "ѕ";
  var dsol = "⧶";
  var Dstrok = "Đ";
  var dstrok = "đ";
  var dtdot = "⋱";
  var dtri = "▿";
  var dtrif = "▾";
  var duarr = "⇵";
  var duhar = "⥯";
  var dwangle = "⦦";
  var DZcy = "Џ";
  var dzcy = "џ";
  var dzigrarr = "⟿";
  var Eacute = "É";
  var eacute = "é";
  var easter = "⩮";
  var Ecaron = "Ě";
  var ecaron = "ě";
  var Ecirc = "Ê";
  var ecirc = "ê";
  var ecir = "≖";
  var ecolon = "≕";
  var Ecy = "Э";
  var ecy = "э";
  var eDDot = "⩷";
  var Edot = "Ė";
  var edot = "ė";
  var eDot = "≑";
  var ee = "ⅇ";
  var efDot = "≒";
  var Efr = "𝔈";
  var efr = "𝔢";
  var eg = "⪚";
  var Egrave = "È";
  var egrave = "è";
  var egs = "⪖";
  var egsdot = "⪘";
  var el = "⪙";
  var Element = "∈";
  var elinters = "⏧";
  var ell = "ℓ";
  var els = "⪕";
  var elsdot = "⪗";
  var Emacr = "Ē";
  var emacr = "ē";
  var empty = "∅";
  var emptyset = "∅";
  var EmptySmallSquare = "◻";
  var emptyv = "∅";
  var EmptyVerySmallSquare = "▫";
  var emsp13 = " ";
  var emsp14 = " ";
  var emsp = " ";
  var ENG = "Ŋ";
  var eng = "ŋ";
  var ensp = " ";
  var Eogon = "Ę";
  var eogon = "ę";
  var Eopf = "𝔼";
  var eopf = "𝕖";
  var epar = "⋕";
  var eparsl = "⧣";
  var eplus = "⩱";
  var epsi = "ε";
  var Epsilon = "Ε";
  var epsilon = "ε";
  var epsiv = "ϵ";
  var eqcirc = "≖";
  var eqcolon = "≕";
  var eqsim = "≂";
  var eqslantgtr = "⪖";
  var eqslantless = "⪕";
  var Equal = "⩵";
  var equals = "=";
  var EqualTilde = "≂";
  var equest = "≟";
  var Equilibrium = "⇌";
  var equiv = "≡";
  var equivDD = "⩸";
  var eqvparsl = "⧥";
  var erarr = "⥱";
  var erDot = "≓";
  var escr = "ℯ";
  var Escr = "ℰ";
  var esdot = "≐";
  var Esim = "⩳";
  var esim = "≂";
  var Eta = "Η";
  var eta = "η";
  var ETH = "Ð";
  var eth = "ð";
  var Euml = "Ë";
  var euml = "ë";
  var euro = "€";
  var excl = "!";
  var exist = "∃";
  var Exists = "∃";
  var expectation = "ℰ";
  var exponentiale = "ⅇ";
  var ExponentialE = "ⅇ";
  var fallingdotseq = "≒";
  var Fcy = "Ф";
  var fcy = "ф";
  var female = "♀";
  var ffilig = "ﬃ";
  var fflig = "ﬀ";
  var ffllig = "ﬄ";
  var Ffr = "𝔉";
  var ffr = "𝔣";
  var filig = "ﬁ";
  var FilledSmallSquare = "◼";
  var FilledVerySmallSquare = "▪";
  var fjlig = "fj";
  var flat = "♭";
  var fllig = "ﬂ";
  var fltns = "▱";
  var fnof = "ƒ";
  var Fopf = "𝔽";
  var fopf = "𝕗";
  var forall = "∀";
  var ForAll = "∀";
  var fork = "⋔";
  var forkv = "⫙";
  var Fouriertrf = "ℱ";
  var fpartint = "⨍";
  var frac12 = "½";
  var frac13 = "⅓";
  var frac14 = "¼";
  var frac15 = "⅕";
  var frac16 = "⅙";
  var frac18 = "⅛";
  var frac23 = "⅔";
  var frac25 = "⅖";
  var frac34 = "¾";
  var frac35 = "⅗";
  var frac38 = "⅜";
  var frac45 = "⅘";
  var frac56 = "⅚";
  var frac58 = "⅝";
  var frac78 = "⅞";
  var frasl = "⁄";
  var frown = "⌢";
  var fscr = "𝒻";
  var Fscr = "ℱ";
  var gacute = "ǵ";
  var Gamma = "Γ";
  var gamma = "γ";
  var Gammad = "Ϝ";
  var gammad = "ϝ";
  var gap = "⪆";
  var Gbreve = "Ğ";
  var gbreve = "ğ";
  var Gcedil = "Ģ";
  var Gcirc = "Ĝ";
  var gcirc = "ĝ";
  var Gcy = "Г";
  var gcy = "г";
  var Gdot = "Ġ";
  var gdot = "ġ";
  var ge = "≥";
  var gE = "≧";
  var gEl = "⪌";
  var gel = "⋛";
  var geq = "≥";
  var geqq = "≧";
  var geqslant = "⩾";
  var gescc = "⪩";
  var ges = "⩾";
  var gesdot = "⪀";
  var gesdoto = "⪂";
  var gesdotol = "⪄";
  var gesl = "⋛︀";
  var gesles = "⪔";
  var Gfr = "𝔊";
  var gfr = "𝔤";
  var gg = "≫";
  var Gg = "⋙";
  var ggg = "⋙";
  var gimel = "ℷ";
  var GJcy = "Ѓ";
  var gjcy = "ѓ";
  var gla = "⪥";
  var gl = "≷";
  var glE = "⪒";
  var glj = "⪤";
  var gnap = "⪊";
  var gnapprox = "⪊";
  var gne = "⪈";
  var gnE = "≩";
  var gneq = "⪈";
  var gneqq = "≩";
  var gnsim = "⋧";
  var Gopf = "𝔾";
  var gopf = "𝕘";
  var grave = "`";
  var GreaterEqual = "≥";
  var GreaterEqualLess = "⋛";
  var GreaterFullEqual = "≧";
  var GreaterGreater = "⪢";
  var GreaterLess = "≷";
  var GreaterSlantEqual = "⩾";
  var GreaterTilde = "≳";
  var Gscr = "𝒢";
  var gscr = "ℊ";
  var gsim = "≳";
  var gsime = "⪎";
  var gsiml = "⪐";
  var gtcc = "⪧";
  var gtcir = "⩺";
  var gt = ">";
  var GT = ">";
  var Gt = "≫";
  var gtdot = "⋗";
  var gtlPar = "⦕";
  var gtquest = "⩼";
  var gtrapprox = "⪆";
  var gtrarr = "⥸";
  var gtrdot = "⋗";
  var gtreqless = "⋛";
  var gtreqqless = "⪌";
  var gtrless = "≷";
  var gtrsim = "≳";
  var gvertneqq = "≩︀";
  var gvnE = "≩︀";
  var Hacek = "ˇ";
  var hairsp = " ";
  var half = "½";
  var hamilt = "ℋ";
  var HARDcy = "Ъ";
  var hardcy = "ъ";
  var harrcir = "⥈";
  var harr = "↔";
  var hArr = "⇔";
  var harrw = "↭";
  var Hat = "^";
  var hbar = "ℏ";
  var Hcirc = "Ĥ";
  var hcirc = "ĥ";
  var hearts = "♥";
  var heartsuit = "♥";
  var hellip = "…";
  var hercon = "⊹";
  var hfr = "𝔥";
  var Hfr = "ℌ";
  var HilbertSpace = "ℋ";
  var hksearow = "⤥";
  var hkswarow = "⤦";
  var hoarr = "⇿";
  var homtht = "∻";
  var hookleftarrow = "↩";
  var hookrightarrow = "↪";
  var hopf = "𝕙";
  var Hopf = "ℍ";
  var horbar = "―";
  var HorizontalLine = "─";
  var hscr = "𝒽";
  var Hscr = "ℋ";
  var hslash = "ℏ";
  var Hstrok = "Ħ";
  var hstrok = "ħ";
  var HumpDownHump = "≎";
  var HumpEqual = "≏";
  var hybull = "⁃";
  var hyphen = "‐";
  var Iacute = "Í";
  var iacute = "í";
  var ic = "⁣";
  var Icirc = "Î";
  var icirc = "î";
  var Icy = "И";
  var icy = "и";
  var Idot = "İ";
  var IEcy = "Е";
  var iecy = "е";
  var iexcl = "¡";
  var iff = "⇔";
  var ifr = "𝔦";
  var Ifr = "ℑ";
  var Igrave = "Ì";
  var igrave = "ì";
  var ii = "ⅈ";
  var iiiint = "⨌";
  var iiint = "∭";
  var iinfin = "⧜";
  var iiota = "℩";
  var IJlig = "Ĳ";
  var ijlig = "ĳ";
  var Imacr = "Ī";
  var imacr = "ī";
  var image = "ℑ";
  var ImaginaryI = "ⅈ";
  var imagline = "ℐ";
  var imagpart = "ℑ";
  var imath = "ı";
  var Im = "ℑ";
  var imof = "⊷";
  var imped = "Ƶ";
  var Implies = "⇒";
  var incare = "℅";
  var infin = "∞";
  var infintie = "⧝";
  var inodot = "ı";
  var intcal = "⊺";
  var int = "∫";
  var Int = "∬";
  var integers = "ℤ";
  var Integral = "∫";
  var intercal = "⊺";
  var Intersection = "⋂";
  var intlarhk = "⨗";
  var intprod = "⨼";
  var InvisibleComma = "⁣";
  var InvisibleTimes = "⁢";
  var IOcy = "Ё";
  var iocy = "ё";
  var Iogon = "Į";
  var iogon = "į";
  var Iopf = "𝕀";
  var iopf = "𝕚";
  var Iota = "Ι";
  var iota = "ι";
  var iprod = "⨼";
  var iquest = "¿";
  var iscr = "𝒾";
  var Iscr = "ℐ";
  var isin = "∈";
  var isindot = "⋵";
  var isinE = "⋹";
  var isins = "⋴";
  var isinsv = "⋳";
  var isinv = "∈";
  var it = "⁢";
  var Itilde = "Ĩ";
  var itilde = "ĩ";
  var Iukcy = "І";
  var iukcy = "і";
  var Iuml = "Ï";
  var iuml = "ï";
  var Jcirc = "Ĵ";
  var jcirc = "ĵ";
  var Jcy = "Й";
  var jcy = "й";
  var Jfr = "𝔍";
  var jfr = "𝔧";
  var jmath = "ȷ";
  var Jopf = "𝕁";
  var jopf = "𝕛";
  var Jscr = "𝒥";
  var jscr = "𝒿";
  var Jsercy = "Ј";
  var jsercy = "ј";
  var Jukcy = "Є";
  var jukcy = "є";
  var Kappa = "Κ";
  var kappa = "κ";
  var kappav = "ϰ";
  var Kcedil = "Ķ";
  var kcedil = "ķ";
  var Kcy = "К";
  var kcy = "к";
  var Kfr = "𝔎";
  var kfr = "𝔨";
  var kgreen = "ĸ";
  var KHcy = "Х";
  var khcy = "х";
  var KJcy = "Ќ";
  var kjcy = "ќ";
  var Kopf = "𝕂";
  var kopf = "𝕜";
  var Kscr = "𝒦";
  var kscr = "𝓀";
  var lAarr = "⇚";
  var Lacute = "Ĺ";
  var lacute = "ĺ";
  var laemptyv = "⦴";
  var lagran = "ℒ";
  var Lambda = "Λ";
  var lambda = "λ";
  var lang = "⟨";
  var Lang = "⟪";
  var langd = "⦑";
  var langle = "⟨";
  var lap = "⪅";
  var Laplacetrf = "ℒ";
  var laquo = "«";
  var larrb = "⇤";
  var larrbfs = "⤟";
  var larr = "←";
  var Larr = "↞";
  var lArr = "⇐";
  var larrfs = "⤝";
  var larrhk = "↩";
  var larrlp = "↫";
  var larrpl = "⤹";
  var larrsim = "⥳";
  var larrtl = "↢";
  var latail = "⤙";
  var lAtail = "⤛";
  var lat = "⪫";
  var late = "⪭";
  var lates = "⪭︀";
  var lbarr = "⤌";
  var lBarr = "⤎";
  var lbbrk = "❲";
  var lbrace = "{";
  var lbrack = "[";
  var lbrke = "⦋";
  var lbrksld = "⦏";
  var lbrkslu = "⦍";
  var Lcaron = "Ľ";
  var lcaron = "ľ";
  var Lcedil = "Ļ";
  var lcedil = "ļ";
  var lceil = "⌈";
  var lcub = "{";
  var Lcy = "Л";
  var lcy = "л";
  var ldca = "⤶";
  var ldquo = "“";
  var ldquor = "„";
  var ldrdhar = "⥧";
  var ldrushar = "⥋";
  var ldsh = "↲";
  var le = "≤";
  var lE = "≦";
  var LeftAngleBracket = "⟨";
  var LeftArrowBar = "⇤";
  var leftarrow = "←";
  var LeftArrow = "←";
  var Leftarrow = "⇐";
  var LeftArrowRightArrow = "⇆";
  var leftarrowtail = "↢";
  var LeftCeiling = "⌈";
  var LeftDoubleBracket = "⟦";
  var LeftDownTeeVector = "⥡";
  var LeftDownVectorBar = "⥙";
  var LeftDownVector = "⇃";
  var LeftFloor = "⌊";
  var leftharpoondown = "↽";
  var leftharpoonup = "↼";
  var leftleftarrows = "⇇";
  var leftrightarrow = "↔";
  var LeftRightArrow = "↔";
  var Leftrightarrow = "⇔";
  var leftrightarrows = "⇆";
  var leftrightharpoons = "⇋";
  var leftrightsquigarrow = "↭";
  var LeftRightVector = "⥎";
  var LeftTeeArrow = "↤";
  var LeftTee = "⊣";
  var LeftTeeVector = "⥚";
  var leftthreetimes = "⋋";
  var LeftTriangleBar = "⧏";
  var LeftTriangle = "⊲";
  var LeftTriangleEqual = "⊴";
  var LeftUpDownVector = "⥑";
  var LeftUpTeeVector = "⥠";
  var LeftUpVectorBar = "⥘";
  var LeftUpVector = "↿";
  var LeftVectorBar = "⥒";
  var LeftVector = "↼";
  var lEg = "⪋";
  var leg = "⋚";
  var leq = "≤";
  var leqq = "≦";
  var leqslant = "⩽";
  var lescc = "⪨";
  var les = "⩽";
  var lesdot = "⩿";
  var lesdoto = "⪁";
  var lesdotor = "⪃";
  var lesg = "⋚︀";
  var lesges = "⪓";
  var lessapprox = "⪅";
  var lessdot = "⋖";
  var lesseqgtr = "⋚";
  var lesseqqgtr = "⪋";
  var LessEqualGreater = "⋚";
  var LessFullEqual = "≦";
  var LessGreater = "≶";
  var lessgtr = "≶";
  var LessLess = "⪡";
  var lesssim = "≲";
  var LessSlantEqual = "⩽";
  var LessTilde = "≲";
  var lfisht = "⥼";
  var lfloor = "⌊";
  var Lfr = "𝔏";
  var lfr = "𝔩";
  var lg = "≶";
  var lgE = "⪑";
  var lHar = "⥢";
  var lhard = "↽";
  var lharu = "↼";
  var lharul = "⥪";
  var lhblk = "▄";
  var LJcy = "Љ";
  var ljcy = "љ";
  var llarr = "⇇";
  var ll = "≪";
  var Ll = "⋘";
  var llcorner = "⌞";
  var Lleftarrow = "⇚";
  var llhard = "⥫";
  var lltri = "◺";
  var Lmidot = "Ŀ";
  var lmidot = "ŀ";
  var lmoustache = "⎰";
  var lmoust = "⎰";
  var lnap = "⪉";
  var lnapprox = "⪉";
  var lne = "⪇";
  var lnE = "≨";
  var lneq = "⪇";
  var lneqq = "≨";
  var lnsim = "⋦";
  var loang = "⟬";
  var loarr = "⇽";
  var lobrk = "⟦";
  var longleftarrow = "⟵";
  var LongLeftArrow = "⟵";
  var Longleftarrow = "⟸";
  var longleftrightarrow = "⟷";
  var LongLeftRightArrow = "⟷";
  var Longleftrightarrow = "⟺";
  var longmapsto = "⟼";
  var longrightarrow = "⟶";
  var LongRightArrow = "⟶";
  var Longrightarrow = "⟹";
  var looparrowleft = "↫";
  var looparrowright = "↬";
  var lopar = "⦅";
  var Lopf = "𝕃";
  var lopf = "𝕝";
  var loplus = "⨭";
  var lotimes = "⨴";
  var lowast = "∗";
  var lowbar = "_";
  var LowerLeftArrow = "↙";
  var LowerRightArrow = "↘";
  var loz = "◊";
  var lozenge = "◊";
  var lozf = "⧫";
  var lpar = "(";
  var lparlt = "⦓";
  var lrarr = "⇆";
  var lrcorner = "⌟";
  var lrhar = "⇋";
  var lrhard = "⥭";
  var lrm = "‎";
  var lrtri = "⊿";
  var lsaquo = "‹";
  var lscr = "𝓁";
  var Lscr = "ℒ";
  var lsh = "↰";
  var Lsh = "↰";
  var lsim = "≲";
  var lsime = "⪍";
  var lsimg = "⪏";
  var lsqb = "[";
  var lsquo = "‘";
  var lsquor = "‚";
  var Lstrok = "Ł";
  var lstrok = "ł";
  var ltcc = "⪦";
  var ltcir = "⩹";
  var lt = "<";
  var LT = "<";
  var Lt = "≪";
  var ltdot = "⋖";
  var lthree = "⋋";
  var ltimes = "⋉";
  var ltlarr = "⥶";
  var ltquest = "⩻";
  var ltri = "◃";
  var ltrie = "⊴";
  var ltrif = "◂";
  var ltrPar = "⦖";
  var lurdshar = "⥊";
  var luruhar = "⥦";
  var lvertneqq = "≨︀";
  var lvnE = "≨︀";
  var macr = "¯";
  var male = "♂";
  var malt = "✠";
  var maltese = "✠";
  var map = "↦";
  var mapsto = "↦";
  var mapstodown = "↧";
  var mapstoleft = "↤";
  var mapstoup = "↥";
  var marker = "▮";
  var mcomma = "⨩";
  var Mcy = "М";
  var mcy = "м";
  var mdash = "—";
  var mDDot = "∺";
  var measuredangle = "∡";
  var MediumSpace = " ";
  var Mellintrf = "ℳ";
  var Mfr = "𝔐";
  var mfr = "𝔪";
  var mho = "℧";
  var micro = "µ";
  var midast = "*";
  var midcir = "⫰";
  var mid = "∣";
  var middot = "·";
  var minusb = "⊟";
  var minus = "−";
  var minusd = "∸";
  var minusdu = "⨪";
  var MinusPlus = "∓";
  var mlcp = "⫛";
  var mldr = "…";
  var mnplus = "∓";
  var models = "⊧";
  var Mopf = "𝕄";
  var mopf = "𝕞";
  var mp = "∓";
  var mscr = "𝓂";
  var Mscr = "ℳ";
  var mstpos = "∾";
  var Mu = "Μ";
  var mu = "μ";
  var multimap = "⊸";
  var mumap = "⊸";
  var nabla = "∇";
  var Nacute = "Ń";
  var nacute = "ń";
  var nang = "∠⃒";
  var nap = "≉";
  var napE = "⩰̸";
  var napid = "≋̸";
  var napos = "ŉ";
  var napprox = "≉";
  var natural = "♮";
  var naturals = "ℕ";
  var natur = "♮";
  var nbsp = " ";
  var nbump = "≎̸";
  var nbumpe = "≏̸";
  var ncap = "⩃";
  var Ncaron = "Ň";
  var ncaron = "ň";
  var Ncedil = "Ņ";
  var ncedil = "ņ";
  var ncong = "≇";
  var ncongdot = "⩭̸";
  var ncup = "⩂";
  var Ncy = "Н";
  var ncy = "н";
  var ndash = "–";
  var nearhk = "⤤";
  var nearr = "↗";
  var neArr = "⇗";
  var nearrow = "↗";
  var ne = "≠";
  var nedot = "≐̸";
  var NegativeMediumSpace = "​";
  var NegativeThickSpace = "​";
  var NegativeThinSpace = "​";
  var NegativeVeryThinSpace = "​";
  var nequiv = "≢";
  var nesear = "⤨";
  var nesim = "≂̸";
  var NestedGreaterGreater = "≫";
  var NestedLessLess = "≪";
  var NewLine = "\n";
  var nexist = "∄";
  var nexists = "∄";
  var Nfr = "𝔑";
  var nfr = "𝔫";
  var ngE = "≧̸";
  var nge = "≱";
  var ngeq = "≱";
  var ngeqq = "≧̸";
  var ngeqslant = "⩾̸";
  var nges = "⩾̸";
  var nGg = "⋙̸";
  var ngsim = "≵";
  var nGt = "≫⃒";
  var ngt = "≯";
  var ngtr = "≯";
  var nGtv = "≫̸";
  var nharr = "↮";
  var nhArr = "⇎";
  var nhpar = "⫲";
  var ni = "∋";
  var nis = "⋼";
  var nisd = "⋺";
  var niv = "∋";
  var NJcy = "Њ";
  var njcy = "њ";
  var nlarr = "↚";
  var nlArr = "⇍";
  var nldr = "‥";
  var nlE = "≦̸";
  var nle = "≰";
  var nleftarrow = "↚";
  var nLeftarrow = "⇍";
  var nleftrightarrow = "↮";
  var nLeftrightarrow = "⇎";
  var nleq = "≰";
  var nleqq = "≦̸";
  var nleqslant = "⩽̸";
  var nles = "⩽̸";
  var nless = "≮";
  var nLl = "⋘̸";
  var nlsim = "≴";
  var nLt = "≪⃒";
  var nlt = "≮";
  var nltri = "⋪";
  var nltrie = "⋬";
  var nLtv = "≪̸";
  var nmid = "∤";
  var NoBreak = "⁠";
  var NonBreakingSpace = " ";
  var nopf = "𝕟";
  var Nopf = "ℕ";
  var Not = "⫬";
  var not = "¬";
  var NotCongruent = "≢";
  var NotCupCap = "≭";
  var NotDoubleVerticalBar = "∦";
  var NotElement = "∉";
  var NotEqual = "≠";
  var NotEqualTilde = "≂̸";
  var NotExists = "∄";
  var NotGreater = "≯";
  var NotGreaterEqual = "≱";
  var NotGreaterFullEqual = "≧̸";
  var NotGreaterGreater = "≫̸";
  var NotGreaterLess = "≹";
  var NotGreaterSlantEqual = "⩾̸";
  var NotGreaterTilde = "≵";
  var NotHumpDownHump = "≎̸";
  var NotHumpEqual = "≏̸";
  var notin = "∉";
  var notindot = "⋵̸";
  var notinE = "⋹̸";
  var notinva = "∉";
  var notinvb = "⋷";
  var notinvc = "⋶";
  var NotLeftTriangleBar = "⧏̸";
  var NotLeftTriangle = "⋪";
  var NotLeftTriangleEqual = "⋬";
  var NotLess = "≮";
  var NotLessEqual = "≰";
  var NotLessGreater = "≸";
  var NotLessLess = "≪̸";
  var NotLessSlantEqual = "⩽̸";
  var NotLessTilde = "≴";
  var NotNestedGreaterGreater = "⪢̸";
  var NotNestedLessLess = "⪡̸";
  var notni = "∌";
  var notniva = "∌";
  var notnivb = "⋾";
  var notnivc = "⋽";
  var NotPrecedes = "⊀";
  var NotPrecedesEqual = "⪯̸";
  var NotPrecedesSlantEqual = "⋠";
  var NotReverseElement = "∌";
  var NotRightTriangleBar = "⧐̸";
  var NotRightTriangle = "⋫";
  var NotRightTriangleEqual = "⋭";
  var NotSquareSubset = "⊏̸";
  var NotSquareSubsetEqual = "⋢";
  var NotSquareSuperset = "⊐̸";
  var NotSquareSupersetEqual = "⋣";
  var NotSubset = "⊂⃒";
  var NotSubsetEqual = "⊈";
  var NotSucceeds = "⊁";
  var NotSucceedsEqual = "⪰̸";
  var NotSucceedsSlantEqual = "⋡";
  var NotSucceedsTilde = "≿̸";
  var NotSuperset = "⊃⃒";
  var NotSupersetEqual = "⊉";
  var NotTilde = "≁";
  var NotTildeEqual = "≄";
  var NotTildeFullEqual = "≇";
  var NotTildeTilde = "≉";
  var NotVerticalBar = "∤";
  var nparallel = "∦";
  var npar = "∦";
  var nparsl = "⫽⃥";
  var npart = "∂̸";
  var npolint = "⨔";
  var npr = "⊀";
  var nprcue = "⋠";
  var nprec = "⊀";
  var npreceq = "⪯̸";
  var npre = "⪯̸";
  var nrarrc = "⤳̸";
  var nrarr = "↛";
  var nrArr = "⇏";
  var nrarrw = "↝̸";
  var nrightarrow = "↛";
  var nRightarrow = "⇏";
  var nrtri = "⋫";
  var nrtrie = "⋭";
  var nsc = "⊁";
  var nsccue = "⋡";
  var nsce = "⪰̸";
  var Nscr = "𝒩";
  var nscr = "𝓃";
  var nshortmid = "∤";
  var nshortparallel = "∦";
  var nsim = "≁";
  var nsime = "≄";
  var nsimeq = "≄";
  var nsmid = "∤";
  var nspar = "∦";
  var nsqsube = "⋢";
  var nsqsupe = "⋣";
  var nsub = "⊄";
  var nsubE = "⫅̸";
  var nsube = "⊈";
  var nsubset = "⊂⃒";
  var nsubseteq = "⊈";
  var nsubseteqq = "⫅̸";
  var nsucc = "⊁";
  var nsucceq = "⪰̸";
  var nsup = "⊅";
  var nsupE = "⫆̸";
  var nsupe = "⊉";
  var nsupset = "⊃⃒";
  var nsupseteq = "⊉";
  var nsupseteqq = "⫆̸";
  var ntgl = "≹";
  var Ntilde = "Ñ";
  var ntilde = "ñ";
  var ntlg = "≸";
  var ntriangleleft = "⋪";
  var ntrianglelefteq = "⋬";
  var ntriangleright = "⋫";
  var ntrianglerighteq = "⋭";
  var Nu = "Ν";
  var nu = "ν";
  var num = "#";
  var numero = "№";
  var numsp = " ";
  var nvap = "≍⃒";
  var nvdash = "⊬";
  var nvDash = "⊭";
  var nVdash = "⊮";
  var nVDash = "⊯";
  var nvge = "≥⃒";
  var nvgt = ">⃒";
  var nvHarr = "⤄";
  var nvinfin = "⧞";
  var nvlArr = "⤂";
  var nvle = "≤⃒";
  var nvlt = "<⃒";
  var nvltrie = "⊴⃒";
  var nvrArr = "⤃";
  var nvrtrie = "⊵⃒";
  var nvsim = "∼⃒";
  var nwarhk = "⤣";
  var nwarr = "↖";
  var nwArr = "⇖";
  var nwarrow = "↖";
  var nwnear = "⤧";
  var Oacute = "Ó";
  var oacute = "ó";
  var oast = "⊛";
  var Ocirc = "Ô";
  var ocirc = "ô";
  var ocir = "⊚";
  var Ocy = "О";
  var ocy = "о";
  var odash = "⊝";
  var Odblac = "Ő";
  var odblac = "ő";
  var odiv = "⨸";
  var odot = "⊙";
  var odsold = "⦼";
  var OElig = "Œ";
  var oelig = "œ";
  var ofcir = "⦿";
  var Ofr = "𝔒";
  var ofr = "𝔬";
  var ogon = "˛";
  var Ograve = "Ò";
  var ograve = "ò";
  var ogt = "⧁";
  var ohbar = "⦵";
  var ohm = "Ω";
  var oint = "∮";
  var olarr = "↺";
  var olcir = "⦾";
  var olcross = "⦻";
  var oline = "‾";
  var olt = "⧀";
  var Omacr = "Ō";
  var omacr = "ō";
  var Omega = "Ω";
  var omega = "ω";
  var Omicron = "Ο";
  var omicron = "ο";
  var omid = "⦶";
  var ominus = "⊖";
  var Oopf = "𝕆";
  var oopf = "𝕠";
  var opar = "⦷";
  var OpenCurlyDoubleQuote = "“";
  var OpenCurlyQuote = "‘";
  var operp = "⦹";
  var oplus = "⊕";
  var orarr = "↻";
  var Or = "⩔";
  var or = "∨";
  var ord = "⩝";
  var order = "ℴ";
  var orderof = "ℴ";
  var ordf = "ª";
  var ordm = "º";
  var origof = "⊶";
  var oror = "⩖";
  var orslope = "⩗";
  var orv = "⩛";
  var oS = "Ⓢ";
  var Oscr = "𝒪";
  var oscr = "ℴ";
  var Oslash = "Ø";
  var oslash = "ø";
  var osol = "⊘";
  var Otilde = "Õ";
  var otilde = "õ";
  var otimesas = "⨶";
  var Otimes = "⨷";
  var otimes = "⊗";
  var Ouml = "Ö";
  var ouml = "ö";
  var ovbar = "⌽";
  var OverBar = "‾";
  var OverBrace = "⏞";
  var OverBracket = "⎴";
  var OverParenthesis = "⏜";
  var para = "¶";
  var parallel = "∥";
  var par = "∥";
  var parsim = "⫳";
  var parsl = "⫽";
  var part = "∂";
  var PartialD = "∂";
  var Pcy = "П";
  var pcy = "п";
  var percnt = "%";
  var period = ".";
  var permil = "‰";
  var perp = "⊥";
  var pertenk = "‱";
  var Pfr = "𝔓";
  var pfr = "𝔭";
  var Phi = "Φ";
  var phi = "φ";
  var phiv = "ϕ";
  var phmmat = "ℳ";
  var phone = "☎";
  var Pi = "Π";
  var pi = "π";
  var pitchfork = "⋔";
  var piv = "ϖ";
  var planck = "ℏ";
  var planckh = "ℎ";
  var plankv = "ℏ";
  var plusacir = "⨣";
  var plusb = "⊞";
  var pluscir = "⨢";
  var plus = "+";
  var plusdo = "∔";
  var plusdu = "⨥";
  var pluse = "⩲";
  var PlusMinus = "±";
  var plusmn = "±";
  var plussim = "⨦";
  var plustwo = "⨧";
  var pm = "±";
  var Poincareplane = "ℌ";
  var pointint = "⨕";
  var popf = "𝕡";
  var Popf = "ℙ";
  var pound = "£";
  var prap = "⪷";
  var Pr = "⪻";
  var pr = "≺";
  var prcue = "≼";
  var precapprox = "⪷";
  var prec = "≺";
  var preccurlyeq = "≼";
  var Precedes = "≺";
  var PrecedesEqual = "⪯";
  var PrecedesSlantEqual = "≼";
  var PrecedesTilde = "≾";
  var preceq = "⪯";
  var precnapprox = "⪹";
  var precneqq = "⪵";
  var precnsim = "⋨";
  var pre = "⪯";
  var prE = "⪳";
  var precsim = "≾";
  var prime = "′";
  var Prime = "″";
  var primes = "ℙ";
  var prnap = "⪹";
  var prnE = "⪵";
  var prnsim = "⋨";
  var prod = "∏";
  var Product = "∏";
  var profalar = "⌮";
  var profline = "⌒";
  var profsurf = "⌓";
  var prop = "∝";
  var Proportional = "∝";
  var Proportion = "∷";
  var propto = "∝";
  var prsim = "≾";
  var prurel = "⊰";
  var Pscr = "𝒫";
  var pscr = "𝓅";
  var Psi = "Ψ";
  var psi = "ψ";
  var puncsp = " ";
  var Qfr = "𝔔";
  var qfr = "𝔮";
  var qint = "⨌";
  var qopf = "𝕢";
  var Qopf = "ℚ";
  var qprime = "⁗";
  var Qscr = "𝒬";
  var qscr = "𝓆";
  var quaternions = "ℍ";
  var quatint = "⨖";
  var quest = "?";
  var questeq = "≟";
  var quot = "\"";
  var QUOT = "\"";
  var rAarr = "⇛";
  var race = "∽̱";
  var Racute = "Ŕ";
  var racute = "ŕ";
  var radic = "√";
  var raemptyv = "⦳";
  var rang = "⟩";
  var Rang = "⟫";
  var rangd = "⦒";
  var range = "⦥";
  var rangle = "⟩";
  var raquo = "»";
  var rarrap = "⥵";
  var rarrb = "⇥";
  var rarrbfs = "⤠";
  var rarrc = "⤳";
  var rarr = "→";
  var Rarr = "↠";
  var rArr = "⇒";
  var rarrfs = "⤞";
  var rarrhk = "↪";
  var rarrlp = "↬";
  var rarrpl = "⥅";
  var rarrsim = "⥴";
  var Rarrtl = "⤖";
  var rarrtl = "↣";
  var rarrw = "↝";
  var ratail = "⤚";
  var rAtail = "⤜";
  var ratio = "∶";
  var rationals = "ℚ";
  var rbarr = "⤍";
  var rBarr = "⤏";
  var RBarr = "⤐";
  var rbbrk = "❳";
  var rbrace = "}";
  var rbrack = "]";
  var rbrke = "⦌";
  var rbrksld = "⦎";
  var rbrkslu = "⦐";
  var Rcaron = "Ř";
  var rcaron = "ř";
  var Rcedil = "Ŗ";
  var rcedil = "ŗ";
  var rceil = "⌉";
  var rcub = "}";
  var Rcy = "Р";
  var rcy = "р";
  var rdca = "⤷";
  var rdldhar = "⥩";
  var rdquo = "”";
  var rdquor = "”";
  var rdsh = "↳";
  var real = "ℜ";
  var realine = "ℛ";
  var realpart = "ℜ";
  var reals = "ℝ";
  var Re = "ℜ";
  var rect = "▭";
  var reg = "®";
  var REG = "®";
  var ReverseElement = "∋";
  var ReverseEquilibrium = "⇋";
  var ReverseUpEquilibrium = "⥯";
  var rfisht = "⥽";
  var rfloor = "⌋";
  var rfr = "𝔯";
  var Rfr = "ℜ";
  var rHar = "⥤";
  var rhard = "⇁";
  var rharu = "⇀";
  var rharul = "⥬";
  var Rho = "Ρ";
  var rho = "ρ";
  var rhov = "ϱ";
  var RightAngleBracket = "⟩";
  var RightArrowBar = "⇥";
  var rightarrow = "→";
  var RightArrow = "→";
  var Rightarrow = "⇒";
  var RightArrowLeftArrow = "⇄";
  var rightarrowtail = "↣";
  var RightCeiling = "⌉";
  var RightDoubleBracket = "⟧";
  var RightDownTeeVector = "⥝";
  var RightDownVectorBar = "⥕";
  var RightDownVector = "⇂";
  var RightFloor = "⌋";
  var rightharpoondown = "⇁";
  var rightharpoonup = "⇀";
  var rightleftarrows = "⇄";
  var rightleftharpoons = "⇌";
  var rightrightarrows = "⇉";
  var rightsquigarrow = "↝";
  var RightTeeArrow = "↦";
  var RightTee = "⊢";
  var RightTeeVector = "⥛";
  var rightthreetimes = "⋌";
  var RightTriangleBar = "⧐";
  var RightTriangle = "⊳";
  var RightTriangleEqual = "⊵";
  var RightUpDownVector = "⥏";
  var RightUpTeeVector = "⥜";
  var RightUpVectorBar = "⥔";
  var RightUpVector = "↾";
  var RightVectorBar = "⥓";
  var RightVector = "⇀";
  var ring = "˚";
  var risingdotseq = "≓";
  var rlarr = "⇄";
  var rlhar = "⇌";
  var rlm = "‏";
  var rmoustache = "⎱";
  var rmoust = "⎱";
  var rnmid = "⫮";
  var roang = "⟭";
  var roarr = "⇾";
  var robrk = "⟧";
  var ropar = "⦆";
  var ropf = "𝕣";
  var Ropf = "ℝ";
  var roplus = "⨮";
  var rotimes = "⨵";
  var RoundImplies = "⥰";
  var rpar = ")";
  var rpargt = "⦔";
  var rppolint = "⨒";
  var rrarr = "⇉";
  var Rrightarrow = "⇛";
  var rsaquo = "›";
  var rscr = "𝓇";
  var Rscr = "ℛ";
  var rsh = "↱";
  var Rsh = "↱";
  var rsqb = "]";
  var rsquo = "’";
  var rsquor = "’";
  var rthree = "⋌";
  var rtimes = "⋊";
  var rtri = "▹";
  var rtrie = "⊵";
  var rtrif = "▸";
  var rtriltri = "⧎";
  var RuleDelayed = "⧴";
  var ruluhar = "⥨";
  var rx = "℞";
  var Sacute = "Ś";
  var sacute = "ś";
  var sbquo = "‚";
  var scap = "⪸";
  var Scaron = "Š";
  var scaron = "š";
  var Sc = "⪼";
  var sc = "≻";
  var sccue = "≽";
  var sce = "⪰";
  var scE = "⪴";
  var Scedil = "Ş";
  var scedil = "ş";
  var Scirc = "Ŝ";
  var scirc = "ŝ";
  var scnap = "⪺";
  var scnE = "⪶";
  var scnsim = "⋩";
  var scpolint = "⨓";
  var scsim = "≿";
  var Scy = "С";
  var scy = "с";
  var sdotb = "⊡";
  var sdot = "⋅";
  var sdote = "⩦";
  var searhk = "⤥";
  var searr = "↘";
  var seArr = "⇘";
  var searrow = "↘";
  var sect = "§";
  var semi = ";";
  var seswar = "⤩";
  var setminus = "∖";
  var setmn = "∖";
  var sext = "✶";
  var Sfr = "𝔖";
  var sfr = "𝔰";
  var sfrown = "⌢";
  var sharp = "♯";
  var SHCHcy = "Щ";
  var shchcy = "щ";
  var SHcy = "Ш";
  var shcy = "ш";
  var ShortDownArrow = "↓";
  var ShortLeftArrow = "←";
  var shortmid = "∣";
  var shortparallel = "∥";
  var ShortRightArrow = "→";
  var ShortUpArrow = "↑";
  var shy = "­";
  var Sigma = "Σ";
  var sigma = "σ";
  var sigmaf = "ς";
  var sigmav = "ς";
  var sim = "∼";
  var simdot = "⩪";
  var sime = "≃";
  var simeq = "≃";
  var simg = "⪞";
  var simgE = "⪠";
  var siml = "⪝";
  var simlE = "⪟";
  var simne = "≆";
  var simplus = "⨤";
  var simrarr = "⥲";
  var slarr = "←";
  var SmallCircle = "∘";
  var smallsetminus = "∖";
  var smashp = "⨳";
  var smeparsl = "⧤";
  var smid = "∣";
  var smile = "⌣";
  var smt = "⪪";
  var smte = "⪬";
  var smtes = "⪬︀";
  var SOFTcy = "Ь";
  var softcy = "ь";
  var solbar = "⌿";
  var solb = "⧄";
  var sol = "/";
  var Sopf = "𝕊";
  var sopf = "𝕤";
  var spades = "♠";
  var spadesuit = "♠";
  var spar = "∥";
  var sqcap = "⊓";
  var sqcaps = "⊓︀";
  var sqcup = "⊔";
  var sqcups = "⊔︀";
  var Sqrt = "√";
  var sqsub = "⊏";
  var sqsube = "⊑";
  var sqsubset = "⊏";
  var sqsubseteq = "⊑";
  var sqsup = "⊐";
  var sqsupe = "⊒";
  var sqsupset = "⊐";
  var sqsupseteq = "⊒";
  var square = "□";
  var Square = "□";
  var SquareIntersection = "⊓";
  var SquareSubset = "⊏";
  var SquareSubsetEqual = "⊑";
  var SquareSuperset = "⊐";
  var SquareSupersetEqual = "⊒";
  var SquareUnion = "⊔";
  var squarf = "▪";
  var squ = "□";
  var squf = "▪";
  var srarr = "→";
  var Sscr = "𝒮";
  var sscr = "𝓈";
  var ssetmn = "∖";
  var ssmile = "⌣";
  var sstarf = "⋆";
  var Star = "⋆";
  var star = "☆";
  var starf = "★";
  var straightepsilon = "ϵ";
  var straightphi = "ϕ";
  var strns = "¯";
  var sub = "⊂";
  var Sub = "⋐";
  var subdot = "⪽";
  var subE = "⫅";
  var sube = "⊆";
  var subedot = "⫃";
  var submult = "⫁";
  var subnE = "⫋";
  var subne = "⊊";
  var subplus = "⪿";
  var subrarr = "⥹";
  var subset = "⊂";
  var Subset = "⋐";
  var subseteq = "⊆";
  var subseteqq = "⫅";
  var SubsetEqual = "⊆";
  var subsetneq = "⊊";
  var subsetneqq = "⫋";
  var subsim = "⫇";
  var subsub = "⫕";
  var subsup = "⫓";
  var succapprox = "⪸";
  var succ = "≻";
  var succcurlyeq = "≽";
  var Succeeds = "≻";
  var SucceedsEqual = "⪰";
  var SucceedsSlantEqual = "≽";
  var SucceedsTilde = "≿";
  var succeq = "⪰";
  var succnapprox = "⪺";
  var succneqq = "⪶";
  var succnsim = "⋩";
  var succsim = "≿";
  var SuchThat = "∋";
  var sum = "∑";
  var Sum = "∑";
  var sung = "♪";
  var sup1 = "¹";
  var sup2 = "²";
  var sup3 = "³";
  var sup = "⊃";
  var Sup = "⋑";
  var supdot = "⪾";
  var supdsub = "⫘";
  var supE = "⫆";
  var supe = "⊇";
  var supedot = "⫄";
  var Superset = "⊃";
  var SupersetEqual = "⊇";
  var suphsol = "⟉";
  var suphsub = "⫗";
  var suplarr = "⥻";
  var supmult = "⫂";
  var supnE = "⫌";
  var supne = "⊋";
  var supplus = "⫀";
  var supset = "⊃";
  var Supset = "⋑";
  var supseteq = "⊇";
  var supseteqq = "⫆";
  var supsetneq = "⊋";
  var supsetneqq = "⫌";
  var supsim = "⫈";
  var supsub = "⫔";
  var supsup = "⫖";
  var swarhk = "⤦";
  var swarr = "↙";
  var swArr = "⇙";
  var swarrow = "↙";
  var swnwar = "⤪";
  var szlig = "ß";
  var Tab = "\t";
  var target = "⌖";
  var Tau = "Τ";
  var tau = "τ";
  var tbrk = "⎴";
  var Tcaron = "Ť";
  var tcaron = "ť";
  var Tcedil = "Ţ";
  var tcedil = "ţ";
  var Tcy = "Т";
  var tcy = "т";
  var tdot = "⃛";
  var telrec = "⌕";
  var Tfr = "𝔗";
  var tfr = "𝔱";
  var there4 = "∴";
  var therefore = "∴";
  var Therefore = "∴";
  var Theta = "Θ";
  var theta = "θ";
  var thetasym = "ϑ";
  var thetav = "ϑ";
  var thickapprox = "≈";
  var thicksim = "∼";
  var ThickSpace = "  ";
  var ThinSpace = " ";
  var thinsp = " ";
  var thkap = "≈";
  var thksim = "∼";
  var THORN = "Þ";
  var thorn = "þ";
  var tilde = "˜";
  var Tilde = "∼";
  var TildeEqual = "≃";
  var TildeFullEqual = "≅";
  var TildeTilde = "≈";
  var timesbar = "⨱";
  var timesb = "⊠";
  var times = "×";
  var timesd = "⨰";
  var tint = "∭";
  var toea = "⤨";
  var topbot = "⌶";
  var topcir = "⫱";
  var top = "⊤";
  var Topf = "𝕋";
  var topf = "𝕥";
  var topfork = "⫚";
  var tosa = "⤩";
  var tprime = "‴";
  var trade = "™";
  var TRADE = "™";
  var triangle = "▵";
  var triangledown = "▿";
  var triangleleft = "◃";
  var trianglelefteq = "⊴";
  var triangleq = "≜";
  var triangleright = "▹";
  var trianglerighteq = "⊵";
  var tridot = "◬";
  var trie = "≜";
  var triminus = "⨺";
  var TripleDot = "⃛";
  var triplus = "⨹";
  var trisb = "⧍";
  var tritime = "⨻";
  var trpezium = "⏢";
  var Tscr = "𝒯";
  var tscr = "𝓉";
  var TScy = "Ц";
  var tscy = "ц";
  var TSHcy = "Ћ";
  var tshcy = "ћ";
  var Tstrok = "Ŧ";
  var tstrok = "ŧ";
  var twixt = "≬";
  var twoheadleftarrow = "↞";
  var twoheadrightarrow = "↠";
  var Uacute = "Ú";
  var uacute = "ú";
  var uarr = "↑";
  var Uarr = "↟";
  var uArr = "⇑";
  var Uarrocir = "⥉";
  var Ubrcy = "Ў";
  var ubrcy = "ў";
  var Ubreve = "Ŭ";
  var ubreve = "ŭ";
  var Ucirc = "Û";
  var ucirc = "û";
  var Ucy = "У";
  var ucy = "у";
  var udarr = "⇅";
  var Udblac = "Ű";
  var udblac = "ű";
  var udhar = "⥮";
  var ufisht = "⥾";
  var Ufr = "𝔘";
  var ufr = "𝔲";
  var Ugrave = "Ù";
  var ugrave = "ù";
  var uHar = "⥣";
  var uharl = "↿";
  var uharr = "↾";
  var uhblk = "▀";
  var ulcorn = "⌜";
  var ulcorner = "⌜";
  var ulcrop = "⌏";
  var ultri = "◸";
  var Umacr = "Ū";
  var umacr = "ū";
  var uml = "¨";
  var UnderBar = "_";
  var UnderBrace = "⏟";
  var UnderBracket = "⎵";
  var UnderParenthesis = "⏝";
  var Union = "⋃";
  var UnionPlus = "⊎";
  var Uogon = "Ų";
  var uogon = "ų";
  var Uopf = "𝕌";
  var uopf = "𝕦";
  var UpArrowBar = "⤒";
  var uparrow = "↑";
  var UpArrow = "↑";
  var Uparrow = "⇑";
  var UpArrowDownArrow = "⇅";
  var updownarrow = "↕";
  var UpDownArrow = "↕";
  var Updownarrow = "⇕";
  var UpEquilibrium = "⥮";
  var upharpoonleft = "↿";
  var upharpoonright = "↾";
  var uplus = "⊎";
  var UpperLeftArrow = "↖";
  var UpperRightArrow = "↗";
  var upsi = "υ";
  var Upsi = "ϒ";
  var upsih = "ϒ";
  var Upsilon = "Υ";
  var upsilon = "υ";
  var UpTeeArrow = "↥";
  var UpTee = "⊥";
  var upuparrows = "⇈";
  var urcorn = "⌝";
  var urcorner = "⌝";
  var urcrop = "⌎";
  var Uring = "Ů";
  var uring = "ů";
  var urtri = "◹";
  var Uscr = "𝒰";
  var uscr = "𝓊";
  var utdot = "⋰";
  var Utilde = "Ũ";
  var utilde = "ũ";
  var utri = "▵";
  var utrif = "▴";
  var uuarr = "⇈";
  var Uuml = "Ü";
  var uuml = "ü";
  var uwangle = "⦧";
  var vangrt = "⦜";
  var varepsilon = "ϵ";
  var varkappa = "ϰ";
  var varnothing = "∅";
  var varphi = "ϕ";
  var varpi = "ϖ";
  var varpropto = "∝";
  var varr = "↕";
  var vArr = "⇕";
  var varrho = "ϱ";
  var varsigma = "ς";
  var varsubsetneq = "⊊︀";
  var varsubsetneqq = "⫋︀";
  var varsupsetneq = "⊋︀";
  var varsupsetneqq = "⫌︀";
  var vartheta = "ϑ";
  var vartriangleleft = "⊲";
  var vartriangleright = "⊳";
  var vBar = "⫨";
  var Vbar = "⫫";
  var vBarv = "⫩";
  var Vcy = "В";
  var vcy = "в";
  var vdash = "⊢";
  var vDash = "⊨";
  var Vdash = "⊩";
  var VDash = "⊫";
  var Vdashl = "⫦";
  var veebar = "⊻";
  var vee = "∨";
  var Vee = "⋁";
  var veeeq = "≚";
  var vellip = "⋮";
  var verbar = "|";
  var Verbar = "‖";
  var vert = "|";
  var Vert = "‖";
  var VerticalBar = "∣";
  var VerticalLine = "|";
  var VerticalSeparator = "❘";
  var VerticalTilde = "≀";
  var VeryThinSpace = " ";
  var Vfr = "𝔙";
  var vfr = "𝔳";
  var vltri = "⊲";
  var vnsub = "⊂⃒";
  var vnsup = "⊃⃒";
  var Vopf = "𝕍";
  var vopf = "𝕧";
  var vprop = "∝";
  var vrtri = "⊳";
  var Vscr = "𝒱";
  var vscr = "𝓋";
  var vsubnE = "⫋︀";
  var vsubne = "⊊︀";
  var vsupnE = "⫌︀";
  var vsupne = "⊋︀";
  var Vvdash = "⊪";
  var vzigzag = "⦚";
  var Wcirc = "Ŵ";
  var wcirc = "ŵ";
  var wedbar = "⩟";
  var wedge = "∧";
  var Wedge = "⋀";
  var wedgeq = "≙";
  var weierp = "℘";
  var Wfr = "𝔚";
  var wfr = "𝔴";
  var Wopf = "𝕎";
  var wopf = "𝕨";
  var wp = "℘";
  var wr = "≀";
  var wreath = "≀";
  var Wscr = "𝒲";
  var wscr = "𝓌";
  var xcap = "⋂";
  var xcirc = "◯";
  var xcup = "⋃";
  var xdtri = "▽";
  var Xfr = "𝔛";
  var xfr = "𝔵";
  var xharr = "⟷";
  var xhArr = "⟺";
  var Xi = "Ξ";
  var xi = "ξ";
  var xlarr = "⟵";
  var xlArr = "⟸";
  var xmap = "⟼";
  var xnis = "⋻";
  var xodot = "⨀";
  var Xopf = "𝕏";
  var xopf = "𝕩";
  var xoplus = "⨁";
  var xotime = "⨂";
  var xrarr = "⟶";
  var xrArr = "⟹";
  var Xscr = "𝒳";
  var xscr = "𝓍";
  var xsqcup = "⨆";
  var xuplus = "⨄";
  var xutri = "△";
  var xvee = "⋁";
  var xwedge = "⋀";
  var Yacute = "Ý";
  var yacute = "ý";
  var YAcy = "Я";
  var yacy = "я";
  var Ycirc = "Ŷ";
  var ycirc = "ŷ";
  var Ycy = "Ы";
  var ycy = "ы";
  var yen = "¥";
  var Yfr = "𝔜";
  var yfr = "𝔶";
  var YIcy = "Ї";
  var yicy = "ї";
  var Yopf = "𝕐";
  var yopf = "𝕪";
  var Yscr = "𝒴";
  var yscr = "𝓎";
  var YUcy = "Ю";
  var yucy = "ю";
  var yuml = "ÿ";
  var Yuml = "Ÿ";
  var Zacute = "Ź";
  var zacute = "ź";
  var Zcaron = "Ž";
  var zcaron = "ž";
  var Zcy = "З";
  var zcy = "з";
  var Zdot = "Ż";
  var zdot = "ż";
  var zeetrf = "ℨ";
  var ZeroWidthSpace = "​";
  var Zeta = "Ζ";
  var zeta = "ζ";
  var zfr = "𝔷";
  var Zfr = "ℨ";
  var ZHcy = "Ж";
  var zhcy = "ж";
  var zigrarr = "⇝";
  var zopf = "𝕫";
  var Zopf = "ℤ";
  var Zscr = "𝒵";
  var zscr = "𝓏";
  var zwj = "‍";
  var zwnj = "‌";
  var entities = {
  	Aacute: Aacute,
  	aacute: aacute,
  	Abreve: Abreve,
  	abreve: abreve,
  	ac: ac,
  	acd: acd,
  	acE: acE,
  	Acirc: Acirc,
  	acirc: acirc,
  	acute: acute,
  	Acy: Acy,
  	acy: acy,
  	AElig: AElig,
  	aelig: aelig,
  	af: af,
  	Afr: Afr,
  	afr: afr,
  	Agrave: Agrave,
  	agrave: agrave,
  	alefsym: alefsym,
  	aleph: aleph,
  	Alpha: Alpha,
  	alpha: alpha,
  	Amacr: Amacr,
  	amacr: amacr,
  	amalg: amalg,
  	amp: amp,
  	AMP: AMP,
  	andand: andand,
  	And: And,
  	and: and,
  	andd: andd,
  	andslope: andslope,
  	andv: andv,
  	ang: ang,
  	ange: ange,
  	angle: angle,
  	angmsdaa: angmsdaa,
  	angmsdab: angmsdab,
  	angmsdac: angmsdac,
  	angmsdad: angmsdad,
  	angmsdae: angmsdae,
  	angmsdaf: angmsdaf,
  	angmsdag: angmsdag,
  	angmsdah: angmsdah,
  	angmsd: angmsd,
  	angrt: angrt,
  	angrtvb: angrtvb,
  	angrtvbd: angrtvbd,
  	angsph: angsph,
  	angst: angst,
  	angzarr: angzarr,
  	Aogon: Aogon,
  	aogon: aogon,
  	Aopf: Aopf,
  	aopf: aopf,
  	apacir: apacir,
  	ap: ap,
  	apE: apE,
  	ape: ape,
  	apid: apid,
  	apos: apos,
  	ApplyFunction: ApplyFunction,
  	approx: approx,
  	approxeq: approxeq,
  	Aring: Aring,
  	aring: aring,
  	Ascr: Ascr,
  	ascr: ascr,
  	Assign: Assign,
  	ast: ast,
  	asymp: asymp,
  	asympeq: asympeq,
  	Atilde: Atilde,
  	atilde: atilde,
  	Auml: Auml,
  	auml: auml,
  	awconint: awconint,
  	awint: awint,
  	backcong: backcong,
  	backepsilon: backepsilon,
  	backprime: backprime,
  	backsim: backsim,
  	backsimeq: backsimeq,
  	Backslash: Backslash,
  	Barv: Barv,
  	barvee: barvee,
  	barwed: barwed,
  	Barwed: Barwed,
  	barwedge: barwedge,
  	bbrk: bbrk,
  	bbrktbrk: bbrktbrk,
  	bcong: bcong,
  	Bcy: Bcy,
  	bcy: bcy,
  	bdquo: bdquo,
  	becaus: becaus,
  	because: because,
  	Because: Because,
  	bemptyv: bemptyv,
  	bepsi: bepsi,
  	bernou: bernou,
  	Bernoullis: Bernoullis,
  	Beta: Beta,
  	beta: beta,
  	beth: beth,
  	between: between,
  	Bfr: Bfr,
  	bfr: bfr,
  	bigcap: bigcap,
  	bigcirc: bigcirc,
  	bigcup: bigcup,
  	bigodot: bigodot,
  	bigoplus: bigoplus,
  	bigotimes: bigotimes,
  	bigsqcup: bigsqcup,
  	bigstar: bigstar,
  	bigtriangledown: bigtriangledown,
  	bigtriangleup: bigtriangleup,
  	biguplus: biguplus,
  	bigvee: bigvee,
  	bigwedge: bigwedge,
  	bkarow: bkarow,
  	blacklozenge: blacklozenge,
  	blacksquare: blacksquare,
  	blacktriangle: blacktriangle,
  	blacktriangledown: blacktriangledown,
  	blacktriangleleft: blacktriangleleft,
  	blacktriangleright: blacktriangleright,
  	blank: blank,
  	blk12: blk12,
  	blk14: blk14,
  	blk34: blk34,
  	block: block,
  	bne: bne,
  	bnequiv: bnequiv,
  	bNot: bNot,
  	bnot: bnot,
  	Bopf: Bopf,
  	bopf: bopf,
  	bot: bot,
  	bottom: bottom,
  	bowtie: bowtie,
  	boxbox: boxbox,
  	boxdl: boxdl,
  	boxdL: boxdL,
  	boxDl: boxDl,
  	boxDL: boxDL,
  	boxdr: boxdr,
  	boxdR: boxdR,
  	boxDr: boxDr,
  	boxDR: boxDR,
  	boxh: boxh,
  	boxH: boxH,
  	boxhd: boxhd,
  	boxHd: boxHd,
  	boxhD: boxhD,
  	boxHD: boxHD,
  	boxhu: boxhu,
  	boxHu: boxHu,
  	boxhU: boxhU,
  	boxHU: boxHU,
  	boxminus: boxminus,
  	boxplus: boxplus,
  	boxtimes: boxtimes,
  	boxul: boxul,
  	boxuL: boxuL,
  	boxUl: boxUl,
  	boxUL: boxUL,
  	boxur: boxur,
  	boxuR: boxuR,
  	boxUr: boxUr,
  	boxUR: boxUR,
  	boxv: boxv,
  	boxV: boxV,
  	boxvh: boxvh,
  	boxvH: boxvH,
  	boxVh: boxVh,
  	boxVH: boxVH,
  	boxvl: boxvl,
  	boxvL: boxvL,
  	boxVl: boxVl,
  	boxVL: boxVL,
  	boxvr: boxvr,
  	boxvR: boxvR,
  	boxVr: boxVr,
  	boxVR: boxVR,
  	bprime: bprime,
  	breve: breve,
  	Breve: Breve,
  	brvbar: brvbar,
  	bscr: bscr,
  	Bscr: Bscr,
  	bsemi: bsemi,
  	bsim: bsim,
  	bsime: bsime,
  	bsolb: bsolb,
  	bsol: bsol,
  	bsolhsub: bsolhsub,
  	bull: bull,
  	bullet: bullet,
  	bump: bump,
  	bumpE: bumpE,
  	bumpe: bumpe,
  	Bumpeq: Bumpeq,
  	bumpeq: bumpeq,
  	Cacute: Cacute,
  	cacute: cacute,
  	capand: capand,
  	capbrcup: capbrcup,
  	capcap: capcap,
  	cap: cap,
  	Cap: Cap,
  	capcup: capcup,
  	capdot: capdot,
  	CapitalDifferentialD: CapitalDifferentialD,
  	caps: caps,
  	caret: caret,
  	caron: caron,
  	Cayleys: Cayleys,
  	ccaps: ccaps,
  	Ccaron: Ccaron,
  	ccaron: ccaron,
  	Ccedil: Ccedil,
  	ccedil: ccedil,
  	Ccirc: Ccirc,
  	ccirc: ccirc,
  	Cconint: Cconint,
  	ccups: ccups,
  	ccupssm: ccupssm,
  	Cdot: Cdot,
  	cdot: cdot,
  	cedil: cedil,
  	Cedilla: Cedilla,
  	cemptyv: cemptyv,
  	cent: cent,
  	centerdot: centerdot,
  	CenterDot: CenterDot,
  	cfr: cfr,
  	Cfr: Cfr,
  	CHcy: CHcy,
  	chcy: chcy,
  	check: check,
  	checkmark: checkmark,
  	Chi: Chi,
  	chi: chi,
  	circ: circ,
  	circeq: circeq,
  	circlearrowleft: circlearrowleft,
  	circlearrowright: circlearrowright,
  	circledast: circledast,
  	circledcirc: circledcirc,
  	circleddash: circleddash,
  	CircleDot: CircleDot,
  	circledR: circledR,
  	circledS: circledS,
  	CircleMinus: CircleMinus,
  	CirclePlus: CirclePlus,
  	CircleTimes: CircleTimes,
  	cir: cir,
  	cirE: cirE,
  	cire: cire,
  	cirfnint: cirfnint,
  	cirmid: cirmid,
  	cirscir: cirscir,
  	ClockwiseContourIntegral: ClockwiseContourIntegral,
  	CloseCurlyDoubleQuote: CloseCurlyDoubleQuote,
  	CloseCurlyQuote: CloseCurlyQuote,
  	clubs: clubs,
  	clubsuit: clubsuit,
  	colon: colon,
  	Colon: Colon,
  	Colone: Colone,
  	colone: colone,
  	coloneq: coloneq,
  	comma: comma,
  	commat: commat,
  	comp: comp,
  	compfn: compfn,
  	complement: complement,
  	complexes: complexes,
  	cong: cong,
  	congdot: congdot,
  	Congruent: Congruent,
  	conint: conint,
  	Conint: Conint,
  	ContourIntegral: ContourIntegral,
  	copf: copf,
  	Copf: Copf,
  	coprod: coprod,
  	Coproduct: Coproduct,
  	copy: copy,
  	COPY: COPY,
  	copysr: copysr,
  	CounterClockwiseContourIntegral: CounterClockwiseContourIntegral,
  	crarr: crarr,
  	cross: cross,
  	Cross: Cross,
  	Cscr: Cscr,
  	cscr: cscr,
  	csub: csub,
  	csube: csube,
  	csup: csup,
  	csupe: csupe,
  	ctdot: ctdot,
  	cudarrl: cudarrl,
  	cudarrr: cudarrr,
  	cuepr: cuepr,
  	cuesc: cuesc,
  	cularr: cularr,
  	cularrp: cularrp,
  	cupbrcap: cupbrcap,
  	cupcap: cupcap,
  	CupCap: CupCap,
  	cup: cup,
  	Cup: Cup,
  	cupcup: cupcup,
  	cupdot: cupdot,
  	cupor: cupor,
  	cups: cups,
  	curarr: curarr,
  	curarrm: curarrm,
  	curlyeqprec: curlyeqprec,
  	curlyeqsucc: curlyeqsucc,
  	curlyvee: curlyvee,
  	curlywedge: curlywedge,
  	curren: curren,
  	curvearrowleft: curvearrowleft,
  	curvearrowright: curvearrowright,
  	cuvee: cuvee,
  	cuwed: cuwed,
  	cwconint: cwconint,
  	cwint: cwint,
  	cylcty: cylcty,
  	dagger: dagger,
  	Dagger: Dagger,
  	daleth: daleth,
  	darr: darr,
  	Darr: Darr,
  	dArr: dArr,
  	dash: dash,
  	Dashv: Dashv,
  	dashv: dashv,
  	dbkarow: dbkarow,
  	dblac: dblac,
  	Dcaron: Dcaron,
  	dcaron: dcaron,
  	Dcy: Dcy,
  	dcy: dcy,
  	ddagger: ddagger,
  	ddarr: ddarr,
  	DD: DD,
  	dd: dd,
  	DDotrahd: DDotrahd,
  	ddotseq: ddotseq,
  	deg: deg,
  	Del: Del,
  	Delta: Delta,
  	delta: delta,
  	demptyv: demptyv,
  	dfisht: dfisht,
  	Dfr: Dfr,
  	dfr: dfr,
  	dHar: dHar,
  	dharl: dharl,
  	dharr: dharr,
  	DiacriticalAcute: DiacriticalAcute,
  	DiacriticalDot: DiacriticalDot,
  	DiacriticalDoubleAcute: DiacriticalDoubleAcute,
  	DiacriticalGrave: DiacriticalGrave,
  	DiacriticalTilde: DiacriticalTilde,
  	diam: diam,
  	diamond: diamond,
  	Diamond: Diamond,
  	diamondsuit: diamondsuit,
  	diams: diams,
  	die: die,
  	DifferentialD: DifferentialD,
  	digamma: digamma,
  	disin: disin,
  	div: div,
  	divide: divide,
  	divideontimes: divideontimes,
  	divonx: divonx,
  	DJcy: DJcy,
  	djcy: djcy,
  	dlcorn: dlcorn,
  	dlcrop: dlcrop,
  	dollar: dollar,
  	Dopf: Dopf,
  	dopf: dopf,
  	Dot: Dot,
  	dot: dot,
  	DotDot: DotDot,
  	doteq: doteq,
  	doteqdot: doteqdot,
  	DotEqual: DotEqual,
  	dotminus: dotminus,
  	dotplus: dotplus,
  	dotsquare: dotsquare,
  	doublebarwedge: doublebarwedge,
  	DoubleContourIntegral: DoubleContourIntegral,
  	DoubleDot: DoubleDot,
  	DoubleDownArrow: DoubleDownArrow,
  	DoubleLeftArrow: DoubleLeftArrow,
  	DoubleLeftRightArrow: DoubleLeftRightArrow,
  	DoubleLeftTee: DoubleLeftTee,
  	DoubleLongLeftArrow: DoubleLongLeftArrow,
  	DoubleLongLeftRightArrow: DoubleLongLeftRightArrow,
  	DoubleLongRightArrow: DoubleLongRightArrow,
  	DoubleRightArrow: DoubleRightArrow,
  	DoubleRightTee: DoubleRightTee,
  	DoubleUpArrow: DoubleUpArrow,
  	DoubleUpDownArrow: DoubleUpDownArrow,
  	DoubleVerticalBar: DoubleVerticalBar,
  	DownArrowBar: DownArrowBar,
  	downarrow: downarrow,
  	DownArrow: DownArrow,
  	Downarrow: Downarrow,
  	DownArrowUpArrow: DownArrowUpArrow,
  	DownBreve: DownBreve,
  	downdownarrows: downdownarrows,
  	downharpoonleft: downharpoonleft,
  	downharpoonright: downharpoonright,
  	DownLeftRightVector: DownLeftRightVector,
  	DownLeftTeeVector: DownLeftTeeVector,
  	DownLeftVectorBar: DownLeftVectorBar,
  	DownLeftVector: DownLeftVector,
  	DownRightTeeVector: DownRightTeeVector,
  	DownRightVectorBar: DownRightVectorBar,
  	DownRightVector: DownRightVector,
  	DownTeeArrow: DownTeeArrow,
  	DownTee: DownTee,
  	drbkarow: drbkarow,
  	drcorn: drcorn,
  	drcrop: drcrop,
  	Dscr: Dscr,
  	dscr: dscr,
  	DScy: DScy,
  	dscy: dscy,
  	dsol: dsol,
  	Dstrok: Dstrok,
  	dstrok: dstrok,
  	dtdot: dtdot,
  	dtri: dtri,
  	dtrif: dtrif,
  	duarr: duarr,
  	duhar: duhar,
  	dwangle: dwangle,
  	DZcy: DZcy,
  	dzcy: dzcy,
  	dzigrarr: dzigrarr,
  	Eacute: Eacute,
  	eacute: eacute,
  	easter: easter,
  	Ecaron: Ecaron,
  	ecaron: ecaron,
  	Ecirc: Ecirc,
  	ecirc: ecirc,
  	ecir: ecir,
  	ecolon: ecolon,
  	Ecy: Ecy,
  	ecy: ecy,
  	eDDot: eDDot,
  	Edot: Edot,
  	edot: edot,
  	eDot: eDot,
  	ee: ee,
  	efDot: efDot,
  	Efr: Efr,
  	efr: efr,
  	eg: eg,
  	Egrave: Egrave,
  	egrave: egrave,
  	egs: egs,
  	egsdot: egsdot,
  	el: el,
  	Element: Element,
  	elinters: elinters,
  	ell: ell,
  	els: els,
  	elsdot: elsdot,
  	Emacr: Emacr,
  	emacr: emacr,
  	empty: empty,
  	emptyset: emptyset,
  	EmptySmallSquare: EmptySmallSquare,
  	emptyv: emptyv,
  	EmptyVerySmallSquare: EmptyVerySmallSquare,
  	emsp13: emsp13,
  	emsp14: emsp14,
  	emsp: emsp,
  	ENG: ENG,
  	eng: eng,
  	ensp: ensp,
  	Eogon: Eogon,
  	eogon: eogon,
  	Eopf: Eopf,
  	eopf: eopf,
  	epar: epar,
  	eparsl: eparsl,
  	eplus: eplus,
  	epsi: epsi,
  	Epsilon: Epsilon,
  	epsilon: epsilon,
  	epsiv: epsiv,
  	eqcirc: eqcirc,
  	eqcolon: eqcolon,
  	eqsim: eqsim,
  	eqslantgtr: eqslantgtr,
  	eqslantless: eqslantless,
  	Equal: Equal,
  	equals: equals,
  	EqualTilde: EqualTilde,
  	equest: equest,
  	Equilibrium: Equilibrium,
  	equiv: equiv,
  	equivDD: equivDD,
  	eqvparsl: eqvparsl,
  	erarr: erarr,
  	erDot: erDot,
  	escr: escr,
  	Escr: Escr,
  	esdot: esdot,
  	Esim: Esim,
  	esim: esim,
  	Eta: Eta,
  	eta: eta,
  	ETH: ETH,
  	eth: eth,
  	Euml: Euml,
  	euml: euml,
  	euro: euro,
  	excl: excl,
  	exist: exist,
  	Exists: Exists,
  	expectation: expectation,
  	exponentiale: exponentiale,
  	ExponentialE: ExponentialE,
  	fallingdotseq: fallingdotseq,
  	Fcy: Fcy,
  	fcy: fcy,
  	female: female,
  	ffilig: ffilig,
  	fflig: fflig,
  	ffllig: ffllig,
  	Ffr: Ffr,
  	ffr: ffr,
  	filig: filig,
  	FilledSmallSquare: FilledSmallSquare,
  	FilledVerySmallSquare: FilledVerySmallSquare,
  	fjlig: fjlig,
  	flat: flat,
  	fllig: fllig,
  	fltns: fltns,
  	fnof: fnof,
  	Fopf: Fopf,
  	fopf: fopf,
  	forall: forall,
  	ForAll: ForAll,
  	fork: fork,
  	forkv: forkv,
  	Fouriertrf: Fouriertrf,
  	fpartint: fpartint,
  	frac12: frac12,
  	frac13: frac13,
  	frac14: frac14,
  	frac15: frac15,
  	frac16: frac16,
  	frac18: frac18,
  	frac23: frac23,
  	frac25: frac25,
  	frac34: frac34,
  	frac35: frac35,
  	frac38: frac38,
  	frac45: frac45,
  	frac56: frac56,
  	frac58: frac58,
  	frac78: frac78,
  	frasl: frasl,
  	frown: frown,
  	fscr: fscr,
  	Fscr: Fscr,
  	gacute: gacute,
  	Gamma: Gamma,
  	gamma: gamma,
  	Gammad: Gammad,
  	gammad: gammad,
  	gap: gap,
  	Gbreve: Gbreve,
  	gbreve: gbreve,
  	Gcedil: Gcedil,
  	Gcirc: Gcirc,
  	gcirc: gcirc,
  	Gcy: Gcy,
  	gcy: gcy,
  	Gdot: Gdot,
  	gdot: gdot,
  	ge: ge,
  	gE: gE,
  	gEl: gEl,
  	gel: gel,
  	geq: geq,
  	geqq: geqq,
  	geqslant: geqslant,
  	gescc: gescc,
  	ges: ges,
  	gesdot: gesdot,
  	gesdoto: gesdoto,
  	gesdotol: gesdotol,
  	gesl: gesl,
  	gesles: gesles,
  	Gfr: Gfr,
  	gfr: gfr,
  	gg: gg,
  	Gg: Gg,
  	ggg: ggg,
  	gimel: gimel,
  	GJcy: GJcy,
  	gjcy: gjcy,
  	gla: gla,
  	gl: gl,
  	glE: glE,
  	glj: glj,
  	gnap: gnap,
  	gnapprox: gnapprox,
  	gne: gne,
  	gnE: gnE,
  	gneq: gneq,
  	gneqq: gneqq,
  	gnsim: gnsim,
  	Gopf: Gopf,
  	gopf: gopf,
  	grave: grave,
  	GreaterEqual: GreaterEqual,
  	GreaterEqualLess: GreaterEqualLess,
  	GreaterFullEqual: GreaterFullEqual,
  	GreaterGreater: GreaterGreater,
  	GreaterLess: GreaterLess,
  	GreaterSlantEqual: GreaterSlantEqual,
  	GreaterTilde: GreaterTilde,
  	Gscr: Gscr,
  	gscr: gscr,
  	gsim: gsim,
  	gsime: gsime,
  	gsiml: gsiml,
  	gtcc: gtcc,
  	gtcir: gtcir,
  	gt: gt,
  	GT: GT,
  	Gt: Gt,
  	gtdot: gtdot,
  	gtlPar: gtlPar,
  	gtquest: gtquest,
  	gtrapprox: gtrapprox,
  	gtrarr: gtrarr,
  	gtrdot: gtrdot,
  	gtreqless: gtreqless,
  	gtreqqless: gtreqqless,
  	gtrless: gtrless,
  	gtrsim: gtrsim,
  	gvertneqq: gvertneqq,
  	gvnE: gvnE,
  	Hacek: Hacek,
  	hairsp: hairsp,
  	half: half,
  	hamilt: hamilt,
  	HARDcy: HARDcy,
  	hardcy: hardcy,
  	harrcir: harrcir,
  	harr: harr,
  	hArr: hArr,
  	harrw: harrw,
  	Hat: Hat,
  	hbar: hbar,
  	Hcirc: Hcirc,
  	hcirc: hcirc,
  	hearts: hearts,
  	heartsuit: heartsuit,
  	hellip: hellip,
  	hercon: hercon,
  	hfr: hfr,
  	Hfr: Hfr,
  	HilbertSpace: HilbertSpace,
  	hksearow: hksearow,
  	hkswarow: hkswarow,
  	hoarr: hoarr,
  	homtht: homtht,
  	hookleftarrow: hookleftarrow,
  	hookrightarrow: hookrightarrow,
  	hopf: hopf,
  	Hopf: Hopf,
  	horbar: horbar,
  	HorizontalLine: HorizontalLine,
  	hscr: hscr,
  	Hscr: Hscr,
  	hslash: hslash,
  	Hstrok: Hstrok,
  	hstrok: hstrok,
  	HumpDownHump: HumpDownHump,
  	HumpEqual: HumpEqual,
  	hybull: hybull,
  	hyphen: hyphen,
  	Iacute: Iacute,
  	iacute: iacute,
  	ic: ic,
  	Icirc: Icirc,
  	icirc: icirc,
  	Icy: Icy,
  	icy: icy,
  	Idot: Idot,
  	IEcy: IEcy,
  	iecy: iecy,
  	iexcl: iexcl,
  	iff: iff,
  	ifr: ifr,
  	Ifr: Ifr,
  	Igrave: Igrave,
  	igrave: igrave,
  	ii: ii,
  	iiiint: iiiint,
  	iiint: iiint,
  	iinfin: iinfin,
  	iiota: iiota,
  	IJlig: IJlig,
  	ijlig: ijlig,
  	Imacr: Imacr,
  	imacr: imacr,
  	image: image,
  	ImaginaryI: ImaginaryI,
  	imagline: imagline,
  	imagpart: imagpart,
  	imath: imath,
  	Im: Im,
  	imof: imof,
  	imped: imped,
  	Implies: Implies,
  	incare: incare,
  	"in": "∈",
  	infin: infin,
  	infintie: infintie,
  	inodot: inodot,
  	intcal: intcal,
  	int: int,
  	Int: Int,
  	integers: integers,
  	Integral: Integral,
  	intercal: intercal,
  	Intersection: Intersection,
  	intlarhk: intlarhk,
  	intprod: intprod,
  	InvisibleComma: InvisibleComma,
  	InvisibleTimes: InvisibleTimes,
  	IOcy: IOcy,
  	iocy: iocy,
  	Iogon: Iogon,
  	iogon: iogon,
  	Iopf: Iopf,
  	iopf: iopf,
  	Iota: Iota,
  	iota: iota,
  	iprod: iprod,
  	iquest: iquest,
  	iscr: iscr,
  	Iscr: Iscr,
  	isin: isin,
  	isindot: isindot,
  	isinE: isinE,
  	isins: isins,
  	isinsv: isinsv,
  	isinv: isinv,
  	it: it,
  	Itilde: Itilde,
  	itilde: itilde,
  	Iukcy: Iukcy,
  	iukcy: iukcy,
  	Iuml: Iuml,
  	iuml: iuml,
  	Jcirc: Jcirc,
  	jcirc: jcirc,
  	Jcy: Jcy,
  	jcy: jcy,
  	Jfr: Jfr,
  	jfr: jfr,
  	jmath: jmath,
  	Jopf: Jopf,
  	jopf: jopf,
  	Jscr: Jscr,
  	jscr: jscr,
  	Jsercy: Jsercy,
  	jsercy: jsercy,
  	Jukcy: Jukcy,
  	jukcy: jukcy,
  	Kappa: Kappa,
  	kappa: kappa,
  	kappav: kappav,
  	Kcedil: Kcedil,
  	kcedil: kcedil,
  	Kcy: Kcy,
  	kcy: kcy,
  	Kfr: Kfr,
  	kfr: kfr,
  	kgreen: kgreen,
  	KHcy: KHcy,
  	khcy: khcy,
  	KJcy: KJcy,
  	kjcy: kjcy,
  	Kopf: Kopf,
  	kopf: kopf,
  	Kscr: Kscr,
  	kscr: kscr,
  	lAarr: lAarr,
  	Lacute: Lacute,
  	lacute: lacute,
  	laemptyv: laemptyv,
  	lagran: lagran,
  	Lambda: Lambda,
  	lambda: lambda,
  	lang: lang,
  	Lang: Lang,
  	langd: langd,
  	langle: langle,
  	lap: lap,
  	Laplacetrf: Laplacetrf,
  	laquo: laquo,
  	larrb: larrb,
  	larrbfs: larrbfs,
  	larr: larr,
  	Larr: Larr,
  	lArr: lArr,
  	larrfs: larrfs,
  	larrhk: larrhk,
  	larrlp: larrlp,
  	larrpl: larrpl,
  	larrsim: larrsim,
  	larrtl: larrtl,
  	latail: latail,
  	lAtail: lAtail,
  	lat: lat,
  	late: late,
  	lates: lates,
  	lbarr: lbarr,
  	lBarr: lBarr,
  	lbbrk: lbbrk,
  	lbrace: lbrace,
  	lbrack: lbrack,
  	lbrke: lbrke,
  	lbrksld: lbrksld,
  	lbrkslu: lbrkslu,
  	Lcaron: Lcaron,
  	lcaron: lcaron,
  	Lcedil: Lcedil,
  	lcedil: lcedil,
  	lceil: lceil,
  	lcub: lcub,
  	Lcy: Lcy,
  	lcy: lcy,
  	ldca: ldca,
  	ldquo: ldquo,
  	ldquor: ldquor,
  	ldrdhar: ldrdhar,
  	ldrushar: ldrushar,
  	ldsh: ldsh,
  	le: le,
  	lE: lE,
  	LeftAngleBracket: LeftAngleBracket,
  	LeftArrowBar: LeftArrowBar,
  	leftarrow: leftarrow,
  	LeftArrow: LeftArrow,
  	Leftarrow: Leftarrow,
  	LeftArrowRightArrow: LeftArrowRightArrow,
  	leftarrowtail: leftarrowtail,
  	LeftCeiling: LeftCeiling,
  	LeftDoubleBracket: LeftDoubleBracket,
  	LeftDownTeeVector: LeftDownTeeVector,
  	LeftDownVectorBar: LeftDownVectorBar,
  	LeftDownVector: LeftDownVector,
  	LeftFloor: LeftFloor,
  	leftharpoondown: leftharpoondown,
  	leftharpoonup: leftharpoonup,
  	leftleftarrows: leftleftarrows,
  	leftrightarrow: leftrightarrow,
  	LeftRightArrow: LeftRightArrow,
  	Leftrightarrow: Leftrightarrow,
  	leftrightarrows: leftrightarrows,
  	leftrightharpoons: leftrightharpoons,
  	leftrightsquigarrow: leftrightsquigarrow,
  	LeftRightVector: LeftRightVector,
  	LeftTeeArrow: LeftTeeArrow,
  	LeftTee: LeftTee,
  	LeftTeeVector: LeftTeeVector,
  	leftthreetimes: leftthreetimes,
  	LeftTriangleBar: LeftTriangleBar,
  	LeftTriangle: LeftTriangle,
  	LeftTriangleEqual: LeftTriangleEqual,
  	LeftUpDownVector: LeftUpDownVector,
  	LeftUpTeeVector: LeftUpTeeVector,
  	LeftUpVectorBar: LeftUpVectorBar,
  	LeftUpVector: LeftUpVector,
  	LeftVectorBar: LeftVectorBar,
  	LeftVector: LeftVector,
  	lEg: lEg,
  	leg: leg,
  	leq: leq,
  	leqq: leqq,
  	leqslant: leqslant,
  	lescc: lescc,
  	les: les,
  	lesdot: lesdot,
  	lesdoto: lesdoto,
  	lesdotor: lesdotor,
  	lesg: lesg,
  	lesges: lesges,
  	lessapprox: lessapprox,
  	lessdot: lessdot,
  	lesseqgtr: lesseqgtr,
  	lesseqqgtr: lesseqqgtr,
  	LessEqualGreater: LessEqualGreater,
  	LessFullEqual: LessFullEqual,
  	LessGreater: LessGreater,
  	lessgtr: lessgtr,
  	LessLess: LessLess,
  	lesssim: lesssim,
  	LessSlantEqual: LessSlantEqual,
  	LessTilde: LessTilde,
  	lfisht: lfisht,
  	lfloor: lfloor,
  	Lfr: Lfr,
  	lfr: lfr,
  	lg: lg,
  	lgE: lgE,
  	lHar: lHar,
  	lhard: lhard,
  	lharu: lharu,
  	lharul: lharul,
  	lhblk: lhblk,
  	LJcy: LJcy,
  	ljcy: ljcy,
  	llarr: llarr,
  	ll: ll,
  	Ll: Ll,
  	llcorner: llcorner,
  	Lleftarrow: Lleftarrow,
  	llhard: llhard,
  	lltri: lltri,
  	Lmidot: Lmidot,
  	lmidot: lmidot,
  	lmoustache: lmoustache,
  	lmoust: lmoust,
  	lnap: lnap,
  	lnapprox: lnapprox,
  	lne: lne,
  	lnE: lnE,
  	lneq: lneq,
  	lneqq: lneqq,
  	lnsim: lnsim,
  	loang: loang,
  	loarr: loarr,
  	lobrk: lobrk,
  	longleftarrow: longleftarrow,
  	LongLeftArrow: LongLeftArrow,
  	Longleftarrow: Longleftarrow,
  	longleftrightarrow: longleftrightarrow,
  	LongLeftRightArrow: LongLeftRightArrow,
  	Longleftrightarrow: Longleftrightarrow,
  	longmapsto: longmapsto,
  	longrightarrow: longrightarrow,
  	LongRightArrow: LongRightArrow,
  	Longrightarrow: Longrightarrow,
  	looparrowleft: looparrowleft,
  	looparrowright: looparrowright,
  	lopar: lopar,
  	Lopf: Lopf,
  	lopf: lopf,
  	loplus: loplus,
  	lotimes: lotimes,
  	lowast: lowast,
  	lowbar: lowbar,
  	LowerLeftArrow: LowerLeftArrow,
  	LowerRightArrow: LowerRightArrow,
  	loz: loz,
  	lozenge: lozenge,
  	lozf: lozf,
  	lpar: lpar,
  	lparlt: lparlt,
  	lrarr: lrarr,
  	lrcorner: lrcorner,
  	lrhar: lrhar,
  	lrhard: lrhard,
  	lrm: lrm,
  	lrtri: lrtri,
  	lsaquo: lsaquo,
  	lscr: lscr,
  	Lscr: Lscr,
  	lsh: lsh,
  	Lsh: Lsh,
  	lsim: lsim,
  	lsime: lsime,
  	lsimg: lsimg,
  	lsqb: lsqb,
  	lsquo: lsquo,
  	lsquor: lsquor,
  	Lstrok: Lstrok,
  	lstrok: lstrok,
  	ltcc: ltcc,
  	ltcir: ltcir,
  	lt: lt,
  	LT: LT,
  	Lt: Lt,
  	ltdot: ltdot,
  	lthree: lthree,
  	ltimes: ltimes,
  	ltlarr: ltlarr,
  	ltquest: ltquest,
  	ltri: ltri,
  	ltrie: ltrie,
  	ltrif: ltrif,
  	ltrPar: ltrPar,
  	lurdshar: lurdshar,
  	luruhar: luruhar,
  	lvertneqq: lvertneqq,
  	lvnE: lvnE,
  	macr: macr,
  	male: male,
  	malt: malt,
  	maltese: maltese,
  	"Map": "⤅",
  	map: map,
  	mapsto: mapsto,
  	mapstodown: mapstodown,
  	mapstoleft: mapstoleft,
  	mapstoup: mapstoup,
  	marker: marker,
  	mcomma: mcomma,
  	Mcy: Mcy,
  	mcy: mcy,
  	mdash: mdash,
  	mDDot: mDDot,
  	measuredangle: measuredangle,
  	MediumSpace: MediumSpace,
  	Mellintrf: Mellintrf,
  	Mfr: Mfr,
  	mfr: mfr,
  	mho: mho,
  	micro: micro,
  	midast: midast,
  	midcir: midcir,
  	mid: mid,
  	middot: middot,
  	minusb: minusb,
  	minus: minus,
  	minusd: minusd,
  	minusdu: minusdu,
  	MinusPlus: MinusPlus,
  	mlcp: mlcp,
  	mldr: mldr,
  	mnplus: mnplus,
  	models: models,
  	Mopf: Mopf,
  	mopf: mopf,
  	mp: mp,
  	mscr: mscr,
  	Mscr: Mscr,
  	mstpos: mstpos,
  	Mu: Mu,
  	mu: mu,
  	multimap: multimap,
  	mumap: mumap,
  	nabla: nabla,
  	Nacute: Nacute,
  	nacute: nacute,
  	nang: nang,
  	nap: nap,
  	napE: napE,
  	napid: napid,
  	napos: napos,
  	napprox: napprox,
  	natural: natural,
  	naturals: naturals,
  	natur: natur,
  	nbsp: nbsp,
  	nbump: nbump,
  	nbumpe: nbumpe,
  	ncap: ncap,
  	Ncaron: Ncaron,
  	ncaron: ncaron,
  	Ncedil: Ncedil,
  	ncedil: ncedil,
  	ncong: ncong,
  	ncongdot: ncongdot,
  	ncup: ncup,
  	Ncy: Ncy,
  	ncy: ncy,
  	ndash: ndash,
  	nearhk: nearhk,
  	nearr: nearr,
  	neArr: neArr,
  	nearrow: nearrow,
  	ne: ne,
  	nedot: nedot,
  	NegativeMediumSpace: NegativeMediumSpace,
  	NegativeThickSpace: NegativeThickSpace,
  	NegativeThinSpace: NegativeThinSpace,
  	NegativeVeryThinSpace: NegativeVeryThinSpace,
  	nequiv: nequiv,
  	nesear: nesear,
  	nesim: nesim,
  	NestedGreaterGreater: NestedGreaterGreater,
  	NestedLessLess: NestedLessLess,
  	NewLine: NewLine,
  	nexist: nexist,
  	nexists: nexists,
  	Nfr: Nfr,
  	nfr: nfr,
  	ngE: ngE,
  	nge: nge,
  	ngeq: ngeq,
  	ngeqq: ngeqq,
  	ngeqslant: ngeqslant,
  	nges: nges,
  	nGg: nGg,
  	ngsim: ngsim,
  	nGt: nGt,
  	ngt: ngt,
  	ngtr: ngtr,
  	nGtv: nGtv,
  	nharr: nharr,
  	nhArr: nhArr,
  	nhpar: nhpar,
  	ni: ni,
  	nis: nis,
  	nisd: nisd,
  	niv: niv,
  	NJcy: NJcy,
  	njcy: njcy,
  	nlarr: nlarr,
  	nlArr: nlArr,
  	nldr: nldr,
  	nlE: nlE,
  	nle: nle,
  	nleftarrow: nleftarrow,
  	nLeftarrow: nLeftarrow,
  	nleftrightarrow: nleftrightarrow,
  	nLeftrightarrow: nLeftrightarrow,
  	nleq: nleq,
  	nleqq: nleqq,
  	nleqslant: nleqslant,
  	nles: nles,
  	nless: nless,
  	nLl: nLl,
  	nlsim: nlsim,
  	nLt: nLt,
  	nlt: nlt,
  	nltri: nltri,
  	nltrie: nltrie,
  	nLtv: nLtv,
  	nmid: nmid,
  	NoBreak: NoBreak,
  	NonBreakingSpace: NonBreakingSpace,
  	nopf: nopf,
  	Nopf: Nopf,
  	Not: Not,
  	not: not,
  	NotCongruent: NotCongruent,
  	NotCupCap: NotCupCap,
  	NotDoubleVerticalBar: NotDoubleVerticalBar,
  	NotElement: NotElement,
  	NotEqual: NotEqual,
  	NotEqualTilde: NotEqualTilde,
  	NotExists: NotExists,
  	NotGreater: NotGreater,
  	NotGreaterEqual: NotGreaterEqual,
  	NotGreaterFullEqual: NotGreaterFullEqual,
  	NotGreaterGreater: NotGreaterGreater,
  	NotGreaterLess: NotGreaterLess,
  	NotGreaterSlantEqual: NotGreaterSlantEqual,
  	NotGreaterTilde: NotGreaterTilde,
  	NotHumpDownHump: NotHumpDownHump,
  	NotHumpEqual: NotHumpEqual,
  	notin: notin,
  	notindot: notindot,
  	notinE: notinE,
  	notinva: notinva,
  	notinvb: notinvb,
  	notinvc: notinvc,
  	NotLeftTriangleBar: NotLeftTriangleBar,
  	NotLeftTriangle: NotLeftTriangle,
  	NotLeftTriangleEqual: NotLeftTriangleEqual,
  	NotLess: NotLess,
  	NotLessEqual: NotLessEqual,
  	NotLessGreater: NotLessGreater,
  	NotLessLess: NotLessLess,
  	NotLessSlantEqual: NotLessSlantEqual,
  	NotLessTilde: NotLessTilde,
  	NotNestedGreaterGreater: NotNestedGreaterGreater,
  	NotNestedLessLess: NotNestedLessLess,
  	notni: notni,
  	notniva: notniva,
  	notnivb: notnivb,
  	notnivc: notnivc,
  	NotPrecedes: NotPrecedes,
  	NotPrecedesEqual: NotPrecedesEqual,
  	NotPrecedesSlantEqual: NotPrecedesSlantEqual,
  	NotReverseElement: NotReverseElement,
  	NotRightTriangleBar: NotRightTriangleBar,
  	NotRightTriangle: NotRightTriangle,
  	NotRightTriangleEqual: NotRightTriangleEqual,
  	NotSquareSubset: NotSquareSubset,
  	NotSquareSubsetEqual: NotSquareSubsetEqual,
  	NotSquareSuperset: NotSquareSuperset,
  	NotSquareSupersetEqual: NotSquareSupersetEqual,
  	NotSubset: NotSubset,
  	NotSubsetEqual: NotSubsetEqual,
  	NotSucceeds: NotSucceeds,
  	NotSucceedsEqual: NotSucceedsEqual,
  	NotSucceedsSlantEqual: NotSucceedsSlantEqual,
  	NotSucceedsTilde: NotSucceedsTilde,
  	NotSuperset: NotSuperset,
  	NotSupersetEqual: NotSupersetEqual,
  	NotTilde: NotTilde,
  	NotTildeEqual: NotTildeEqual,
  	NotTildeFullEqual: NotTildeFullEqual,
  	NotTildeTilde: NotTildeTilde,
  	NotVerticalBar: NotVerticalBar,
  	nparallel: nparallel,
  	npar: npar,
  	nparsl: nparsl,
  	npart: npart,
  	npolint: npolint,
  	npr: npr,
  	nprcue: nprcue,
  	nprec: nprec,
  	npreceq: npreceq,
  	npre: npre,
  	nrarrc: nrarrc,
  	nrarr: nrarr,
  	nrArr: nrArr,
  	nrarrw: nrarrw,
  	nrightarrow: nrightarrow,
  	nRightarrow: nRightarrow,
  	nrtri: nrtri,
  	nrtrie: nrtrie,
  	nsc: nsc,
  	nsccue: nsccue,
  	nsce: nsce,
  	Nscr: Nscr,
  	nscr: nscr,
  	nshortmid: nshortmid,
  	nshortparallel: nshortparallel,
  	nsim: nsim,
  	nsime: nsime,
  	nsimeq: nsimeq,
  	nsmid: nsmid,
  	nspar: nspar,
  	nsqsube: nsqsube,
  	nsqsupe: nsqsupe,
  	nsub: nsub,
  	nsubE: nsubE,
  	nsube: nsube,
  	nsubset: nsubset,
  	nsubseteq: nsubseteq,
  	nsubseteqq: nsubseteqq,
  	nsucc: nsucc,
  	nsucceq: nsucceq,
  	nsup: nsup,
  	nsupE: nsupE,
  	nsupe: nsupe,
  	nsupset: nsupset,
  	nsupseteq: nsupseteq,
  	nsupseteqq: nsupseteqq,
  	ntgl: ntgl,
  	Ntilde: Ntilde,
  	ntilde: ntilde,
  	ntlg: ntlg,
  	ntriangleleft: ntriangleleft,
  	ntrianglelefteq: ntrianglelefteq,
  	ntriangleright: ntriangleright,
  	ntrianglerighteq: ntrianglerighteq,
  	Nu: Nu,
  	nu: nu,
  	num: num,
  	numero: numero,
  	numsp: numsp,
  	nvap: nvap,
  	nvdash: nvdash,
  	nvDash: nvDash,
  	nVdash: nVdash,
  	nVDash: nVDash,
  	nvge: nvge,
  	nvgt: nvgt,
  	nvHarr: nvHarr,
  	nvinfin: nvinfin,
  	nvlArr: nvlArr,
  	nvle: nvle,
  	nvlt: nvlt,
  	nvltrie: nvltrie,
  	nvrArr: nvrArr,
  	nvrtrie: nvrtrie,
  	nvsim: nvsim,
  	nwarhk: nwarhk,
  	nwarr: nwarr,
  	nwArr: nwArr,
  	nwarrow: nwarrow,
  	nwnear: nwnear,
  	Oacute: Oacute,
  	oacute: oacute,
  	oast: oast,
  	Ocirc: Ocirc,
  	ocirc: ocirc,
  	ocir: ocir,
  	Ocy: Ocy,
  	ocy: ocy,
  	odash: odash,
  	Odblac: Odblac,
  	odblac: odblac,
  	odiv: odiv,
  	odot: odot,
  	odsold: odsold,
  	OElig: OElig,
  	oelig: oelig,
  	ofcir: ofcir,
  	Ofr: Ofr,
  	ofr: ofr,
  	ogon: ogon,
  	Ograve: Ograve,
  	ograve: ograve,
  	ogt: ogt,
  	ohbar: ohbar,
  	ohm: ohm,
  	oint: oint,
  	olarr: olarr,
  	olcir: olcir,
  	olcross: olcross,
  	oline: oline,
  	olt: olt,
  	Omacr: Omacr,
  	omacr: omacr,
  	Omega: Omega,
  	omega: omega,
  	Omicron: Omicron,
  	omicron: omicron,
  	omid: omid,
  	ominus: ominus,
  	Oopf: Oopf,
  	oopf: oopf,
  	opar: opar,
  	OpenCurlyDoubleQuote: OpenCurlyDoubleQuote,
  	OpenCurlyQuote: OpenCurlyQuote,
  	operp: operp,
  	oplus: oplus,
  	orarr: orarr,
  	Or: Or,
  	or: or,
  	ord: ord,
  	order: order,
  	orderof: orderof,
  	ordf: ordf,
  	ordm: ordm,
  	origof: origof,
  	oror: oror,
  	orslope: orslope,
  	orv: orv,
  	oS: oS,
  	Oscr: Oscr,
  	oscr: oscr,
  	Oslash: Oslash,
  	oslash: oslash,
  	osol: osol,
  	Otilde: Otilde,
  	otilde: otilde,
  	otimesas: otimesas,
  	Otimes: Otimes,
  	otimes: otimes,
  	Ouml: Ouml,
  	ouml: ouml,
  	ovbar: ovbar,
  	OverBar: OverBar,
  	OverBrace: OverBrace,
  	OverBracket: OverBracket,
  	OverParenthesis: OverParenthesis,
  	para: para,
  	parallel: parallel,
  	par: par,
  	parsim: parsim,
  	parsl: parsl,
  	part: part,
  	PartialD: PartialD,
  	Pcy: Pcy,
  	pcy: pcy,
  	percnt: percnt,
  	period: period,
  	permil: permil,
  	perp: perp,
  	pertenk: pertenk,
  	Pfr: Pfr,
  	pfr: pfr,
  	Phi: Phi,
  	phi: phi,
  	phiv: phiv,
  	phmmat: phmmat,
  	phone: phone,
  	Pi: Pi,
  	pi: pi,
  	pitchfork: pitchfork,
  	piv: piv,
  	planck: planck,
  	planckh: planckh,
  	plankv: plankv,
  	plusacir: plusacir,
  	plusb: plusb,
  	pluscir: pluscir,
  	plus: plus,
  	plusdo: plusdo,
  	plusdu: plusdu,
  	pluse: pluse,
  	PlusMinus: PlusMinus,
  	plusmn: plusmn,
  	plussim: plussim,
  	plustwo: plustwo,
  	pm: pm,
  	Poincareplane: Poincareplane,
  	pointint: pointint,
  	popf: popf,
  	Popf: Popf,
  	pound: pound,
  	prap: prap,
  	Pr: Pr,
  	pr: pr,
  	prcue: prcue,
  	precapprox: precapprox,
  	prec: prec,
  	preccurlyeq: preccurlyeq,
  	Precedes: Precedes,
  	PrecedesEqual: PrecedesEqual,
  	PrecedesSlantEqual: PrecedesSlantEqual,
  	PrecedesTilde: PrecedesTilde,
  	preceq: preceq,
  	precnapprox: precnapprox,
  	precneqq: precneqq,
  	precnsim: precnsim,
  	pre: pre,
  	prE: prE,
  	precsim: precsim,
  	prime: prime,
  	Prime: Prime,
  	primes: primes,
  	prnap: prnap,
  	prnE: prnE,
  	prnsim: prnsim,
  	prod: prod,
  	Product: Product,
  	profalar: profalar,
  	profline: profline,
  	profsurf: profsurf,
  	prop: prop,
  	Proportional: Proportional,
  	Proportion: Proportion,
  	propto: propto,
  	prsim: prsim,
  	prurel: prurel,
  	Pscr: Pscr,
  	pscr: pscr,
  	Psi: Psi,
  	psi: psi,
  	puncsp: puncsp,
  	Qfr: Qfr,
  	qfr: qfr,
  	qint: qint,
  	qopf: qopf,
  	Qopf: Qopf,
  	qprime: qprime,
  	Qscr: Qscr,
  	qscr: qscr,
  	quaternions: quaternions,
  	quatint: quatint,
  	quest: quest,
  	questeq: questeq,
  	quot: quot,
  	QUOT: QUOT,
  	rAarr: rAarr,
  	race: race,
  	Racute: Racute,
  	racute: racute,
  	radic: radic,
  	raemptyv: raemptyv,
  	rang: rang,
  	Rang: Rang,
  	rangd: rangd,
  	range: range,
  	rangle: rangle,
  	raquo: raquo,
  	rarrap: rarrap,
  	rarrb: rarrb,
  	rarrbfs: rarrbfs,
  	rarrc: rarrc,
  	rarr: rarr,
  	Rarr: Rarr,
  	rArr: rArr,
  	rarrfs: rarrfs,
  	rarrhk: rarrhk,
  	rarrlp: rarrlp,
  	rarrpl: rarrpl,
  	rarrsim: rarrsim,
  	Rarrtl: Rarrtl,
  	rarrtl: rarrtl,
  	rarrw: rarrw,
  	ratail: ratail,
  	rAtail: rAtail,
  	ratio: ratio,
  	rationals: rationals,
  	rbarr: rbarr,
  	rBarr: rBarr,
  	RBarr: RBarr,
  	rbbrk: rbbrk,
  	rbrace: rbrace,
  	rbrack: rbrack,
  	rbrke: rbrke,
  	rbrksld: rbrksld,
  	rbrkslu: rbrkslu,
  	Rcaron: Rcaron,
  	rcaron: rcaron,
  	Rcedil: Rcedil,
  	rcedil: rcedil,
  	rceil: rceil,
  	rcub: rcub,
  	Rcy: Rcy,
  	rcy: rcy,
  	rdca: rdca,
  	rdldhar: rdldhar,
  	rdquo: rdquo,
  	rdquor: rdquor,
  	rdsh: rdsh,
  	real: real,
  	realine: realine,
  	realpart: realpart,
  	reals: reals,
  	Re: Re,
  	rect: rect,
  	reg: reg,
  	REG: REG,
  	ReverseElement: ReverseElement,
  	ReverseEquilibrium: ReverseEquilibrium,
  	ReverseUpEquilibrium: ReverseUpEquilibrium,
  	rfisht: rfisht,
  	rfloor: rfloor,
  	rfr: rfr,
  	Rfr: Rfr,
  	rHar: rHar,
  	rhard: rhard,
  	rharu: rharu,
  	rharul: rharul,
  	Rho: Rho,
  	rho: rho,
  	rhov: rhov,
  	RightAngleBracket: RightAngleBracket,
  	RightArrowBar: RightArrowBar,
  	rightarrow: rightarrow,
  	RightArrow: RightArrow,
  	Rightarrow: Rightarrow,
  	RightArrowLeftArrow: RightArrowLeftArrow,
  	rightarrowtail: rightarrowtail,
  	RightCeiling: RightCeiling,
  	RightDoubleBracket: RightDoubleBracket,
  	RightDownTeeVector: RightDownTeeVector,
  	RightDownVectorBar: RightDownVectorBar,
  	RightDownVector: RightDownVector,
  	RightFloor: RightFloor,
  	rightharpoondown: rightharpoondown,
  	rightharpoonup: rightharpoonup,
  	rightleftarrows: rightleftarrows,
  	rightleftharpoons: rightleftharpoons,
  	rightrightarrows: rightrightarrows,
  	rightsquigarrow: rightsquigarrow,
  	RightTeeArrow: RightTeeArrow,
  	RightTee: RightTee,
  	RightTeeVector: RightTeeVector,
  	rightthreetimes: rightthreetimes,
  	RightTriangleBar: RightTriangleBar,
  	RightTriangle: RightTriangle,
  	RightTriangleEqual: RightTriangleEqual,
  	RightUpDownVector: RightUpDownVector,
  	RightUpTeeVector: RightUpTeeVector,
  	RightUpVectorBar: RightUpVectorBar,
  	RightUpVector: RightUpVector,
  	RightVectorBar: RightVectorBar,
  	RightVector: RightVector,
  	ring: ring,
  	risingdotseq: risingdotseq,
  	rlarr: rlarr,
  	rlhar: rlhar,
  	rlm: rlm,
  	rmoustache: rmoustache,
  	rmoust: rmoust,
  	rnmid: rnmid,
  	roang: roang,
  	roarr: roarr,
  	robrk: robrk,
  	ropar: ropar,
  	ropf: ropf,
  	Ropf: Ropf,
  	roplus: roplus,
  	rotimes: rotimes,
  	RoundImplies: RoundImplies,
  	rpar: rpar,
  	rpargt: rpargt,
  	rppolint: rppolint,
  	rrarr: rrarr,
  	Rrightarrow: Rrightarrow,
  	rsaquo: rsaquo,
  	rscr: rscr,
  	Rscr: Rscr,
  	rsh: rsh,
  	Rsh: Rsh,
  	rsqb: rsqb,
  	rsquo: rsquo,
  	rsquor: rsquor,
  	rthree: rthree,
  	rtimes: rtimes,
  	rtri: rtri,
  	rtrie: rtrie,
  	rtrif: rtrif,
  	rtriltri: rtriltri,
  	RuleDelayed: RuleDelayed,
  	ruluhar: ruluhar,
  	rx: rx,
  	Sacute: Sacute,
  	sacute: sacute,
  	sbquo: sbquo,
  	scap: scap,
  	Scaron: Scaron,
  	scaron: scaron,
  	Sc: Sc,
  	sc: sc,
  	sccue: sccue,
  	sce: sce,
  	scE: scE,
  	Scedil: Scedil,
  	scedil: scedil,
  	Scirc: Scirc,
  	scirc: scirc,
  	scnap: scnap,
  	scnE: scnE,
  	scnsim: scnsim,
  	scpolint: scpolint,
  	scsim: scsim,
  	Scy: Scy,
  	scy: scy,
  	sdotb: sdotb,
  	sdot: sdot,
  	sdote: sdote,
  	searhk: searhk,
  	searr: searr,
  	seArr: seArr,
  	searrow: searrow,
  	sect: sect,
  	semi: semi,
  	seswar: seswar,
  	setminus: setminus,
  	setmn: setmn,
  	sext: sext,
  	Sfr: Sfr,
  	sfr: sfr,
  	sfrown: sfrown,
  	sharp: sharp,
  	SHCHcy: SHCHcy,
  	shchcy: shchcy,
  	SHcy: SHcy,
  	shcy: shcy,
  	ShortDownArrow: ShortDownArrow,
  	ShortLeftArrow: ShortLeftArrow,
  	shortmid: shortmid,
  	shortparallel: shortparallel,
  	ShortRightArrow: ShortRightArrow,
  	ShortUpArrow: ShortUpArrow,
  	shy: shy,
  	Sigma: Sigma,
  	sigma: sigma,
  	sigmaf: sigmaf,
  	sigmav: sigmav,
  	sim: sim,
  	simdot: simdot,
  	sime: sime,
  	simeq: simeq,
  	simg: simg,
  	simgE: simgE,
  	siml: siml,
  	simlE: simlE,
  	simne: simne,
  	simplus: simplus,
  	simrarr: simrarr,
  	slarr: slarr,
  	SmallCircle: SmallCircle,
  	smallsetminus: smallsetminus,
  	smashp: smashp,
  	smeparsl: smeparsl,
  	smid: smid,
  	smile: smile,
  	smt: smt,
  	smte: smte,
  	smtes: smtes,
  	SOFTcy: SOFTcy,
  	softcy: softcy,
  	solbar: solbar,
  	solb: solb,
  	sol: sol,
  	Sopf: Sopf,
  	sopf: sopf,
  	spades: spades,
  	spadesuit: spadesuit,
  	spar: spar,
  	sqcap: sqcap,
  	sqcaps: sqcaps,
  	sqcup: sqcup,
  	sqcups: sqcups,
  	Sqrt: Sqrt,
  	sqsub: sqsub,
  	sqsube: sqsube,
  	sqsubset: sqsubset,
  	sqsubseteq: sqsubseteq,
  	sqsup: sqsup,
  	sqsupe: sqsupe,
  	sqsupset: sqsupset,
  	sqsupseteq: sqsupseteq,
  	square: square,
  	Square: Square,
  	SquareIntersection: SquareIntersection,
  	SquareSubset: SquareSubset,
  	SquareSubsetEqual: SquareSubsetEqual,
  	SquareSuperset: SquareSuperset,
  	SquareSupersetEqual: SquareSupersetEqual,
  	SquareUnion: SquareUnion,
  	squarf: squarf,
  	squ: squ,
  	squf: squf,
  	srarr: srarr,
  	Sscr: Sscr,
  	sscr: sscr,
  	ssetmn: ssetmn,
  	ssmile: ssmile,
  	sstarf: sstarf,
  	Star: Star,
  	star: star,
  	starf: starf,
  	straightepsilon: straightepsilon,
  	straightphi: straightphi,
  	strns: strns,
  	sub: sub,
  	Sub: Sub,
  	subdot: subdot,
  	subE: subE,
  	sube: sube,
  	subedot: subedot,
  	submult: submult,
  	subnE: subnE,
  	subne: subne,
  	subplus: subplus,
  	subrarr: subrarr,
  	subset: subset,
  	Subset: Subset,
  	subseteq: subseteq,
  	subseteqq: subseteqq,
  	SubsetEqual: SubsetEqual,
  	subsetneq: subsetneq,
  	subsetneqq: subsetneqq,
  	subsim: subsim,
  	subsub: subsub,
  	subsup: subsup,
  	succapprox: succapprox,
  	succ: succ,
  	succcurlyeq: succcurlyeq,
  	Succeeds: Succeeds,
  	SucceedsEqual: SucceedsEqual,
  	SucceedsSlantEqual: SucceedsSlantEqual,
  	SucceedsTilde: SucceedsTilde,
  	succeq: succeq,
  	succnapprox: succnapprox,
  	succneqq: succneqq,
  	succnsim: succnsim,
  	succsim: succsim,
  	SuchThat: SuchThat,
  	sum: sum,
  	Sum: Sum,
  	sung: sung,
  	sup1: sup1,
  	sup2: sup2,
  	sup3: sup3,
  	sup: sup,
  	Sup: Sup,
  	supdot: supdot,
  	supdsub: supdsub,
  	supE: supE,
  	supe: supe,
  	supedot: supedot,
  	Superset: Superset,
  	SupersetEqual: SupersetEqual,
  	suphsol: suphsol,
  	suphsub: suphsub,
  	suplarr: suplarr,
  	supmult: supmult,
  	supnE: supnE,
  	supne: supne,
  	supplus: supplus,
  	supset: supset,
  	Supset: Supset,
  	supseteq: supseteq,
  	supseteqq: supseteqq,
  	supsetneq: supsetneq,
  	supsetneqq: supsetneqq,
  	supsim: supsim,
  	supsub: supsub,
  	supsup: supsup,
  	swarhk: swarhk,
  	swarr: swarr,
  	swArr: swArr,
  	swarrow: swarrow,
  	swnwar: swnwar,
  	szlig: szlig,
  	Tab: Tab,
  	target: target,
  	Tau: Tau,
  	tau: tau,
  	tbrk: tbrk,
  	Tcaron: Tcaron,
  	tcaron: tcaron,
  	Tcedil: Tcedil,
  	tcedil: tcedil,
  	Tcy: Tcy,
  	tcy: tcy,
  	tdot: tdot,
  	telrec: telrec,
  	Tfr: Tfr,
  	tfr: tfr,
  	there4: there4,
  	therefore: therefore,
  	Therefore: Therefore,
  	Theta: Theta,
  	theta: theta,
  	thetasym: thetasym,
  	thetav: thetav,
  	thickapprox: thickapprox,
  	thicksim: thicksim,
  	ThickSpace: ThickSpace,
  	ThinSpace: ThinSpace,
  	thinsp: thinsp,
  	thkap: thkap,
  	thksim: thksim,
  	THORN: THORN,
  	thorn: thorn,
  	tilde: tilde,
  	Tilde: Tilde,
  	TildeEqual: TildeEqual,
  	TildeFullEqual: TildeFullEqual,
  	TildeTilde: TildeTilde,
  	timesbar: timesbar,
  	timesb: timesb,
  	times: times,
  	timesd: timesd,
  	tint: tint,
  	toea: toea,
  	topbot: topbot,
  	topcir: topcir,
  	top: top,
  	Topf: Topf,
  	topf: topf,
  	topfork: topfork,
  	tosa: tosa,
  	tprime: tprime,
  	trade: trade,
  	TRADE: TRADE,
  	triangle: triangle,
  	triangledown: triangledown,
  	triangleleft: triangleleft,
  	trianglelefteq: trianglelefteq,
  	triangleq: triangleq,
  	triangleright: triangleright,
  	trianglerighteq: trianglerighteq,
  	tridot: tridot,
  	trie: trie,
  	triminus: triminus,
  	TripleDot: TripleDot,
  	triplus: triplus,
  	trisb: trisb,
  	tritime: tritime,
  	trpezium: trpezium,
  	Tscr: Tscr,
  	tscr: tscr,
  	TScy: TScy,
  	tscy: tscy,
  	TSHcy: TSHcy,
  	tshcy: tshcy,
  	Tstrok: Tstrok,
  	tstrok: tstrok,
  	twixt: twixt,
  	twoheadleftarrow: twoheadleftarrow,
  	twoheadrightarrow: twoheadrightarrow,
  	Uacute: Uacute,
  	uacute: uacute,
  	uarr: uarr,
  	Uarr: Uarr,
  	uArr: uArr,
  	Uarrocir: Uarrocir,
  	Ubrcy: Ubrcy,
  	ubrcy: ubrcy,
  	Ubreve: Ubreve,
  	ubreve: ubreve,
  	Ucirc: Ucirc,
  	ucirc: ucirc,
  	Ucy: Ucy,
  	ucy: ucy,
  	udarr: udarr,
  	Udblac: Udblac,
  	udblac: udblac,
  	udhar: udhar,
  	ufisht: ufisht,
  	Ufr: Ufr,
  	ufr: ufr,
  	Ugrave: Ugrave,
  	ugrave: ugrave,
  	uHar: uHar,
  	uharl: uharl,
  	uharr: uharr,
  	uhblk: uhblk,
  	ulcorn: ulcorn,
  	ulcorner: ulcorner,
  	ulcrop: ulcrop,
  	ultri: ultri,
  	Umacr: Umacr,
  	umacr: umacr,
  	uml: uml,
  	UnderBar: UnderBar,
  	UnderBrace: UnderBrace,
  	UnderBracket: UnderBracket,
  	UnderParenthesis: UnderParenthesis,
  	Union: Union,
  	UnionPlus: UnionPlus,
  	Uogon: Uogon,
  	uogon: uogon,
  	Uopf: Uopf,
  	uopf: uopf,
  	UpArrowBar: UpArrowBar,
  	uparrow: uparrow,
  	UpArrow: UpArrow,
  	Uparrow: Uparrow,
  	UpArrowDownArrow: UpArrowDownArrow,
  	updownarrow: updownarrow,
  	UpDownArrow: UpDownArrow,
  	Updownarrow: Updownarrow,
  	UpEquilibrium: UpEquilibrium,
  	upharpoonleft: upharpoonleft,
  	upharpoonright: upharpoonright,
  	uplus: uplus,
  	UpperLeftArrow: UpperLeftArrow,
  	UpperRightArrow: UpperRightArrow,
  	upsi: upsi,
  	Upsi: Upsi,
  	upsih: upsih,
  	Upsilon: Upsilon,
  	upsilon: upsilon,
  	UpTeeArrow: UpTeeArrow,
  	UpTee: UpTee,
  	upuparrows: upuparrows,
  	urcorn: urcorn,
  	urcorner: urcorner,
  	urcrop: urcrop,
  	Uring: Uring,
  	uring: uring,
  	urtri: urtri,
  	Uscr: Uscr,
  	uscr: uscr,
  	utdot: utdot,
  	Utilde: Utilde,
  	utilde: utilde,
  	utri: utri,
  	utrif: utrif,
  	uuarr: uuarr,
  	Uuml: Uuml,
  	uuml: uuml,
  	uwangle: uwangle,
  	vangrt: vangrt,
  	varepsilon: varepsilon,
  	varkappa: varkappa,
  	varnothing: varnothing,
  	varphi: varphi,
  	varpi: varpi,
  	varpropto: varpropto,
  	varr: varr,
  	vArr: vArr,
  	varrho: varrho,
  	varsigma: varsigma,
  	varsubsetneq: varsubsetneq,
  	varsubsetneqq: varsubsetneqq,
  	varsupsetneq: varsupsetneq,
  	varsupsetneqq: varsupsetneqq,
  	vartheta: vartheta,
  	vartriangleleft: vartriangleleft,
  	vartriangleright: vartriangleright,
  	vBar: vBar,
  	Vbar: Vbar,
  	vBarv: vBarv,
  	Vcy: Vcy,
  	vcy: vcy,
  	vdash: vdash,
  	vDash: vDash,
  	Vdash: Vdash,
  	VDash: VDash,
  	Vdashl: Vdashl,
  	veebar: veebar,
  	vee: vee,
  	Vee: Vee,
  	veeeq: veeeq,
  	vellip: vellip,
  	verbar: verbar,
  	Verbar: Verbar,
  	vert: vert,
  	Vert: Vert,
  	VerticalBar: VerticalBar,
  	VerticalLine: VerticalLine,
  	VerticalSeparator: VerticalSeparator,
  	VerticalTilde: VerticalTilde,
  	VeryThinSpace: VeryThinSpace,
  	Vfr: Vfr,
  	vfr: vfr,
  	vltri: vltri,
  	vnsub: vnsub,
  	vnsup: vnsup,
  	Vopf: Vopf,
  	vopf: vopf,
  	vprop: vprop,
  	vrtri: vrtri,
  	Vscr: Vscr,
  	vscr: vscr,
  	vsubnE: vsubnE,
  	vsubne: vsubne,
  	vsupnE: vsupnE,
  	vsupne: vsupne,
  	Vvdash: Vvdash,
  	vzigzag: vzigzag,
  	Wcirc: Wcirc,
  	wcirc: wcirc,
  	wedbar: wedbar,
  	wedge: wedge,
  	Wedge: Wedge,
  	wedgeq: wedgeq,
  	weierp: weierp,
  	Wfr: Wfr,
  	wfr: wfr,
  	Wopf: Wopf,
  	wopf: wopf,
  	wp: wp,
  	wr: wr,
  	wreath: wreath,
  	Wscr: Wscr,
  	wscr: wscr,
  	xcap: xcap,
  	xcirc: xcirc,
  	xcup: xcup,
  	xdtri: xdtri,
  	Xfr: Xfr,
  	xfr: xfr,
  	xharr: xharr,
  	xhArr: xhArr,
  	Xi: Xi,
  	xi: xi,
  	xlarr: xlarr,
  	xlArr: xlArr,
  	xmap: xmap,
  	xnis: xnis,
  	xodot: xodot,
  	Xopf: Xopf,
  	xopf: xopf,
  	xoplus: xoplus,
  	xotime: xotime,
  	xrarr: xrarr,
  	xrArr: xrArr,
  	Xscr: Xscr,
  	xscr: xscr,
  	xsqcup: xsqcup,
  	xuplus: xuplus,
  	xutri: xutri,
  	xvee: xvee,
  	xwedge: xwedge,
  	Yacute: Yacute,
  	yacute: yacute,
  	YAcy: YAcy,
  	yacy: yacy,
  	Ycirc: Ycirc,
  	ycirc: ycirc,
  	Ycy: Ycy,
  	ycy: ycy,
  	yen: yen,
  	Yfr: Yfr,
  	yfr: yfr,
  	YIcy: YIcy,
  	yicy: yicy,
  	Yopf: Yopf,
  	yopf: yopf,
  	Yscr: Yscr,
  	yscr: yscr,
  	YUcy: YUcy,
  	yucy: yucy,
  	yuml: yuml,
  	Yuml: Yuml,
  	Zacute: Zacute,
  	zacute: zacute,
  	Zcaron: Zcaron,
  	zcaron: zcaron,
  	Zcy: Zcy,
  	zcy: zcy,
  	Zdot: Zdot,
  	zdot: zdot,
  	zeetrf: zeetrf,
  	ZeroWidthSpace: ZeroWidthSpace,
  	Zeta: Zeta,
  	zeta: zeta,
  	zfr: zfr,
  	Zfr: Zfr,
  	ZHcy: ZHcy,
  	zhcy: zhcy,
  	zigrarr: zigrarr,
  	zopf: zopf,
  	Zopf: Zopf,
  	Zscr: Zscr,
  	zscr: zscr,
  	zwj: zwj,
  	zwnj: zwnj
  };

  var entities$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    Aacute: Aacute,
    aacute: aacute,
    Abreve: Abreve,
    abreve: abreve,
    ac: ac,
    acd: acd,
    acE: acE,
    Acirc: Acirc,
    acirc: acirc,
    acute: acute,
    Acy: Acy,
    acy: acy,
    AElig: AElig,
    aelig: aelig,
    af: af,
    Afr: Afr,
    afr: afr,
    Agrave: Agrave,
    agrave: agrave,
    alefsym: alefsym,
    aleph: aleph,
    Alpha: Alpha,
    alpha: alpha,
    Amacr: Amacr,
    amacr: amacr,
    amalg: amalg,
    amp: amp,
    AMP: AMP,
    andand: andand,
    And: And,
    and: and,
    andd: andd,
    andslope: andslope,
    andv: andv,
    ang: ang,
    ange: ange,
    angle: angle,
    angmsdaa: angmsdaa,
    angmsdab: angmsdab,
    angmsdac: angmsdac,
    angmsdad: angmsdad,
    angmsdae: angmsdae,
    angmsdaf: angmsdaf,
    angmsdag: angmsdag,
    angmsdah: angmsdah,
    angmsd: angmsd,
    angrt: angrt,
    angrtvb: angrtvb,
    angrtvbd: angrtvbd,
    angsph: angsph,
    angst: angst,
    angzarr: angzarr,
    Aogon: Aogon,
    aogon: aogon,
    Aopf: Aopf,
    aopf: aopf,
    apacir: apacir,
    ap: ap,
    apE: apE,
    ape: ape,
    apid: apid,
    apos: apos,
    ApplyFunction: ApplyFunction,
    approx: approx,
    approxeq: approxeq,
    Aring: Aring,
    aring: aring,
    Ascr: Ascr,
    ascr: ascr,
    Assign: Assign,
    ast: ast,
    asymp: asymp,
    asympeq: asympeq,
    Atilde: Atilde,
    atilde: atilde,
    Auml: Auml,
    auml: auml,
    awconint: awconint,
    awint: awint,
    backcong: backcong,
    backepsilon: backepsilon,
    backprime: backprime,
    backsim: backsim,
    backsimeq: backsimeq,
    Backslash: Backslash,
    Barv: Barv,
    barvee: barvee,
    barwed: barwed,
    Barwed: Barwed,
    barwedge: barwedge,
    bbrk: bbrk,
    bbrktbrk: bbrktbrk,
    bcong: bcong,
    Bcy: Bcy,
    bcy: bcy,
    bdquo: bdquo,
    becaus: becaus,
    because: because,
    Because: Because,
    bemptyv: bemptyv,
    bepsi: bepsi,
    bernou: bernou,
    Bernoullis: Bernoullis,
    Beta: Beta,
    beta: beta,
    beth: beth,
    between: between,
    Bfr: Bfr,
    bfr: bfr,
    bigcap: bigcap,
    bigcirc: bigcirc,
    bigcup: bigcup,
    bigodot: bigodot,
    bigoplus: bigoplus,
    bigotimes: bigotimes,
    bigsqcup: bigsqcup,
    bigstar: bigstar,
    bigtriangledown: bigtriangledown,
    bigtriangleup: bigtriangleup,
    biguplus: biguplus,
    bigvee: bigvee,
    bigwedge: bigwedge,
    bkarow: bkarow,
    blacklozenge: blacklozenge,
    blacksquare: blacksquare,
    blacktriangle: blacktriangle,
    blacktriangledown: blacktriangledown,
    blacktriangleleft: blacktriangleleft,
    blacktriangleright: blacktriangleright,
    blank: blank,
    blk12: blk12,
    blk14: blk14,
    blk34: blk34,
    block: block,
    bne: bne,
    bnequiv: bnequiv,
    bNot: bNot,
    bnot: bnot,
    Bopf: Bopf,
    bopf: bopf,
    bot: bot,
    bottom: bottom,
    bowtie: bowtie,
    boxbox: boxbox,
    boxdl: boxdl,
    boxdL: boxdL,
    boxDl: boxDl,
    boxDL: boxDL,
    boxdr: boxdr,
    boxdR: boxdR,
    boxDr: boxDr,
    boxDR: boxDR,
    boxh: boxh,
    boxH: boxH,
    boxhd: boxhd,
    boxHd: boxHd,
    boxhD: boxhD,
    boxHD: boxHD,
    boxhu: boxhu,
    boxHu: boxHu,
    boxhU: boxhU,
    boxHU: boxHU,
    boxminus: boxminus,
    boxplus: boxplus,
    boxtimes: boxtimes,
    boxul: boxul,
    boxuL: boxuL,
    boxUl: boxUl,
    boxUL: boxUL,
    boxur: boxur,
    boxuR: boxuR,
    boxUr: boxUr,
    boxUR: boxUR,
    boxv: boxv,
    boxV: boxV,
    boxvh: boxvh,
    boxvH: boxvH,
    boxVh: boxVh,
    boxVH: boxVH,
    boxvl: boxvl,
    boxvL: boxvL,
    boxVl: boxVl,
    boxVL: boxVL,
    boxvr: boxvr,
    boxvR: boxvR,
    boxVr: boxVr,
    boxVR: boxVR,
    bprime: bprime,
    breve: breve,
    Breve: Breve,
    brvbar: brvbar,
    bscr: bscr,
    Bscr: Bscr,
    bsemi: bsemi,
    bsim: bsim,
    bsime: bsime,
    bsolb: bsolb,
    bsol: bsol,
    bsolhsub: bsolhsub,
    bull: bull,
    bullet: bullet,
    bump: bump,
    bumpE: bumpE,
    bumpe: bumpe,
    Bumpeq: Bumpeq,
    bumpeq: bumpeq,
    Cacute: Cacute,
    cacute: cacute,
    capand: capand,
    capbrcup: capbrcup,
    capcap: capcap,
    cap: cap,
    Cap: Cap,
    capcup: capcup,
    capdot: capdot,
    CapitalDifferentialD: CapitalDifferentialD,
    caps: caps,
    caret: caret,
    caron: caron,
    Cayleys: Cayleys,
    ccaps: ccaps,
    Ccaron: Ccaron,
    ccaron: ccaron,
    Ccedil: Ccedil,
    ccedil: ccedil,
    Ccirc: Ccirc,
    ccirc: ccirc,
    Cconint: Cconint,
    ccups: ccups,
    ccupssm: ccupssm,
    Cdot: Cdot,
    cdot: cdot,
    cedil: cedil,
    Cedilla: Cedilla,
    cemptyv: cemptyv,
    cent: cent,
    centerdot: centerdot,
    CenterDot: CenterDot,
    cfr: cfr,
    Cfr: Cfr,
    CHcy: CHcy,
    chcy: chcy,
    check: check,
    checkmark: checkmark,
    Chi: Chi,
    chi: chi,
    circ: circ,
    circeq: circeq,
    circlearrowleft: circlearrowleft,
    circlearrowright: circlearrowright,
    circledast: circledast,
    circledcirc: circledcirc,
    circleddash: circleddash,
    CircleDot: CircleDot,
    circledR: circledR,
    circledS: circledS,
    CircleMinus: CircleMinus,
    CirclePlus: CirclePlus,
    CircleTimes: CircleTimes,
    cir: cir,
    cirE: cirE,
    cire: cire,
    cirfnint: cirfnint,
    cirmid: cirmid,
    cirscir: cirscir,
    ClockwiseContourIntegral: ClockwiseContourIntegral,
    CloseCurlyDoubleQuote: CloseCurlyDoubleQuote,
    CloseCurlyQuote: CloseCurlyQuote,
    clubs: clubs,
    clubsuit: clubsuit,
    colon: colon,
    Colon: Colon,
    Colone: Colone,
    colone: colone,
    coloneq: coloneq,
    comma: comma,
    commat: commat,
    comp: comp,
    compfn: compfn,
    complement: complement,
    complexes: complexes,
    cong: cong,
    congdot: congdot,
    Congruent: Congruent,
    conint: conint,
    Conint: Conint,
    ContourIntegral: ContourIntegral,
    copf: copf,
    Copf: Copf,
    coprod: coprod,
    Coproduct: Coproduct,
    copy: copy,
    COPY: COPY,
    copysr: copysr,
    CounterClockwiseContourIntegral: CounterClockwiseContourIntegral,
    crarr: crarr,
    cross: cross,
    Cross: Cross,
    Cscr: Cscr,
    cscr: cscr,
    csub: csub,
    csube: csube,
    csup: csup,
    csupe: csupe,
    ctdot: ctdot,
    cudarrl: cudarrl,
    cudarrr: cudarrr,
    cuepr: cuepr,
    cuesc: cuesc,
    cularr: cularr,
    cularrp: cularrp,
    cupbrcap: cupbrcap,
    cupcap: cupcap,
    CupCap: CupCap,
    cup: cup,
    Cup: Cup,
    cupcup: cupcup,
    cupdot: cupdot,
    cupor: cupor,
    cups: cups,
    curarr: curarr,
    curarrm: curarrm,
    curlyeqprec: curlyeqprec,
    curlyeqsucc: curlyeqsucc,
    curlyvee: curlyvee,
    curlywedge: curlywedge,
    curren: curren,
    curvearrowleft: curvearrowleft,
    curvearrowright: curvearrowright,
    cuvee: cuvee,
    cuwed: cuwed,
    cwconint: cwconint,
    cwint: cwint,
    cylcty: cylcty,
    dagger: dagger,
    Dagger: Dagger,
    daleth: daleth,
    darr: darr,
    Darr: Darr,
    dArr: dArr,
    dash: dash,
    Dashv: Dashv,
    dashv: dashv,
    dbkarow: dbkarow,
    dblac: dblac,
    Dcaron: Dcaron,
    dcaron: dcaron,
    Dcy: Dcy,
    dcy: dcy,
    ddagger: ddagger,
    ddarr: ddarr,
    DD: DD,
    dd: dd,
    DDotrahd: DDotrahd,
    ddotseq: ddotseq,
    deg: deg,
    Del: Del,
    Delta: Delta,
    delta: delta,
    demptyv: demptyv,
    dfisht: dfisht,
    Dfr: Dfr,
    dfr: dfr,
    dHar: dHar,
    dharl: dharl,
    dharr: dharr,
    DiacriticalAcute: DiacriticalAcute,
    DiacriticalDot: DiacriticalDot,
    DiacriticalDoubleAcute: DiacriticalDoubleAcute,
    DiacriticalGrave: DiacriticalGrave,
    DiacriticalTilde: DiacriticalTilde,
    diam: diam,
    diamond: diamond,
    Diamond: Diamond,
    diamondsuit: diamondsuit,
    diams: diams,
    die: die,
    DifferentialD: DifferentialD,
    digamma: digamma,
    disin: disin,
    div: div,
    divide: divide,
    divideontimes: divideontimes,
    divonx: divonx,
    DJcy: DJcy,
    djcy: djcy,
    dlcorn: dlcorn,
    dlcrop: dlcrop,
    dollar: dollar,
    Dopf: Dopf,
    dopf: dopf,
    Dot: Dot,
    dot: dot,
    DotDot: DotDot,
    doteq: doteq,
    doteqdot: doteqdot,
    DotEqual: DotEqual,
    dotminus: dotminus,
    dotplus: dotplus,
    dotsquare: dotsquare,
    doublebarwedge: doublebarwedge,
    DoubleContourIntegral: DoubleContourIntegral,
    DoubleDot: DoubleDot,
    DoubleDownArrow: DoubleDownArrow,
    DoubleLeftArrow: DoubleLeftArrow,
    DoubleLeftRightArrow: DoubleLeftRightArrow,
    DoubleLeftTee: DoubleLeftTee,
    DoubleLongLeftArrow: DoubleLongLeftArrow,
    DoubleLongLeftRightArrow: DoubleLongLeftRightArrow,
    DoubleLongRightArrow: DoubleLongRightArrow,
    DoubleRightArrow: DoubleRightArrow,
    DoubleRightTee: DoubleRightTee,
    DoubleUpArrow: DoubleUpArrow,
    DoubleUpDownArrow: DoubleUpDownArrow,
    DoubleVerticalBar: DoubleVerticalBar,
    DownArrowBar: DownArrowBar,
    downarrow: downarrow,
    DownArrow: DownArrow,
    Downarrow: Downarrow,
    DownArrowUpArrow: DownArrowUpArrow,
    DownBreve: DownBreve,
    downdownarrows: downdownarrows,
    downharpoonleft: downharpoonleft,
    downharpoonright: downharpoonright,
    DownLeftRightVector: DownLeftRightVector,
    DownLeftTeeVector: DownLeftTeeVector,
    DownLeftVectorBar: DownLeftVectorBar,
    DownLeftVector: DownLeftVector,
    DownRightTeeVector: DownRightTeeVector,
    DownRightVectorBar: DownRightVectorBar,
    DownRightVector: DownRightVector,
    DownTeeArrow: DownTeeArrow,
    DownTee: DownTee,
    drbkarow: drbkarow,
    drcorn: drcorn,
    drcrop: drcrop,
    Dscr: Dscr,
    dscr: dscr,
    DScy: DScy,
    dscy: dscy,
    dsol: dsol,
    Dstrok: Dstrok,
    dstrok: dstrok,
    dtdot: dtdot,
    dtri: dtri,
    dtrif: dtrif,
    duarr: duarr,
    duhar: duhar,
    dwangle: dwangle,
    DZcy: DZcy,
    dzcy: dzcy,
    dzigrarr: dzigrarr,
    Eacute: Eacute,
    eacute: eacute,
    easter: easter,
    Ecaron: Ecaron,
    ecaron: ecaron,
    Ecirc: Ecirc,
    ecirc: ecirc,
    ecir: ecir,
    ecolon: ecolon,
    Ecy: Ecy,
    ecy: ecy,
    eDDot: eDDot,
    Edot: Edot,
    edot: edot,
    eDot: eDot,
    ee: ee,
    efDot: efDot,
    Efr: Efr,
    efr: efr,
    eg: eg,
    Egrave: Egrave,
    egrave: egrave,
    egs: egs,
    egsdot: egsdot,
    el: el,
    Element: Element,
    elinters: elinters,
    ell: ell,
    els: els,
    elsdot: elsdot,
    Emacr: Emacr,
    emacr: emacr,
    empty: empty,
    emptyset: emptyset,
    EmptySmallSquare: EmptySmallSquare,
    emptyv: emptyv,
    EmptyVerySmallSquare: EmptyVerySmallSquare,
    emsp13: emsp13,
    emsp14: emsp14,
    emsp: emsp,
    ENG: ENG,
    eng: eng,
    ensp: ensp,
    Eogon: Eogon,
    eogon: eogon,
    Eopf: Eopf,
    eopf: eopf,
    epar: epar,
    eparsl: eparsl,
    eplus: eplus,
    epsi: epsi,
    Epsilon: Epsilon,
    epsilon: epsilon,
    epsiv: epsiv,
    eqcirc: eqcirc,
    eqcolon: eqcolon,
    eqsim: eqsim,
    eqslantgtr: eqslantgtr,
    eqslantless: eqslantless,
    Equal: Equal,
    equals: equals,
    EqualTilde: EqualTilde,
    equest: equest,
    Equilibrium: Equilibrium,
    equiv: equiv,
    equivDD: equivDD,
    eqvparsl: eqvparsl,
    erarr: erarr,
    erDot: erDot,
    escr: escr,
    Escr: Escr,
    esdot: esdot,
    Esim: Esim,
    esim: esim,
    Eta: Eta,
    eta: eta,
    ETH: ETH,
    eth: eth,
    Euml: Euml,
    euml: euml,
    euro: euro,
    excl: excl,
    exist: exist,
    Exists: Exists,
    expectation: expectation,
    exponentiale: exponentiale,
    ExponentialE: ExponentialE,
    fallingdotseq: fallingdotseq,
    Fcy: Fcy,
    fcy: fcy,
    female: female,
    ffilig: ffilig,
    fflig: fflig,
    ffllig: ffllig,
    Ffr: Ffr,
    ffr: ffr,
    filig: filig,
    FilledSmallSquare: FilledSmallSquare,
    FilledVerySmallSquare: FilledVerySmallSquare,
    fjlig: fjlig,
    flat: flat,
    fllig: fllig,
    fltns: fltns,
    fnof: fnof,
    Fopf: Fopf,
    fopf: fopf,
    forall: forall,
    ForAll: ForAll,
    fork: fork,
    forkv: forkv,
    Fouriertrf: Fouriertrf,
    fpartint: fpartint,
    frac12: frac12,
    frac13: frac13,
    frac14: frac14,
    frac15: frac15,
    frac16: frac16,
    frac18: frac18,
    frac23: frac23,
    frac25: frac25,
    frac34: frac34,
    frac35: frac35,
    frac38: frac38,
    frac45: frac45,
    frac56: frac56,
    frac58: frac58,
    frac78: frac78,
    frasl: frasl,
    frown: frown,
    fscr: fscr,
    Fscr: Fscr,
    gacute: gacute,
    Gamma: Gamma,
    gamma: gamma,
    Gammad: Gammad,
    gammad: gammad,
    gap: gap,
    Gbreve: Gbreve,
    gbreve: gbreve,
    Gcedil: Gcedil,
    Gcirc: Gcirc,
    gcirc: gcirc,
    Gcy: Gcy,
    gcy: gcy,
    Gdot: Gdot,
    gdot: gdot,
    ge: ge,
    gE: gE,
    gEl: gEl,
    gel: gel,
    geq: geq,
    geqq: geqq,
    geqslant: geqslant,
    gescc: gescc,
    ges: ges,
    gesdot: gesdot,
    gesdoto: gesdoto,
    gesdotol: gesdotol,
    gesl: gesl,
    gesles: gesles,
    Gfr: Gfr,
    gfr: gfr,
    gg: gg,
    Gg: Gg,
    ggg: ggg,
    gimel: gimel,
    GJcy: GJcy,
    gjcy: gjcy,
    gla: gla,
    gl: gl,
    glE: glE,
    glj: glj,
    gnap: gnap,
    gnapprox: gnapprox,
    gne: gne,
    gnE: gnE,
    gneq: gneq,
    gneqq: gneqq,
    gnsim: gnsim,
    Gopf: Gopf,
    gopf: gopf,
    grave: grave,
    GreaterEqual: GreaterEqual,
    GreaterEqualLess: GreaterEqualLess,
    GreaterFullEqual: GreaterFullEqual,
    GreaterGreater: GreaterGreater,
    GreaterLess: GreaterLess,
    GreaterSlantEqual: GreaterSlantEqual,
    GreaterTilde: GreaterTilde,
    Gscr: Gscr,
    gscr: gscr,
    gsim: gsim,
    gsime: gsime,
    gsiml: gsiml,
    gtcc: gtcc,
    gtcir: gtcir,
    gt: gt,
    GT: GT,
    Gt: Gt,
    gtdot: gtdot,
    gtlPar: gtlPar,
    gtquest: gtquest,
    gtrapprox: gtrapprox,
    gtrarr: gtrarr,
    gtrdot: gtrdot,
    gtreqless: gtreqless,
    gtreqqless: gtreqqless,
    gtrless: gtrless,
    gtrsim: gtrsim,
    gvertneqq: gvertneqq,
    gvnE: gvnE,
    Hacek: Hacek,
    hairsp: hairsp,
    half: half,
    hamilt: hamilt,
    HARDcy: HARDcy,
    hardcy: hardcy,
    harrcir: harrcir,
    harr: harr,
    hArr: hArr,
    harrw: harrw,
    Hat: Hat,
    hbar: hbar,
    Hcirc: Hcirc,
    hcirc: hcirc,
    hearts: hearts,
    heartsuit: heartsuit,
    hellip: hellip,
    hercon: hercon,
    hfr: hfr,
    Hfr: Hfr,
    HilbertSpace: HilbertSpace,
    hksearow: hksearow,
    hkswarow: hkswarow,
    hoarr: hoarr,
    homtht: homtht,
    hookleftarrow: hookleftarrow,
    hookrightarrow: hookrightarrow,
    hopf: hopf,
    Hopf: Hopf,
    horbar: horbar,
    HorizontalLine: HorizontalLine,
    hscr: hscr,
    Hscr: Hscr,
    hslash: hslash,
    Hstrok: Hstrok,
    hstrok: hstrok,
    HumpDownHump: HumpDownHump,
    HumpEqual: HumpEqual,
    hybull: hybull,
    hyphen: hyphen,
    Iacute: Iacute,
    iacute: iacute,
    ic: ic,
    Icirc: Icirc,
    icirc: icirc,
    Icy: Icy,
    icy: icy,
    Idot: Idot,
    IEcy: IEcy,
    iecy: iecy,
    iexcl: iexcl,
    iff: iff,
    ifr: ifr,
    Ifr: Ifr,
    Igrave: Igrave,
    igrave: igrave,
    ii: ii,
    iiiint: iiiint,
    iiint: iiint,
    iinfin: iinfin,
    iiota: iiota,
    IJlig: IJlig,
    ijlig: ijlig,
    Imacr: Imacr,
    imacr: imacr,
    image: image,
    ImaginaryI: ImaginaryI,
    imagline: imagline,
    imagpart: imagpart,
    imath: imath,
    Im: Im,
    imof: imof,
    imped: imped,
    Implies: Implies,
    incare: incare,
    infin: infin,
    infintie: infintie,
    inodot: inodot,
    intcal: intcal,
    int: int,
    Int: Int,
    integers: integers,
    Integral: Integral,
    intercal: intercal,
    Intersection: Intersection,
    intlarhk: intlarhk,
    intprod: intprod,
    InvisibleComma: InvisibleComma,
    InvisibleTimes: InvisibleTimes,
    IOcy: IOcy,
    iocy: iocy,
    Iogon: Iogon,
    iogon: iogon,
    Iopf: Iopf,
    iopf: iopf,
    Iota: Iota,
    iota: iota,
    iprod: iprod,
    iquest: iquest,
    iscr: iscr,
    Iscr: Iscr,
    isin: isin,
    isindot: isindot,
    isinE: isinE,
    isins: isins,
    isinsv: isinsv,
    isinv: isinv,
    it: it,
    Itilde: Itilde,
    itilde: itilde,
    Iukcy: Iukcy,
    iukcy: iukcy,
    Iuml: Iuml,
    iuml: iuml,
    Jcirc: Jcirc,
    jcirc: jcirc,
    Jcy: Jcy,
    jcy: jcy,
    Jfr: Jfr,
    jfr: jfr,
    jmath: jmath,
    Jopf: Jopf,
    jopf: jopf,
    Jscr: Jscr,
    jscr: jscr,
    Jsercy: Jsercy,
    jsercy: jsercy,
    Jukcy: Jukcy,
    jukcy: jukcy,
    Kappa: Kappa,
    kappa: kappa,
    kappav: kappav,
    Kcedil: Kcedil,
    kcedil: kcedil,
    Kcy: Kcy,
    kcy: kcy,
    Kfr: Kfr,
    kfr: kfr,
    kgreen: kgreen,
    KHcy: KHcy,
    khcy: khcy,
    KJcy: KJcy,
    kjcy: kjcy,
    Kopf: Kopf,
    kopf: kopf,
    Kscr: Kscr,
    kscr: kscr,
    lAarr: lAarr,
    Lacute: Lacute,
    lacute: lacute,
    laemptyv: laemptyv,
    lagran: lagran,
    Lambda: Lambda,
    lambda: lambda,
    lang: lang,
    Lang: Lang,
    langd: langd,
    langle: langle,
    lap: lap,
    Laplacetrf: Laplacetrf,
    laquo: laquo,
    larrb: larrb,
    larrbfs: larrbfs,
    larr: larr,
    Larr: Larr,
    lArr: lArr,
    larrfs: larrfs,
    larrhk: larrhk,
    larrlp: larrlp,
    larrpl: larrpl,
    larrsim: larrsim,
    larrtl: larrtl,
    latail: latail,
    lAtail: lAtail,
    lat: lat,
    late: late,
    lates: lates,
    lbarr: lbarr,
    lBarr: lBarr,
    lbbrk: lbbrk,
    lbrace: lbrace,
    lbrack: lbrack,
    lbrke: lbrke,
    lbrksld: lbrksld,
    lbrkslu: lbrkslu,
    Lcaron: Lcaron,
    lcaron: lcaron,
    Lcedil: Lcedil,
    lcedil: lcedil,
    lceil: lceil,
    lcub: lcub,
    Lcy: Lcy,
    lcy: lcy,
    ldca: ldca,
    ldquo: ldquo,
    ldquor: ldquor,
    ldrdhar: ldrdhar,
    ldrushar: ldrushar,
    ldsh: ldsh,
    le: le,
    lE: lE,
    LeftAngleBracket: LeftAngleBracket,
    LeftArrowBar: LeftArrowBar,
    leftarrow: leftarrow,
    LeftArrow: LeftArrow,
    Leftarrow: Leftarrow,
    LeftArrowRightArrow: LeftArrowRightArrow,
    leftarrowtail: leftarrowtail,
    LeftCeiling: LeftCeiling,
    LeftDoubleBracket: LeftDoubleBracket,
    LeftDownTeeVector: LeftDownTeeVector,
    LeftDownVectorBar: LeftDownVectorBar,
    LeftDownVector: LeftDownVector,
    LeftFloor: LeftFloor,
    leftharpoondown: leftharpoondown,
    leftharpoonup: leftharpoonup,
    leftleftarrows: leftleftarrows,
    leftrightarrow: leftrightarrow,
    LeftRightArrow: LeftRightArrow,
    Leftrightarrow: Leftrightarrow,
    leftrightarrows: leftrightarrows,
    leftrightharpoons: leftrightharpoons,
    leftrightsquigarrow: leftrightsquigarrow,
    LeftRightVector: LeftRightVector,
    LeftTeeArrow: LeftTeeArrow,
    LeftTee: LeftTee,
    LeftTeeVector: LeftTeeVector,
    leftthreetimes: leftthreetimes,
    LeftTriangleBar: LeftTriangleBar,
    LeftTriangle: LeftTriangle,
    LeftTriangleEqual: LeftTriangleEqual,
    LeftUpDownVector: LeftUpDownVector,
    LeftUpTeeVector: LeftUpTeeVector,
    LeftUpVectorBar: LeftUpVectorBar,
    LeftUpVector: LeftUpVector,
    LeftVectorBar: LeftVectorBar,
    LeftVector: LeftVector,
    lEg: lEg,
    leg: leg,
    leq: leq,
    leqq: leqq,
    leqslant: leqslant,
    lescc: lescc,
    les: les,
    lesdot: lesdot,
    lesdoto: lesdoto,
    lesdotor: lesdotor,
    lesg: lesg,
    lesges: lesges,
    lessapprox: lessapprox,
    lessdot: lessdot,
    lesseqgtr: lesseqgtr,
    lesseqqgtr: lesseqqgtr,
    LessEqualGreater: LessEqualGreater,
    LessFullEqual: LessFullEqual,
    LessGreater: LessGreater,
    lessgtr: lessgtr,
    LessLess: LessLess,
    lesssim: lesssim,
    LessSlantEqual: LessSlantEqual,
    LessTilde: LessTilde,
    lfisht: lfisht,
    lfloor: lfloor,
    Lfr: Lfr,
    lfr: lfr,
    lg: lg,
    lgE: lgE,
    lHar: lHar,
    lhard: lhard,
    lharu: lharu,
    lharul: lharul,
    lhblk: lhblk,
    LJcy: LJcy,
    ljcy: ljcy,
    llarr: llarr,
    ll: ll,
    Ll: Ll,
    llcorner: llcorner,
    Lleftarrow: Lleftarrow,
    llhard: llhard,
    lltri: lltri,
    Lmidot: Lmidot,
    lmidot: lmidot,
    lmoustache: lmoustache,
    lmoust: lmoust,
    lnap: lnap,
    lnapprox: lnapprox,
    lne: lne,
    lnE: lnE,
    lneq: lneq,
    lneqq: lneqq,
    lnsim: lnsim,
    loang: loang,
    loarr: loarr,
    lobrk: lobrk,
    longleftarrow: longleftarrow,
    LongLeftArrow: LongLeftArrow,
    Longleftarrow: Longleftarrow,
    longleftrightarrow: longleftrightarrow,
    LongLeftRightArrow: LongLeftRightArrow,
    Longleftrightarrow: Longleftrightarrow,
    longmapsto: longmapsto,
    longrightarrow: longrightarrow,
    LongRightArrow: LongRightArrow,
    Longrightarrow: Longrightarrow,
    looparrowleft: looparrowleft,
    looparrowright: looparrowright,
    lopar: lopar,
    Lopf: Lopf,
    lopf: lopf,
    loplus: loplus,
    lotimes: lotimes,
    lowast: lowast,
    lowbar: lowbar,
    LowerLeftArrow: LowerLeftArrow,
    LowerRightArrow: LowerRightArrow,
    loz: loz,
    lozenge: lozenge,
    lozf: lozf,
    lpar: lpar,
    lparlt: lparlt,
    lrarr: lrarr,
    lrcorner: lrcorner,
    lrhar: lrhar,
    lrhard: lrhard,
    lrm: lrm,
    lrtri: lrtri,
    lsaquo: lsaquo,
    lscr: lscr,
    Lscr: Lscr,
    lsh: lsh,
    Lsh: Lsh,
    lsim: lsim,
    lsime: lsime,
    lsimg: lsimg,
    lsqb: lsqb,
    lsquo: lsquo,
    lsquor: lsquor,
    Lstrok: Lstrok,
    lstrok: lstrok,
    ltcc: ltcc,
    ltcir: ltcir,
    lt: lt,
    LT: LT,
    Lt: Lt,
    ltdot: ltdot,
    lthree: lthree,
    ltimes: ltimes,
    ltlarr: ltlarr,
    ltquest: ltquest,
    ltri: ltri,
    ltrie: ltrie,
    ltrif: ltrif,
    ltrPar: ltrPar,
    lurdshar: lurdshar,
    luruhar: luruhar,
    lvertneqq: lvertneqq,
    lvnE: lvnE,
    macr: macr,
    male: male,
    malt: malt,
    maltese: maltese,
    map: map,
    mapsto: mapsto,
    mapstodown: mapstodown,
    mapstoleft: mapstoleft,
    mapstoup: mapstoup,
    marker: marker,
    mcomma: mcomma,
    Mcy: Mcy,
    mcy: mcy,
    mdash: mdash,
    mDDot: mDDot,
    measuredangle: measuredangle,
    MediumSpace: MediumSpace,
    Mellintrf: Mellintrf,
    Mfr: Mfr,
    mfr: mfr,
    mho: mho,
    micro: micro,
    midast: midast,
    midcir: midcir,
    mid: mid,
    middot: middot,
    minusb: minusb,
    minus: minus,
    minusd: minusd,
    minusdu: minusdu,
    MinusPlus: MinusPlus,
    mlcp: mlcp,
    mldr: mldr,
    mnplus: mnplus,
    models: models,
    Mopf: Mopf,
    mopf: mopf,
    mp: mp,
    mscr: mscr,
    Mscr: Mscr,
    mstpos: mstpos,
    Mu: Mu,
    mu: mu,
    multimap: multimap,
    mumap: mumap,
    nabla: nabla,
    Nacute: Nacute,
    nacute: nacute,
    nang: nang,
    nap: nap,
    napE: napE,
    napid: napid,
    napos: napos,
    napprox: napprox,
    natural: natural,
    naturals: naturals,
    natur: natur,
    nbsp: nbsp,
    nbump: nbump,
    nbumpe: nbumpe,
    ncap: ncap,
    Ncaron: Ncaron,
    ncaron: ncaron,
    Ncedil: Ncedil,
    ncedil: ncedil,
    ncong: ncong,
    ncongdot: ncongdot,
    ncup: ncup,
    Ncy: Ncy,
    ncy: ncy,
    ndash: ndash,
    nearhk: nearhk,
    nearr: nearr,
    neArr: neArr,
    nearrow: nearrow,
    ne: ne,
    nedot: nedot,
    NegativeMediumSpace: NegativeMediumSpace,
    NegativeThickSpace: NegativeThickSpace,
    NegativeThinSpace: NegativeThinSpace,
    NegativeVeryThinSpace: NegativeVeryThinSpace,
    nequiv: nequiv,
    nesear: nesear,
    nesim: nesim,
    NestedGreaterGreater: NestedGreaterGreater,
    NestedLessLess: NestedLessLess,
    NewLine: NewLine,
    nexist: nexist,
    nexists: nexists,
    Nfr: Nfr,
    nfr: nfr,
    ngE: ngE,
    nge: nge,
    ngeq: ngeq,
    ngeqq: ngeqq,
    ngeqslant: ngeqslant,
    nges: nges,
    nGg: nGg,
    ngsim: ngsim,
    nGt: nGt,
    ngt: ngt,
    ngtr: ngtr,
    nGtv: nGtv,
    nharr: nharr,
    nhArr: nhArr,
    nhpar: nhpar,
    ni: ni,
    nis: nis,
    nisd: nisd,
    niv: niv,
    NJcy: NJcy,
    njcy: njcy,
    nlarr: nlarr,
    nlArr: nlArr,
    nldr: nldr,
    nlE: nlE,
    nle: nle,
    nleftarrow: nleftarrow,
    nLeftarrow: nLeftarrow,
    nleftrightarrow: nleftrightarrow,
    nLeftrightarrow: nLeftrightarrow,
    nleq: nleq,
    nleqq: nleqq,
    nleqslant: nleqslant,
    nles: nles,
    nless: nless,
    nLl: nLl,
    nlsim: nlsim,
    nLt: nLt,
    nlt: nlt,
    nltri: nltri,
    nltrie: nltrie,
    nLtv: nLtv,
    nmid: nmid,
    NoBreak: NoBreak,
    NonBreakingSpace: NonBreakingSpace,
    nopf: nopf,
    Nopf: Nopf,
    Not: Not,
    not: not,
    NotCongruent: NotCongruent,
    NotCupCap: NotCupCap,
    NotDoubleVerticalBar: NotDoubleVerticalBar,
    NotElement: NotElement,
    NotEqual: NotEqual,
    NotEqualTilde: NotEqualTilde,
    NotExists: NotExists,
    NotGreater: NotGreater,
    NotGreaterEqual: NotGreaterEqual,
    NotGreaterFullEqual: NotGreaterFullEqual,
    NotGreaterGreater: NotGreaterGreater,
    NotGreaterLess: NotGreaterLess,
    NotGreaterSlantEqual: NotGreaterSlantEqual,
    NotGreaterTilde: NotGreaterTilde,
    NotHumpDownHump: NotHumpDownHump,
    NotHumpEqual: NotHumpEqual,
    notin: notin,
    notindot: notindot,
    notinE: notinE,
    notinva: notinva,
    notinvb: notinvb,
    notinvc: notinvc,
    NotLeftTriangleBar: NotLeftTriangleBar,
    NotLeftTriangle: NotLeftTriangle,
    NotLeftTriangleEqual: NotLeftTriangleEqual,
    NotLess: NotLess,
    NotLessEqual: NotLessEqual,
    NotLessGreater: NotLessGreater,
    NotLessLess: NotLessLess,
    NotLessSlantEqual: NotLessSlantEqual,
    NotLessTilde: NotLessTilde,
    NotNestedGreaterGreater: NotNestedGreaterGreater,
    NotNestedLessLess: NotNestedLessLess,
    notni: notni,
    notniva: notniva,
    notnivb: notnivb,
    notnivc: notnivc,
    NotPrecedes: NotPrecedes,
    NotPrecedesEqual: NotPrecedesEqual,
    NotPrecedesSlantEqual: NotPrecedesSlantEqual,
    NotReverseElement: NotReverseElement,
    NotRightTriangleBar: NotRightTriangleBar,
    NotRightTriangle: NotRightTriangle,
    NotRightTriangleEqual: NotRightTriangleEqual,
    NotSquareSubset: NotSquareSubset,
    NotSquareSubsetEqual: NotSquareSubsetEqual,
    NotSquareSuperset: NotSquareSuperset,
    NotSquareSupersetEqual: NotSquareSupersetEqual,
    NotSubset: NotSubset,
    NotSubsetEqual: NotSubsetEqual,
    NotSucceeds: NotSucceeds,
    NotSucceedsEqual: NotSucceedsEqual,
    NotSucceedsSlantEqual: NotSucceedsSlantEqual,
    NotSucceedsTilde: NotSucceedsTilde,
    NotSuperset: NotSuperset,
    NotSupersetEqual: NotSupersetEqual,
    NotTilde: NotTilde,
    NotTildeEqual: NotTildeEqual,
    NotTildeFullEqual: NotTildeFullEqual,
    NotTildeTilde: NotTildeTilde,
    NotVerticalBar: NotVerticalBar,
    nparallel: nparallel,
    npar: npar,
    nparsl: nparsl,
    npart: npart,
    npolint: npolint,
    npr: npr,
    nprcue: nprcue,
    nprec: nprec,
    npreceq: npreceq,
    npre: npre,
    nrarrc: nrarrc,
    nrarr: nrarr,
    nrArr: nrArr,
    nrarrw: nrarrw,
    nrightarrow: nrightarrow,
    nRightarrow: nRightarrow,
    nrtri: nrtri,
    nrtrie: nrtrie,
    nsc: nsc,
    nsccue: nsccue,
    nsce: nsce,
    Nscr: Nscr,
    nscr: nscr,
    nshortmid: nshortmid,
    nshortparallel: nshortparallel,
    nsim: nsim,
    nsime: nsime,
    nsimeq: nsimeq,
    nsmid: nsmid,
    nspar: nspar,
    nsqsube: nsqsube,
    nsqsupe: nsqsupe,
    nsub: nsub,
    nsubE: nsubE,
    nsube: nsube,
    nsubset: nsubset,
    nsubseteq: nsubseteq,
    nsubseteqq: nsubseteqq,
    nsucc: nsucc,
    nsucceq: nsucceq,
    nsup: nsup,
    nsupE: nsupE,
    nsupe: nsupe,
    nsupset: nsupset,
    nsupseteq: nsupseteq,
    nsupseteqq: nsupseteqq,
    ntgl: ntgl,
    Ntilde: Ntilde,
    ntilde: ntilde,
    ntlg: ntlg,
    ntriangleleft: ntriangleleft,
    ntrianglelefteq: ntrianglelefteq,
    ntriangleright: ntriangleright,
    ntrianglerighteq: ntrianglerighteq,
    Nu: Nu,
    nu: nu,
    num: num,
    numero: numero,
    numsp: numsp,
    nvap: nvap,
    nvdash: nvdash,
    nvDash: nvDash,
    nVdash: nVdash,
    nVDash: nVDash,
    nvge: nvge,
    nvgt: nvgt,
    nvHarr: nvHarr,
    nvinfin: nvinfin,
    nvlArr: nvlArr,
    nvle: nvle,
    nvlt: nvlt,
    nvltrie: nvltrie,
    nvrArr: nvrArr,
    nvrtrie: nvrtrie,
    nvsim: nvsim,
    nwarhk: nwarhk,
    nwarr: nwarr,
    nwArr: nwArr,
    nwarrow: nwarrow,
    nwnear: nwnear,
    Oacute: Oacute,
    oacute: oacute,
    oast: oast,
    Ocirc: Ocirc,
    ocirc: ocirc,
    ocir: ocir,
    Ocy: Ocy,
    ocy: ocy,
    odash: odash,
    Odblac: Odblac,
    odblac: odblac,
    odiv: odiv,
    odot: odot,
    odsold: odsold,
    OElig: OElig,
    oelig: oelig,
    ofcir: ofcir,
    Ofr: Ofr,
    ofr: ofr,
    ogon: ogon,
    Ograve: Ograve,
    ograve: ograve,
    ogt: ogt,
    ohbar: ohbar,
    ohm: ohm,
    oint: oint,
    olarr: olarr,
    olcir: olcir,
    olcross: olcross,
    oline: oline,
    olt: olt,
    Omacr: Omacr,
    omacr: omacr,
    Omega: Omega,
    omega: omega,
    Omicron: Omicron,
    omicron: omicron,
    omid: omid,
    ominus: ominus,
    Oopf: Oopf,
    oopf: oopf,
    opar: opar,
    OpenCurlyDoubleQuote: OpenCurlyDoubleQuote,
    OpenCurlyQuote: OpenCurlyQuote,
    operp: operp,
    oplus: oplus,
    orarr: orarr,
    Or: Or,
    or: or,
    ord: ord,
    order: order,
    orderof: orderof,
    ordf: ordf,
    ordm: ordm,
    origof: origof,
    oror: oror,
    orslope: orslope,
    orv: orv,
    oS: oS,
    Oscr: Oscr,
    oscr: oscr,
    Oslash: Oslash,
    oslash: oslash,
    osol: osol,
    Otilde: Otilde,
    otilde: otilde,
    otimesas: otimesas,
    Otimes: Otimes,
    otimes: otimes,
    Ouml: Ouml,
    ouml: ouml,
    ovbar: ovbar,
    OverBar: OverBar,
    OverBrace: OverBrace,
    OverBracket: OverBracket,
    OverParenthesis: OverParenthesis,
    para: para,
    parallel: parallel,
    par: par,
    parsim: parsim,
    parsl: parsl,
    part: part,
    PartialD: PartialD,
    Pcy: Pcy,
    pcy: pcy,
    percnt: percnt,
    period: period,
    permil: permil,
    perp: perp,
    pertenk: pertenk,
    Pfr: Pfr,
    pfr: pfr,
    Phi: Phi,
    phi: phi,
    phiv: phiv,
    phmmat: phmmat,
    phone: phone,
    Pi: Pi,
    pi: pi,
    pitchfork: pitchfork,
    piv: piv,
    planck: planck,
    planckh: planckh,
    plankv: plankv,
    plusacir: plusacir,
    plusb: plusb,
    pluscir: pluscir,
    plus: plus,
    plusdo: plusdo,
    plusdu: plusdu,
    pluse: pluse,
    PlusMinus: PlusMinus,
    plusmn: plusmn,
    plussim: plussim,
    plustwo: plustwo,
    pm: pm,
    Poincareplane: Poincareplane,
    pointint: pointint,
    popf: popf,
    Popf: Popf,
    pound: pound,
    prap: prap,
    Pr: Pr,
    pr: pr,
    prcue: prcue,
    precapprox: precapprox,
    prec: prec,
    preccurlyeq: preccurlyeq,
    Precedes: Precedes,
    PrecedesEqual: PrecedesEqual,
    PrecedesSlantEqual: PrecedesSlantEqual,
    PrecedesTilde: PrecedesTilde,
    preceq: preceq,
    precnapprox: precnapprox,
    precneqq: precneqq,
    precnsim: precnsim,
    pre: pre,
    prE: prE,
    precsim: precsim,
    prime: prime,
    Prime: Prime,
    primes: primes,
    prnap: prnap,
    prnE: prnE,
    prnsim: prnsim,
    prod: prod,
    Product: Product,
    profalar: profalar,
    profline: profline,
    profsurf: profsurf,
    prop: prop,
    Proportional: Proportional,
    Proportion: Proportion,
    propto: propto,
    prsim: prsim,
    prurel: prurel,
    Pscr: Pscr,
    pscr: pscr,
    Psi: Psi,
    psi: psi,
    puncsp: puncsp,
    Qfr: Qfr,
    qfr: qfr,
    qint: qint,
    qopf: qopf,
    Qopf: Qopf,
    qprime: qprime,
    Qscr: Qscr,
    qscr: qscr,
    quaternions: quaternions,
    quatint: quatint,
    quest: quest,
    questeq: questeq,
    quot: quot,
    QUOT: QUOT,
    rAarr: rAarr,
    race: race,
    Racute: Racute,
    racute: racute,
    radic: radic,
    raemptyv: raemptyv,
    rang: rang,
    Rang: Rang,
    rangd: rangd,
    range: range,
    rangle: rangle,
    raquo: raquo,
    rarrap: rarrap,
    rarrb: rarrb,
    rarrbfs: rarrbfs,
    rarrc: rarrc,
    rarr: rarr,
    Rarr: Rarr,
    rArr: rArr,
    rarrfs: rarrfs,
    rarrhk: rarrhk,
    rarrlp: rarrlp,
    rarrpl: rarrpl,
    rarrsim: rarrsim,
    Rarrtl: Rarrtl,
    rarrtl: rarrtl,
    rarrw: rarrw,
    ratail: ratail,
    rAtail: rAtail,
    ratio: ratio,
    rationals: rationals,
    rbarr: rbarr,
    rBarr: rBarr,
    RBarr: RBarr,
    rbbrk: rbbrk,
    rbrace: rbrace,
    rbrack: rbrack,
    rbrke: rbrke,
    rbrksld: rbrksld,
    rbrkslu: rbrkslu,
    Rcaron: Rcaron,
    rcaron: rcaron,
    Rcedil: Rcedil,
    rcedil: rcedil,
    rceil: rceil,
    rcub: rcub,
    Rcy: Rcy,
    rcy: rcy,
    rdca: rdca,
    rdldhar: rdldhar,
    rdquo: rdquo,
    rdquor: rdquor,
    rdsh: rdsh,
    real: real,
    realine: realine,
    realpart: realpart,
    reals: reals,
    Re: Re,
    rect: rect,
    reg: reg,
    REG: REG,
    ReverseElement: ReverseElement,
    ReverseEquilibrium: ReverseEquilibrium,
    ReverseUpEquilibrium: ReverseUpEquilibrium,
    rfisht: rfisht,
    rfloor: rfloor,
    rfr: rfr,
    Rfr: Rfr,
    rHar: rHar,
    rhard: rhard,
    rharu: rharu,
    rharul: rharul,
    Rho: Rho,
    rho: rho,
    rhov: rhov,
    RightAngleBracket: RightAngleBracket,
    RightArrowBar: RightArrowBar,
    rightarrow: rightarrow,
    RightArrow: RightArrow,
    Rightarrow: Rightarrow,
    RightArrowLeftArrow: RightArrowLeftArrow,
    rightarrowtail: rightarrowtail,
    RightCeiling: RightCeiling,
    RightDoubleBracket: RightDoubleBracket,
    RightDownTeeVector: RightDownTeeVector,
    RightDownVectorBar: RightDownVectorBar,
    RightDownVector: RightDownVector,
    RightFloor: RightFloor,
    rightharpoondown: rightharpoondown,
    rightharpoonup: rightharpoonup,
    rightleftarrows: rightleftarrows,
    rightleftharpoons: rightleftharpoons,
    rightrightarrows: rightrightarrows,
    rightsquigarrow: rightsquigarrow,
    RightTeeArrow: RightTeeArrow,
    RightTee: RightTee,
    RightTeeVector: RightTeeVector,
    rightthreetimes: rightthreetimes,
    RightTriangleBar: RightTriangleBar,
    RightTriangle: RightTriangle,
    RightTriangleEqual: RightTriangleEqual,
    RightUpDownVector: RightUpDownVector,
    RightUpTeeVector: RightUpTeeVector,
    RightUpVectorBar: RightUpVectorBar,
    RightUpVector: RightUpVector,
    RightVectorBar: RightVectorBar,
    RightVector: RightVector,
    ring: ring,
    risingdotseq: risingdotseq,
    rlarr: rlarr,
    rlhar: rlhar,
    rlm: rlm,
    rmoustache: rmoustache,
    rmoust: rmoust,
    rnmid: rnmid,
    roang: roang,
    roarr: roarr,
    robrk: robrk,
    ropar: ropar,
    ropf: ropf,
    Ropf: Ropf,
    roplus: roplus,
    rotimes: rotimes,
    RoundImplies: RoundImplies,
    rpar: rpar,
    rpargt: rpargt,
    rppolint: rppolint,
    rrarr: rrarr,
    Rrightarrow: Rrightarrow,
    rsaquo: rsaquo,
    rscr: rscr,
    Rscr: Rscr,
    rsh: rsh,
    Rsh: Rsh,
    rsqb: rsqb,
    rsquo: rsquo,
    rsquor: rsquor,
    rthree: rthree,
    rtimes: rtimes,
    rtri: rtri,
    rtrie: rtrie,
    rtrif: rtrif,
    rtriltri: rtriltri,
    RuleDelayed: RuleDelayed,
    ruluhar: ruluhar,
    rx: rx,
    Sacute: Sacute,
    sacute: sacute,
    sbquo: sbquo,
    scap: scap,
    Scaron: Scaron,
    scaron: scaron,
    Sc: Sc,
    sc: sc,
    sccue: sccue,
    sce: sce,
    scE: scE,
    Scedil: Scedil,
    scedil: scedil,
    Scirc: Scirc,
    scirc: scirc,
    scnap: scnap,
    scnE: scnE,
    scnsim: scnsim,
    scpolint: scpolint,
    scsim: scsim,
    Scy: Scy,
    scy: scy,
    sdotb: sdotb,
    sdot: sdot,
    sdote: sdote,
    searhk: searhk,
    searr: searr,
    seArr: seArr,
    searrow: searrow,
    sect: sect,
    semi: semi,
    seswar: seswar,
    setminus: setminus,
    setmn: setmn,
    sext: sext,
    Sfr: Sfr,
    sfr: sfr,
    sfrown: sfrown,
    sharp: sharp,
    SHCHcy: SHCHcy,
    shchcy: shchcy,
    SHcy: SHcy,
    shcy: shcy,
    ShortDownArrow: ShortDownArrow,
    ShortLeftArrow: ShortLeftArrow,
    shortmid: shortmid,
    shortparallel: shortparallel,
    ShortRightArrow: ShortRightArrow,
    ShortUpArrow: ShortUpArrow,
    shy: shy,
    Sigma: Sigma,
    sigma: sigma,
    sigmaf: sigmaf,
    sigmav: sigmav,
    sim: sim,
    simdot: simdot,
    sime: sime,
    simeq: simeq,
    simg: simg,
    simgE: simgE,
    siml: siml,
    simlE: simlE,
    simne: simne,
    simplus: simplus,
    simrarr: simrarr,
    slarr: slarr,
    SmallCircle: SmallCircle,
    smallsetminus: smallsetminus,
    smashp: smashp,
    smeparsl: smeparsl,
    smid: smid,
    smile: smile,
    smt: smt,
    smte: smte,
    smtes: smtes,
    SOFTcy: SOFTcy,
    softcy: softcy,
    solbar: solbar,
    solb: solb,
    sol: sol,
    Sopf: Sopf,
    sopf: sopf,
    spades: spades,
    spadesuit: spadesuit,
    spar: spar,
    sqcap: sqcap,
    sqcaps: sqcaps,
    sqcup: sqcup,
    sqcups: sqcups,
    Sqrt: Sqrt,
    sqsub: sqsub,
    sqsube: sqsube,
    sqsubset: sqsubset,
    sqsubseteq: sqsubseteq,
    sqsup: sqsup,
    sqsupe: sqsupe,
    sqsupset: sqsupset,
    sqsupseteq: sqsupseteq,
    square: square,
    Square: Square,
    SquareIntersection: SquareIntersection,
    SquareSubset: SquareSubset,
    SquareSubsetEqual: SquareSubsetEqual,
    SquareSuperset: SquareSuperset,
    SquareSupersetEqual: SquareSupersetEqual,
    SquareUnion: SquareUnion,
    squarf: squarf,
    squ: squ,
    squf: squf,
    srarr: srarr,
    Sscr: Sscr,
    sscr: sscr,
    ssetmn: ssetmn,
    ssmile: ssmile,
    sstarf: sstarf,
    Star: Star,
    star: star,
    starf: starf,
    straightepsilon: straightepsilon,
    straightphi: straightphi,
    strns: strns,
    sub: sub,
    Sub: Sub,
    subdot: subdot,
    subE: subE,
    sube: sube,
    subedot: subedot,
    submult: submult,
    subnE: subnE,
    subne: subne,
    subplus: subplus,
    subrarr: subrarr,
    subset: subset,
    Subset: Subset,
    subseteq: subseteq,
    subseteqq: subseteqq,
    SubsetEqual: SubsetEqual,
    subsetneq: subsetneq,
    subsetneqq: subsetneqq,
    subsim: subsim,
    subsub: subsub,
    subsup: subsup,
    succapprox: succapprox,
    succ: succ,
    succcurlyeq: succcurlyeq,
    Succeeds: Succeeds,
    SucceedsEqual: SucceedsEqual,
    SucceedsSlantEqual: SucceedsSlantEqual,
    SucceedsTilde: SucceedsTilde,
    succeq: succeq,
    succnapprox: succnapprox,
    succneqq: succneqq,
    succnsim: succnsim,
    succsim: succsim,
    SuchThat: SuchThat,
    sum: sum,
    Sum: Sum,
    sung: sung,
    sup1: sup1,
    sup2: sup2,
    sup3: sup3,
    sup: sup,
    Sup: Sup,
    supdot: supdot,
    supdsub: supdsub,
    supE: supE,
    supe: supe,
    supedot: supedot,
    Superset: Superset,
    SupersetEqual: SupersetEqual,
    suphsol: suphsol,
    suphsub: suphsub,
    suplarr: suplarr,
    supmult: supmult,
    supnE: supnE,
    supne: supne,
    supplus: supplus,
    supset: supset,
    Supset: Supset,
    supseteq: supseteq,
    supseteqq: supseteqq,
    supsetneq: supsetneq,
    supsetneqq: supsetneqq,
    supsim: supsim,
    supsub: supsub,
    supsup: supsup,
    swarhk: swarhk,
    swarr: swarr,
    swArr: swArr,
    swarrow: swarrow,
    swnwar: swnwar,
    szlig: szlig,
    Tab: Tab,
    target: target,
    Tau: Tau,
    tau: tau,
    tbrk: tbrk,
    Tcaron: Tcaron,
    tcaron: tcaron,
    Tcedil: Tcedil,
    tcedil: tcedil,
    Tcy: Tcy,
    tcy: tcy,
    tdot: tdot,
    telrec: telrec,
    Tfr: Tfr,
    tfr: tfr,
    there4: there4,
    therefore: therefore,
    Therefore: Therefore,
    Theta: Theta,
    theta: theta,
    thetasym: thetasym,
    thetav: thetav,
    thickapprox: thickapprox,
    thicksim: thicksim,
    ThickSpace: ThickSpace,
    ThinSpace: ThinSpace,
    thinsp: thinsp,
    thkap: thkap,
    thksim: thksim,
    THORN: THORN,
    thorn: thorn,
    tilde: tilde,
    Tilde: Tilde,
    TildeEqual: TildeEqual,
    TildeFullEqual: TildeFullEqual,
    TildeTilde: TildeTilde,
    timesbar: timesbar,
    timesb: timesb,
    times: times,
    timesd: timesd,
    tint: tint,
    toea: toea,
    topbot: topbot,
    topcir: topcir,
    top: top,
    Topf: Topf,
    topf: topf,
    topfork: topfork,
    tosa: tosa,
    tprime: tprime,
    trade: trade,
    TRADE: TRADE,
    triangle: triangle,
    triangledown: triangledown,
    triangleleft: triangleleft,
    trianglelefteq: trianglelefteq,
    triangleq: triangleq,
    triangleright: triangleright,
    trianglerighteq: trianglerighteq,
    tridot: tridot,
    trie: trie,
    triminus: triminus,
    TripleDot: TripleDot,
    triplus: triplus,
    trisb: trisb,
    tritime: tritime,
    trpezium: trpezium,
    Tscr: Tscr,
    tscr: tscr,
    TScy: TScy,
    tscy: tscy,
    TSHcy: TSHcy,
    tshcy: tshcy,
    Tstrok: Tstrok,
    tstrok: tstrok,
    twixt: twixt,
    twoheadleftarrow: twoheadleftarrow,
    twoheadrightarrow: twoheadrightarrow,
    Uacute: Uacute,
    uacute: uacute,
    uarr: uarr,
    Uarr: Uarr,
    uArr: uArr,
    Uarrocir: Uarrocir,
    Ubrcy: Ubrcy,
    ubrcy: ubrcy,
    Ubreve: Ubreve,
    ubreve: ubreve,
    Ucirc: Ucirc,
    ucirc: ucirc,
    Ucy: Ucy,
    ucy: ucy,
    udarr: udarr,
    Udblac: Udblac,
    udblac: udblac,
    udhar: udhar,
    ufisht: ufisht,
    Ufr: Ufr,
    ufr: ufr,
    Ugrave: Ugrave,
    ugrave: ugrave,
    uHar: uHar,
    uharl: uharl,
    uharr: uharr,
    uhblk: uhblk,
    ulcorn: ulcorn,
    ulcorner: ulcorner,
    ulcrop: ulcrop,
    ultri: ultri,
    Umacr: Umacr,
    umacr: umacr,
    uml: uml,
    UnderBar: UnderBar,
    UnderBrace: UnderBrace,
    UnderBracket: UnderBracket,
    UnderParenthesis: UnderParenthesis,
    Union: Union,
    UnionPlus: UnionPlus,
    Uogon: Uogon,
    uogon: uogon,
    Uopf: Uopf,
    uopf: uopf,
    UpArrowBar: UpArrowBar,
    uparrow: uparrow,
    UpArrow: UpArrow,
    Uparrow: Uparrow,
    UpArrowDownArrow: UpArrowDownArrow,
    updownarrow: updownarrow,
    UpDownArrow: UpDownArrow,
    Updownarrow: Updownarrow,
    UpEquilibrium: UpEquilibrium,
    upharpoonleft: upharpoonleft,
    upharpoonright: upharpoonright,
    uplus: uplus,
    UpperLeftArrow: UpperLeftArrow,
    UpperRightArrow: UpperRightArrow,
    upsi: upsi,
    Upsi: Upsi,
    upsih: upsih,
    Upsilon: Upsilon,
    upsilon: upsilon,
    UpTeeArrow: UpTeeArrow,
    UpTee: UpTee,
    upuparrows: upuparrows,
    urcorn: urcorn,
    urcorner: urcorner,
    urcrop: urcrop,
    Uring: Uring,
    uring: uring,
    urtri: urtri,
    Uscr: Uscr,
    uscr: uscr,
    utdot: utdot,
    Utilde: Utilde,
    utilde: utilde,
    utri: utri,
    utrif: utrif,
    uuarr: uuarr,
    Uuml: Uuml,
    uuml: uuml,
    uwangle: uwangle,
    vangrt: vangrt,
    varepsilon: varepsilon,
    varkappa: varkappa,
    varnothing: varnothing,
    varphi: varphi,
    varpi: varpi,
    varpropto: varpropto,
    varr: varr,
    vArr: vArr,
    varrho: varrho,
    varsigma: varsigma,
    varsubsetneq: varsubsetneq,
    varsubsetneqq: varsubsetneqq,
    varsupsetneq: varsupsetneq,
    varsupsetneqq: varsupsetneqq,
    vartheta: vartheta,
    vartriangleleft: vartriangleleft,
    vartriangleright: vartriangleright,
    vBar: vBar,
    Vbar: Vbar,
    vBarv: vBarv,
    Vcy: Vcy,
    vcy: vcy,
    vdash: vdash,
    vDash: vDash,
    Vdash: Vdash,
    VDash: VDash,
    Vdashl: Vdashl,
    veebar: veebar,
    vee: vee,
    Vee: Vee,
    veeeq: veeeq,
    vellip: vellip,
    verbar: verbar,
    Verbar: Verbar,
    vert: vert,
    Vert: Vert,
    VerticalBar: VerticalBar,
    VerticalLine: VerticalLine,
    VerticalSeparator: VerticalSeparator,
    VerticalTilde: VerticalTilde,
    VeryThinSpace: VeryThinSpace,
    Vfr: Vfr,
    vfr: vfr,
    vltri: vltri,
    vnsub: vnsub,
    vnsup: vnsup,
    Vopf: Vopf,
    vopf: vopf,
    vprop: vprop,
    vrtri: vrtri,
    Vscr: Vscr,
    vscr: vscr,
    vsubnE: vsubnE,
    vsubne: vsubne,
    vsupnE: vsupnE,
    vsupne: vsupne,
    Vvdash: Vvdash,
    vzigzag: vzigzag,
    Wcirc: Wcirc,
    wcirc: wcirc,
    wedbar: wedbar,
    wedge: wedge,
    Wedge: Wedge,
    wedgeq: wedgeq,
    weierp: weierp,
    Wfr: Wfr,
    wfr: wfr,
    Wopf: Wopf,
    wopf: wopf,
    wp: wp,
    wr: wr,
    wreath: wreath,
    Wscr: Wscr,
    wscr: wscr,
    xcap: xcap,
    xcirc: xcirc,
    xcup: xcup,
    xdtri: xdtri,
    Xfr: Xfr,
    xfr: xfr,
    xharr: xharr,
    xhArr: xhArr,
    Xi: Xi,
    xi: xi,
    xlarr: xlarr,
    xlArr: xlArr,
    xmap: xmap,
    xnis: xnis,
    xodot: xodot,
    Xopf: Xopf,
    xopf: xopf,
    xoplus: xoplus,
    xotime: xotime,
    xrarr: xrarr,
    xrArr: xrArr,
    Xscr: Xscr,
    xscr: xscr,
    xsqcup: xsqcup,
    xuplus: xuplus,
    xutri: xutri,
    xvee: xvee,
    xwedge: xwedge,
    Yacute: Yacute,
    yacute: yacute,
    YAcy: YAcy,
    yacy: yacy,
    Ycirc: Ycirc,
    ycirc: ycirc,
    Ycy: Ycy,
    ycy: ycy,
    yen: yen,
    Yfr: Yfr,
    yfr: yfr,
    YIcy: YIcy,
    yicy: yicy,
    Yopf: Yopf,
    yopf: yopf,
    Yscr: Yscr,
    yscr: yscr,
    YUcy: YUcy,
    yucy: yucy,
    yuml: yuml,
    Yuml: Yuml,
    Zacute: Zacute,
    zacute: zacute,
    Zcaron: Zcaron,
    zcaron: zcaron,
    Zcy: Zcy,
    zcy: zcy,
    Zdot: Zdot,
    zdot: zdot,
    zeetrf: zeetrf,
    ZeroWidthSpace: ZeroWidthSpace,
    Zeta: Zeta,
    zeta: zeta,
    zfr: zfr,
    Zfr: Zfr,
    ZHcy: ZHcy,
    zhcy: zhcy,
    zigrarr: zigrarr,
    zopf: zopf,
    Zopf: Zopf,
    Zscr: Zscr,
    zscr: zscr,
    zwj: zwj,
    zwnj: zwnj,
    'default': entities
  });

  var Aacute$1 = "Á";
  var aacute$1 = "á";
  var Acirc$1 = "Â";
  var acirc$1 = "â";
  var acute$1 = "´";
  var AElig$1 = "Æ";
  var aelig$1 = "æ";
  var Agrave$1 = "À";
  var agrave$1 = "à";
  var amp$1 = "&";
  var AMP$1 = "&";
  var Aring$1 = "Å";
  var aring$1 = "å";
  var Atilde$1 = "Ã";
  var atilde$1 = "ã";
  var Auml$1 = "Ä";
  var auml$1 = "ä";
  var brvbar$1 = "¦";
  var Ccedil$1 = "Ç";
  var ccedil$1 = "ç";
  var cedil$1 = "¸";
  var cent$1 = "¢";
  var copy$1 = "©";
  var COPY$1 = "©";
  var curren$1 = "¤";
  var deg$1 = "°";
  var divide$1 = "÷";
  var Eacute$1 = "É";
  var eacute$1 = "é";
  var Ecirc$1 = "Ê";
  var ecirc$1 = "ê";
  var Egrave$1 = "È";
  var egrave$1 = "è";
  var ETH$1 = "Ð";
  var eth$1 = "ð";
  var Euml$1 = "Ë";
  var euml$1 = "ë";
  var frac12$1 = "½";
  var frac14$1 = "¼";
  var frac34$1 = "¾";
  var gt$1 = ">";
  var GT$1 = ">";
  var Iacute$1 = "Í";
  var iacute$1 = "í";
  var Icirc$1 = "Î";
  var icirc$1 = "î";
  var iexcl$1 = "¡";
  var Igrave$1 = "Ì";
  var igrave$1 = "ì";
  var iquest$1 = "¿";
  var Iuml$1 = "Ï";
  var iuml$1 = "ï";
  var laquo$1 = "«";
  var lt$1 = "<";
  var LT$1 = "<";
  var macr$1 = "¯";
  var micro$1 = "µ";
  var middot$1 = "·";
  var nbsp$1 = " ";
  var not$1 = "¬";
  var Ntilde$1 = "Ñ";
  var ntilde$1 = "ñ";
  var Oacute$1 = "Ó";
  var oacute$1 = "ó";
  var Ocirc$1 = "Ô";
  var ocirc$1 = "ô";
  var Ograve$1 = "Ò";
  var ograve$1 = "ò";
  var ordf$1 = "ª";
  var ordm$1 = "º";
  var Oslash$1 = "Ø";
  var oslash$1 = "ø";
  var Otilde$1 = "Õ";
  var otilde$1 = "õ";
  var Ouml$1 = "Ö";
  var ouml$1 = "ö";
  var para$1 = "¶";
  var plusmn$1 = "±";
  var pound$1 = "£";
  var quot$1 = "\"";
  var QUOT$1 = "\"";
  var raquo$1 = "»";
  var reg$1 = "®";
  var REG$1 = "®";
  var sect$1 = "§";
  var shy$1 = "­";
  var sup1$1 = "¹";
  var sup2$1 = "²";
  var sup3$1 = "³";
  var szlig$1 = "ß";
  var THORN$1 = "Þ";
  var thorn$1 = "þ";
  var times$1 = "×";
  var Uacute$1 = "Ú";
  var uacute$1 = "ú";
  var Ucirc$1 = "Û";
  var ucirc$1 = "û";
  var Ugrave$1 = "Ù";
  var ugrave$1 = "ù";
  var uml$1 = "¨";
  var Uuml$1 = "Ü";
  var uuml$1 = "ü";
  var Yacute$1 = "Ý";
  var yacute$1 = "ý";
  var yen$1 = "¥";
  var yuml$1 = "ÿ";
  var legacy = {
  	Aacute: Aacute$1,
  	aacute: aacute$1,
  	Acirc: Acirc$1,
  	acirc: acirc$1,
  	acute: acute$1,
  	AElig: AElig$1,
  	aelig: aelig$1,
  	Agrave: Agrave$1,
  	agrave: agrave$1,
  	amp: amp$1,
  	AMP: AMP$1,
  	Aring: Aring$1,
  	aring: aring$1,
  	Atilde: Atilde$1,
  	atilde: atilde$1,
  	Auml: Auml$1,
  	auml: auml$1,
  	brvbar: brvbar$1,
  	Ccedil: Ccedil$1,
  	ccedil: ccedil$1,
  	cedil: cedil$1,
  	cent: cent$1,
  	copy: copy$1,
  	COPY: COPY$1,
  	curren: curren$1,
  	deg: deg$1,
  	divide: divide$1,
  	Eacute: Eacute$1,
  	eacute: eacute$1,
  	Ecirc: Ecirc$1,
  	ecirc: ecirc$1,
  	Egrave: Egrave$1,
  	egrave: egrave$1,
  	ETH: ETH$1,
  	eth: eth$1,
  	Euml: Euml$1,
  	euml: euml$1,
  	frac12: frac12$1,
  	frac14: frac14$1,
  	frac34: frac34$1,
  	gt: gt$1,
  	GT: GT$1,
  	Iacute: Iacute$1,
  	iacute: iacute$1,
  	Icirc: Icirc$1,
  	icirc: icirc$1,
  	iexcl: iexcl$1,
  	Igrave: Igrave$1,
  	igrave: igrave$1,
  	iquest: iquest$1,
  	Iuml: Iuml$1,
  	iuml: iuml$1,
  	laquo: laquo$1,
  	lt: lt$1,
  	LT: LT$1,
  	macr: macr$1,
  	micro: micro$1,
  	middot: middot$1,
  	nbsp: nbsp$1,
  	not: not$1,
  	Ntilde: Ntilde$1,
  	ntilde: ntilde$1,
  	Oacute: Oacute$1,
  	oacute: oacute$1,
  	Ocirc: Ocirc$1,
  	ocirc: ocirc$1,
  	Ograve: Ograve$1,
  	ograve: ograve$1,
  	ordf: ordf$1,
  	ordm: ordm$1,
  	Oslash: Oslash$1,
  	oslash: oslash$1,
  	Otilde: Otilde$1,
  	otilde: otilde$1,
  	Ouml: Ouml$1,
  	ouml: ouml$1,
  	para: para$1,
  	plusmn: plusmn$1,
  	pound: pound$1,
  	quot: quot$1,
  	QUOT: QUOT$1,
  	raquo: raquo$1,
  	reg: reg$1,
  	REG: REG$1,
  	sect: sect$1,
  	shy: shy$1,
  	sup1: sup1$1,
  	sup2: sup2$1,
  	sup3: sup3$1,
  	szlig: szlig$1,
  	THORN: THORN$1,
  	thorn: thorn$1,
  	times: times$1,
  	Uacute: Uacute$1,
  	uacute: uacute$1,
  	Ucirc: Ucirc$1,
  	ucirc: ucirc$1,
  	Ugrave: Ugrave$1,
  	ugrave: ugrave$1,
  	uml: uml$1,
  	Uuml: Uuml$1,
  	uuml: uuml$1,
  	Yacute: Yacute$1,
  	yacute: yacute$1,
  	yen: yen$1,
  	yuml: yuml$1
  };

  var legacy$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    Aacute: Aacute$1,
    aacute: aacute$1,
    Acirc: Acirc$1,
    acirc: acirc$1,
    acute: acute$1,
    AElig: AElig$1,
    aelig: aelig$1,
    Agrave: Agrave$1,
    agrave: agrave$1,
    amp: amp$1,
    AMP: AMP$1,
    Aring: Aring$1,
    aring: aring$1,
    Atilde: Atilde$1,
    atilde: atilde$1,
    Auml: Auml$1,
    auml: auml$1,
    brvbar: brvbar$1,
    Ccedil: Ccedil$1,
    ccedil: ccedil$1,
    cedil: cedil$1,
    cent: cent$1,
    copy: copy$1,
    COPY: COPY$1,
    curren: curren$1,
    deg: deg$1,
    divide: divide$1,
    Eacute: Eacute$1,
    eacute: eacute$1,
    Ecirc: Ecirc$1,
    ecirc: ecirc$1,
    Egrave: Egrave$1,
    egrave: egrave$1,
    ETH: ETH$1,
    eth: eth$1,
    Euml: Euml$1,
    euml: euml$1,
    frac12: frac12$1,
    frac14: frac14$1,
    frac34: frac34$1,
    gt: gt$1,
    GT: GT$1,
    Iacute: Iacute$1,
    iacute: iacute$1,
    Icirc: Icirc$1,
    icirc: icirc$1,
    iexcl: iexcl$1,
    Igrave: Igrave$1,
    igrave: igrave$1,
    iquest: iquest$1,
    Iuml: Iuml$1,
    iuml: iuml$1,
    laquo: laquo$1,
    lt: lt$1,
    LT: LT$1,
    macr: macr$1,
    micro: micro$1,
    middot: middot$1,
    nbsp: nbsp$1,
    not: not$1,
    Ntilde: Ntilde$1,
    ntilde: ntilde$1,
    Oacute: Oacute$1,
    oacute: oacute$1,
    Ocirc: Ocirc$1,
    ocirc: ocirc$1,
    Ograve: Ograve$1,
    ograve: ograve$1,
    ordf: ordf$1,
    ordm: ordm$1,
    Oslash: Oslash$1,
    oslash: oslash$1,
    Otilde: Otilde$1,
    otilde: otilde$1,
    Ouml: Ouml$1,
    ouml: ouml$1,
    para: para$1,
    plusmn: plusmn$1,
    pound: pound$1,
    quot: quot$1,
    QUOT: QUOT$1,
    raquo: raquo$1,
    reg: reg$1,
    REG: REG$1,
    sect: sect$1,
    shy: shy$1,
    sup1: sup1$1,
    sup2: sup2$1,
    sup3: sup3$1,
    szlig: szlig$1,
    THORN: THORN$1,
    thorn: thorn$1,
    times: times$1,
    Uacute: Uacute$1,
    uacute: uacute$1,
    Ucirc: Ucirc$1,
    ucirc: ucirc$1,
    Ugrave: Ugrave$1,
    ugrave: ugrave$1,
    uml: uml$1,
    Uuml: Uuml$1,
    uuml: uuml$1,
    Yacute: Yacute$1,
    yacute: yacute$1,
    yen: yen$1,
    yuml: yuml$1,
    'default': legacy
  });

  var amp$2 = "&";
  var apos$1 = "'";
  var gt$2 = ">";
  var lt$2 = "<";
  var quot$2 = "\"";
  var xml = {
  	amp: amp$2,
  	apos: apos$1,
  	gt: gt$2,
  	lt: lt$2,
  	quot: quot$2
  };

  var xml$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    amp: amp$2,
    apos: apos$1,
    gt: gt$2,
    lt: lt$2,
    quot: quot$2,
    'default': xml
  });

  var decode = {
  	"0": 65533,
  	"128": 8364,
  	"130": 8218,
  	"131": 402,
  	"132": 8222,
  	"133": 8230,
  	"134": 8224,
  	"135": 8225,
  	"136": 710,
  	"137": 8240,
  	"138": 352,
  	"139": 8249,
  	"140": 338,
  	"142": 381,
  	"145": 8216,
  	"146": 8217,
  	"147": 8220,
  	"148": 8221,
  	"149": 8226,
  	"150": 8211,
  	"151": 8212,
  	"152": 732,
  	"153": 8482,
  	"154": 353,
  	"155": 8250,
  	"156": 339,
  	"158": 382,
  	"159": 376
  };

  var decode$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': decode
  });

  var require$$0 = getCjsExportFromNamespace(decode$1);

  var decode_codepoint = createCommonjsModule(function (module, exports) {
  var __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
      return (mod && mod.__esModule) ? mod : { "default": mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var decode_json_1 = __importDefault(require$$0);
  // modified version of https://github.com/mathiasbynens/he/blob/master/src/he.js#L94-L119
  function decodeCodePoint(codePoint) {
      if ((codePoint >= 0xd800 && codePoint <= 0xdfff) || codePoint > 0x10ffff) {
          return "\uFFFD";
      }
      if (codePoint in decode_json_1.default) {
          // @ts-ignore
          codePoint = decode_json_1.default[codePoint];
      }
      var output = "";
      if (codePoint > 0xffff) {
          codePoint -= 0x10000;
          output += String.fromCharCode(((codePoint >>> 10) & 0x3ff) | 0xd800);
          codePoint = 0xdc00 | (codePoint & 0x3ff);
      }
      output += String.fromCharCode(codePoint);
      return output;
  }
  exports.default = decodeCodePoint;
  });

  unwrapExports(decode_codepoint);

  var require$$1 = getCjsExportFromNamespace(entities$1);

  var require$$1$1 = getCjsExportFromNamespace(legacy$1);

  var require$$0$1 = getCjsExportFromNamespace(xml$1);

  var decode$2 = createCommonjsModule(function (module, exports) {
  var __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
      return (mod && mod.__esModule) ? mod : { "default": mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var entities_json_1 = __importDefault(require$$1);
  var legacy_json_1 = __importDefault(require$$1$1);
  var xml_json_1 = __importDefault(require$$0$1);
  var decode_codepoint_1 = __importDefault(decode_codepoint);
  exports.decodeXML = getStrictDecoder(xml_json_1.default);
  exports.decodeHTMLStrict = getStrictDecoder(entities_json_1.default);
  function getStrictDecoder(map) {
      var keys = Object.keys(map).join("|");
      var replace = getReplacer(map);
      keys += "|#[xX][\\da-fA-F]+|#\\d+";
      var re = new RegExp("&(?:" + keys + ");", "g");
      return function (str) { return String(str).replace(re, replace); };
  }
  var sorter = function (a, b) { return (a < b ? 1 : -1); };
  exports.decodeHTML = (function () {
      var legacy = Object.keys(legacy_json_1.default).sort(sorter);
      var keys = Object.keys(entities_json_1.default).sort(sorter);
      for (var i = 0, j = 0; i < keys.length; i++) {
          if (legacy[j] === keys[i]) {
              keys[i] += ";?";
              j++;
          }
          else {
              keys[i] += ";";
          }
      }
      var re = new RegExp("&(?:" + keys.join("|") + "|#[xX][\\da-fA-F]+;?|#\\d+;?)", "g");
      var replace = getReplacer(entities_json_1.default);
      function replacer(str) {
          if (str.substr(-1) !== ";")
              str += ";";
          return replace(str);
      }
      //TODO consider creating a merged map
      return function (str) {
          return String(str).replace(re, replacer);
      };
  })();
  function getReplacer(map) {
      return function replace(str) {
          if (str.charAt(1) === "#") {
              if (str.charAt(2) === "X" || str.charAt(2) === "x") {
                  return decode_codepoint_1.default(parseInt(str.substr(3), 16));
              }
              return decode_codepoint_1.default(parseInt(str.substr(2), 10));
          }
          return map[str.slice(1, -1)];
      };
  }
  });

  unwrapExports(decode$2);
  var decode_1 = decode$2.decodeXML;
  var decode_2 = decode$2.decodeHTMLStrict;
  var decode_3 = decode$2.decodeHTML;

  var encode = createCommonjsModule(function (module, exports) {
  var __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
      return (mod && mod.__esModule) ? mod : { "default": mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var xml_json_1 = __importDefault(require$$0$1);
  var inverseXML = getInverseObj(xml_json_1.default);
  var xmlReplacer = getInverseReplacer(inverseXML);
  exports.encodeXML = getInverse(inverseXML, xmlReplacer);
  var entities_json_1 = __importDefault(require$$1);
  var inverseHTML = getInverseObj(entities_json_1.default);
  var htmlReplacer = getInverseReplacer(inverseHTML);
  exports.encodeHTML = getInverse(inverseHTML, htmlReplacer);
  function getInverseObj(obj) {
      return Object.keys(obj)
          .sort()
          .reduce(function (inverse, name) {
          inverse[obj[name]] = "&" + name + ";";
          return inverse;
      }, {});
  }
  function getInverseReplacer(inverse) {
      var single = [];
      var multiple = [];
      Object.keys(inverse).forEach(function (k) {
          return k.length === 1
              ? // Add value to single array
                  single.push("\\" + k)
              : // Add value to multiple array
                  multiple.push(k);
      });
      //TODO add ranges
      multiple.unshift("[" + single.join("") + "]");
      return new RegExp(multiple.join("|"), "g");
  }
  var reNonASCII = /[^\0-\x7F]/g;
  var reAstralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
  function singleCharReplacer(c) {
      return "&#x" + c
          .charCodeAt(0)
          .toString(16)
          .toUpperCase() + ";";
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any
  function astralReplacer(c, _) {
      // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
      var high = c.charCodeAt(0);
      var low = c.charCodeAt(1);
      var codePoint = (high - 0xd800) * 0x400 + low - 0xdc00 + 0x10000;
      return "&#x" + codePoint.toString(16).toUpperCase() + ";";
  }
  function getInverse(inverse, re) {
      return function (data) {
          return data
              .replace(re, function (name) { return inverse[name]; })
              .replace(reAstralSymbols, astralReplacer)
              .replace(reNonASCII, singleCharReplacer);
      };
  }
  var reXmlChars = getInverseReplacer(inverseXML);
  function escape(data) {
      return data
          .replace(reXmlChars, singleCharReplacer)
          .replace(reAstralSymbols, astralReplacer)
          .replace(reNonASCII, singleCharReplacer);
  }
  exports.escape = escape;
  });

  unwrapExports(encode);
  var encode_1 = encode.encodeXML;
  var encode_2 = encode.encodeHTML;
  var encode_3 = encode.escape;

  var lib$1 = createCommonjsModule(function (module, exports) {
  Object.defineProperty(exports, "__esModule", { value: true });


  function decode(data, level) {
      return (!level || level <= 0 ? decode$2.decodeXML : decode$2.decodeHTML)(data);
  }
  exports.decode = decode;
  function decodeStrict(data, level) {
      return (!level || level <= 0 ? decode$2.decodeXML : decode$2.decodeHTMLStrict)(data);
  }
  exports.decodeStrict = decodeStrict;
  function encode$1(data, level) {
      return (!level || level <= 0 ? encode.encodeXML : encode.encodeHTML)(data);
  }
  exports.encode = encode$1;
  var encode_2 = encode;
  exports.encodeXML = encode_2.encodeXML;
  exports.encodeHTML = encode_2.encodeHTML;
  exports.escape = encode_2.escape;
  // Legacy aliases
  exports.encodeHTML4 = encode_2.encodeHTML;
  exports.encodeHTML5 = encode_2.encodeHTML;
  var decode_2 = decode$2;
  exports.decodeXML = decode_2.decodeXML;
  exports.decodeHTML = decode_2.decodeHTML;
  exports.decodeHTMLStrict = decode_2.decodeHTMLStrict;
  // Legacy aliases
  exports.decodeHTML4 = decode_2.decodeHTML;
  exports.decodeHTML5 = decode_2.decodeHTML;
  exports.decodeHTML4Strict = decode_2.decodeHTMLStrict;
  exports.decodeHTML5Strict = decode_2.decodeHTMLStrict;
  exports.decodeXMLStrict = decode_2.decodeXML;
  });

  unwrapExports(lib$1);
  var lib_1$1 = lib$1.decode;
  var lib_2$1 = lib$1.decodeStrict;
  var lib_3$1 = lib$1.encode;
  var lib_4$1 = lib$1.encodeXML;
  var lib_5$1 = lib$1.encodeHTML;
  var lib_6$1 = lib$1.escape;
  var lib_7$1 = lib$1.encodeHTML4;
  var lib_8$1 = lib$1.encodeHTML5;
  var lib_9$1 = lib$1.decodeXML;
  var lib_10 = lib$1.decodeHTML;
  var lib_11 = lib$1.decodeHTMLStrict;
  var lib_12 = lib$1.decodeHTML4;
  var lib_13 = lib$1.decodeHTML5;
  var lib_14 = lib$1.decodeHTML4Strict;
  var lib_15 = lib$1.decodeHTML5Strict;
  var lib_16 = lib$1.decodeXMLStrict;

  var elementNames = {
  	altglyph: "altGlyph",
  	altglyphdef: "altGlyphDef",
  	altglyphitem: "altGlyphItem",
  	animatecolor: "animateColor",
  	animatemotion: "animateMotion",
  	animatetransform: "animateTransform",
  	clippath: "clipPath",
  	feblend: "feBlend",
  	fecolormatrix: "feColorMatrix",
  	fecomponenttransfer: "feComponentTransfer",
  	fecomposite: "feComposite",
  	feconvolvematrix: "feConvolveMatrix",
  	fediffuselighting: "feDiffuseLighting",
  	fedisplacementmap: "feDisplacementMap",
  	fedistantlight: "feDistantLight",
  	fedropshadow: "feDropShadow",
  	feflood: "feFlood",
  	fefunca: "feFuncA",
  	fefuncb: "feFuncB",
  	fefuncg: "feFuncG",
  	fefuncr: "feFuncR",
  	fegaussianblur: "feGaussianBlur",
  	feimage: "feImage",
  	femerge: "feMerge",
  	femergenode: "feMergeNode",
  	femorphology: "feMorphology",
  	feoffset: "feOffset",
  	fepointlight: "fePointLight",
  	fespecularlighting: "feSpecularLighting",
  	fespotlight: "feSpotLight",
  	fetile: "feTile",
  	feturbulence: "feTurbulence",
  	foreignobject: "foreignObject",
  	glyphref: "glyphRef",
  	lineargradient: "linearGradient",
  	radialgradient: "radialGradient",
  	textpath: "textPath"
  };
  var attributeNames = {
  	definitionurl: "definitionURL",
  	attributename: "attributeName",
  	attributetype: "attributeType",
  	basefrequency: "baseFrequency",
  	baseprofile: "baseProfile",
  	calcmode: "calcMode",
  	clippathunits: "clipPathUnits",
  	diffuseconstant: "diffuseConstant",
  	edgemode: "edgeMode",
  	filterunits: "filterUnits",
  	glyphref: "glyphRef",
  	gradienttransform: "gradientTransform",
  	gradientunits: "gradientUnits",
  	kernelmatrix: "kernelMatrix",
  	kernelunitlength: "kernelUnitLength",
  	keypoints: "keyPoints",
  	keysplines: "keySplines",
  	keytimes: "keyTimes",
  	lengthadjust: "lengthAdjust",
  	limitingconeangle: "limitingConeAngle",
  	markerheight: "markerHeight",
  	markerunits: "markerUnits",
  	markerwidth: "markerWidth",
  	maskcontentunits: "maskContentUnits",
  	maskunits: "maskUnits",
  	numoctaves: "numOctaves",
  	pathlength: "pathLength",
  	patterncontentunits: "patternContentUnits",
  	patterntransform: "patternTransform",
  	patternunits: "patternUnits",
  	pointsatx: "pointsAtX",
  	pointsaty: "pointsAtY",
  	pointsatz: "pointsAtZ",
  	preservealpha: "preserveAlpha",
  	preserveaspectratio: "preserveAspectRatio",
  	primitiveunits: "primitiveUnits",
  	refx: "refX",
  	refy: "refY",
  	repeatcount: "repeatCount",
  	repeatdur: "repeatDur",
  	requiredextensions: "requiredExtensions",
  	requiredfeatures: "requiredFeatures",
  	specularconstant: "specularConstant",
  	specularexponent: "specularExponent",
  	spreadmethod: "spreadMethod",
  	startoffset: "startOffset",
  	stddeviation: "stdDeviation",
  	stitchtiles: "stitchTiles",
  	surfacescale: "surfaceScale",
  	systemlanguage: "systemLanguage",
  	tablevalues: "tableValues",
  	targetx: "targetX",
  	targety: "targetY",
  	textlength: "textLength",
  	viewbox: "viewBox",
  	viewtarget: "viewTarget",
  	xchannelselector: "xChannelSelector",
  	ychannelselector: "yChannelSelector",
  	zoomandpan: "zoomAndPan"
  };
  var foreignNames = {
  	elementNames: elementNames,
  	attributeNames: attributeNames
  };

  var foreignNames$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    elementNames: elementNames,
    attributeNames: attributeNames,
    'default': foreignNames
  });

  var foreignNames$2 = getCjsExportFromNamespace(foreignNames$1);

  var domSerializer = createCommonjsModule(function (module) {
  /*
    Module dependencies
  */



  /* mixed-case SVG and MathML tags & attributes
     recognized by the HTML parser, see
     https://html.spec.whatwg.org/multipage/parsing.html#parsing-main-inforeign
  */

  foreignNames$2.elementNames.__proto__ = null; /* use as a simple dictionary */
  foreignNames$2.attributeNames.__proto__ = null;

  var unencodedElements = {
    __proto__: null,
    style: true,
    script: true,
    xmp: true,
    iframe: true,
    noembed: true,
    noframes: true,
    plaintext: true,
    noscript: true
  };

  /*
    Format attributes
  */
  function formatAttrs(attributes, opts) {
    if (!attributes) return;

    var output = '';
    var value;

    // Loop through the attributes
    for (var key in attributes) {
      value = attributes[key];
      if (output) {
        output += ' ';
      }

      if (opts.xmlMode === 'foreign') {
        /* fix up mixed-case attribute names */
        key = foreignNames$2.attributeNames[key] || key;
      }
      output += key;
      if ((value !== null && value !== '') || opts.xmlMode) {
        output +=
          '="' +
          (opts.decodeEntities
            ? lib$1.encodeXML(value)
            : value.replace(/\"/g, '&quot;')) +
          '"';
      }
    }

    return output;
  }

  /*
    Self-enclosing tags (stolen from node-htmlparser)
  */
  var singleTag = {
    __proto__: null,
    area: true,
    base: true,
    basefont: true,
    br: true,
    col: true,
    command: true,
    embed: true,
    frame: true,
    hr: true,
    img: true,
    input: true,
    isindex: true,
    keygen: true,
    link: true,
    meta: true,
    param: true,
    source: true,
    track: true,
    wbr: true
  };

  var render = (module.exports = function(dom, opts) {
    if (!Array.isArray(dom) && !dom.cheerio) dom = [dom];
    opts = opts || {};

    var output = '';

    for (var i = 0; i < dom.length; i++) {
      var elem = dom[i];

      if (elem.type === 'root') output += render(elem.children, opts);
      else if (lib.isTag(elem)) output += renderTag(elem, opts);
      else if (elem.type === lib.Directive)
        output += renderDirective(elem);
      else if (elem.type === lib.Comment) output += renderComment(elem);
      else if (elem.type === lib.CDATA) output += renderCdata(elem);
      else output += renderText(elem, opts);
    }

    return output;
  });

  var foreignModeIntegrationPoints = [
    'mi',
    'mo',
    'mn',
    'ms',
    'mtext',
    'annotation-xml',
    'foreignObject',
    'desc',
    'title'
  ];

  function renderTag(elem, opts) {
    // Handle SVG / MathML in HTML
    if (opts.xmlMode === 'foreign') {
      /* fix up mixed-case element names */
      elem.name = foreignNames$2.elementNames[elem.name] || elem.name;
      /* exit foreign mode at integration points */
      if (
        elem.parent &&
        foreignModeIntegrationPoints.indexOf(elem.parent.name) >= 0
      )
        opts = Object.assign({}, opts, { xmlMode: false });
    }
    if (!opts.xmlMode && ['svg', 'math'].indexOf(elem.name) >= 0) {
      opts = Object.assign({}, opts, { xmlMode: 'foreign' });
    }

    var tag = '<' + elem.name;
    var attribs = formatAttrs(elem.attribs, opts);

    if (attribs) {
      tag += ' ' + attribs;
    }

    if (opts.xmlMode && (!elem.children || elem.children.length === 0)) {
      tag += '/>';
    } else {
      tag += '>';
      if (elem.children) {
        tag += render(elem.children, opts);
      }

      if (!singleTag[elem.name] || opts.xmlMode) {
        tag += '</' + elem.name + '>';
      }
    }

    return tag;
  }

  function renderDirective(elem) {
    return '<' + elem.data + '>';
  }

  function renderText(elem, opts) {
    var data = elem.data || '';

    // if entities weren't decoded, no need to encode them back
    if (
      opts.decodeEntities &&
      !(elem.parent && elem.parent.name in unencodedElements)
    ) {
      data = lib$1.encodeXML(data);
    }

    return data;
  }

  function renderCdata(elem) {
    return '<![CDATA[' + elem.children[0].data + ']]>';
  }

  function renderComment(elem) {
    return '<!--' + elem.data + '-->';
  }
  });

  var isTag = domelementtype.isTag;

  var stringify = {
  	getInnerHTML: getInnerHTML,
  	getOuterHTML: domSerializer,
  	getText: getText
  };

  function getInnerHTML(elem, opts){
  	return elem.children ? elem.children.map(function(elem){
  		return domSerializer(elem, opts);
  	}).join("") : "";
  }

  function getText(elem){
  	if(Array.isArray(elem)) return elem.map(getText).join("");
  	if(isTag(elem)) return elem.name === "br" ? "\n" : getText(elem.children);
  	if(elem.type === domelementtype.CDATA) return getText(elem.children);
  	if(elem.type === domelementtype.Text) return elem.data;
  	return "";
  }

  var traversal = createCommonjsModule(function (module, exports) {
  var getChildren = exports.getChildren = function(elem){
  	return elem.children;
  };

  var getParent = exports.getParent = function(elem){
  	return elem.parent;
  };

  exports.getSiblings = function(elem){
  	var parent = getParent(elem);
  	return parent ? getChildren(parent) : [elem];
  };

  exports.getAttributeValue = function(elem, name){
  	return elem.attribs && elem.attribs[name];
  };

  exports.hasAttrib = function(elem, name){
  	return !!elem.attribs && hasOwnProperty.call(elem.attribs, name);
  };

  exports.getName = function(elem){
  	return elem.name;
  };
  });
  var traversal_1 = traversal.getChildren;
  var traversal_2 = traversal.getParent;
  var traversal_3 = traversal.getSiblings;
  var traversal_4 = traversal.getAttributeValue;
  var traversal_5 = traversal.hasAttrib;
  var traversal_6 = traversal.getName;

  var removeElement = function(elem){
  	if(elem.prev) elem.prev.next = elem.next;
  	if(elem.next) elem.next.prev = elem.prev;

  	if(elem.parent){
  		var childs = elem.parent.children;
  		childs.splice(childs.lastIndexOf(elem), 1);
  	}
  };

  var replaceElement = function(elem, replacement){
  	var prev = replacement.prev = elem.prev;
  	if(prev){
  		prev.next = replacement;
  	}

  	var next = replacement.next = elem.next;
  	if(next){
  		next.prev = replacement;
  	}

  	var parent = replacement.parent = elem.parent;
  	if(parent){
  		var childs = parent.children;
  		childs[childs.lastIndexOf(elem)] = replacement;
  	}
  };

  var appendChild = function(elem, child){
  	child.parent = elem;

  	if(elem.children.push(child) !== 1){
  		var sibling = elem.children[elem.children.length - 2];
  		sibling.next = child;
  		child.prev = sibling;
  		child.next = null;
  	}
  };

  var append = function(elem, next){
  	var parent = elem.parent,
  		currNext = elem.next;

  	next.next = currNext;
  	next.prev = elem;
  	elem.next = next;
  	next.parent = parent;

  	if(currNext){
  		currNext.prev = next;
  		if(parent){
  			var childs = parent.children;
  			childs.splice(childs.lastIndexOf(currNext), 0, next);
  		}
  	} else if(parent){
  		parent.children.push(next);
  	}
  };

  var prepend = function(elem, prev){
  	var parent = elem.parent;
  	if(parent){
  		var childs = parent.children;
  		childs.splice(childs.lastIndexOf(elem), 0, prev);
  	}

  	if(elem.prev){
  		elem.prev.next = prev;
  	}
  	
  	prev.parent = parent;
  	prev.prev = elem.prev;
  	prev.next = elem;
  	elem.prev = prev;
  };

  var manipulation = {
  	removeElement: removeElement,
  	replaceElement: replaceElement,
  	appendChild: appendChild,
  	append: append,
  	prepend: prepend
  };

  var isTag$1 = domelementtype.isTag;

  var querying = {
  	filter: filter,
  	find: find,
  	findOneChild: findOneChild,
  	findOne: findOne,
  	existsOne: existsOne,
  	findAll: findAll
  };

  function filter(test, element, recurse, limit){
  	if(!Array.isArray(element)) element = [element];

  	if(typeof limit !== "number" || !isFinite(limit)){
  		limit = Infinity;
  	}
  	return find(test, element, recurse !== false, limit);
  }

  function find(test, elems, recurse, limit){
  	var result = [], childs;

  	for(var i = 0, j = elems.length; i < j; i++){
  		if(test(elems[i])){
  			result.push(elems[i]);
  			if(--limit <= 0) break;
  		}

  		childs = elems[i].children;
  		if(recurse && childs && childs.length > 0){
  			childs = find(test, childs, recurse, limit);
  			result = result.concat(childs);
  			limit -= childs.length;
  			if(limit <= 0) break;
  		}
  	}

  	return result;
  }

  function findOneChild(test, elems){
  	for(var i = 0, l = elems.length; i < l; i++){
  		if(test(elems[i])) return elems[i];
  	}

  	return null;
  }

  function findOne(test, elems){
  	var elem = null;

  	for(var i = 0, l = elems.length; i < l && !elem; i++){
  		if(!isTag$1(elems[i])){
  			continue;
  		} else if(test(elems[i])){
  			elem = elems[i];
  		} else if(elems[i].children.length > 0){
  			elem = findOne(test, elems[i].children);
  		}
  	}

  	return elem;
  }

  function existsOne(test, elems){
  	for(var i = 0, l = elems.length; i < l; i++){
  		if(
  			isTag$1(elems[i]) && (
  				test(elems[i]) || (
  					elems[i].children.length > 0 &&
  					existsOne(test, elems[i].children)
  				)
  			)
  		){
  			return true;
  		}
  	}

  	return false;
  }

  function findAll(test, rootElems){
  	var result = [];
  	var stack = rootElems.slice();
  	while(stack.length){
  		var elem = stack.shift();
  		if(!isTag$1(elem)) continue;
  		if (elem.children && elem.children.length > 0) {
  			stack.unshift.apply(stack, elem.children);
  		}
  		if(test(elem)) result.push(elem);
  	}
  	return result;
  }

  var legacy$2 = createCommonjsModule(function (module, exports) {
  var isTag = exports.isTag = domelementtype.isTag;

  exports.testElement = function(options, element){
  	for(var key in options){
  		if(!options.hasOwnProperty(key));
  		else if(key === "tag_name"){
  			if(!isTag(element) || !options.tag_name(element.name)){
  				return false;
  			}
  		} else if(key === "tag_type"){
  			if(!options.tag_type(element.type)) return false;
  		} else if(key === "tag_contains"){
  			if(isTag(element) || !options.tag_contains(element.data)){
  				return false;
  			}
  		} else if(!element.attribs || !options[key](element.attribs[key])){
  			return false;
  		}
  	}
  	return true;
  };

  var Checks = {
  	tag_name: function(name){
  		if(typeof name === "function"){
  			return function(elem){ return isTag(elem) && name(elem.name); };
  		} else if(name === "*"){
  			return isTag;
  		} else {
  			return function(elem){ return isTag(elem) && elem.name === name; };
  		}
  	},
  	tag_type: function(type){
  		if(typeof type === "function"){
  			return function(elem){ return type(elem.type); };
  		} else {
  			return function(elem){ return elem.type === type; };
  		}
  	},
  	tag_contains: function(data){
  		if(typeof data === "function"){
  			return function(elem){ return !isTag(elem) && data(elem.data); };
  		} else {
  			return function(elem){ return !isTag(elem) && elem.data === data; };
  		}
  	}
  };

  function getAttribCheck(attrib, value){
  	if(typeof value === "function"){
  		return function(elem){ return elem.attribs && value(elem.attribs[attrib]); };
  	} else {
  		return function(elem){ return elem.attribs && elem.attribs[attrib] === value; };
  	}
  }

  function combineFuncs(a, b){
  	return function(elem){
  		return a(elem) || b(elem);
  	};
  }

  exports.getElements = function(options, element, recurse, limit){
  	var funcs = Object.keys(options).map(function(key){
  		var value = options[key];
  		return key in Checks ? Checks[key](value) : getAttribCheck(key, value);
  	});

  	return funcs.length === 0 ? [] : this.filter(
  		funcs.reduce(combineFuncs),
  		element, recurse, limit
  	);
  };

  exports.getElementById = function(id, element, recurse){
  	if(!Array.isArray(element)) element = [element];
  	return this.findOne(getAttribCheck("id", id), element, recurse !== false);
  };

  exports.getElementsByTagName = function(name, element, recurse, limit){
  	return this.filter(Checks.tag_name(name), element, recurse, limit);
  };

  exports.getElementsByTagType = function(type, element, recurse, limit){
  	return this.filter(Checks.tag_type(type), element, recurse, limit);
  };
  });
  var legacy_1 = legacy$2.isTag;
  var legacy_2 = legacy$2.testElement;
  var legacy_3 = legacy$2.getElements;
  var legacy_4 = legacy$2.getElementById;
  var legacy_5 = legacy$2.getElementsByTagName;
  var legacy_6 = legacy$2.getElementsByTagType;

  var helpers = createCommonjsModule(function (module, exports) {
  // removeSubsets
  // Given an array of nodes, remove any member that is contained by another.
  exports.removeSubsets = function(nodes) {
  	var idx = nodes.length, node, ancestor, replace;

  	// Check if each node (or one of its ancestors) is already contained in the
  	// array.
  	while (--idx > -1) {
  		node = ancestor = nodes[idx];

  		// Temporarily remove the node under consideration
  		nodes[idx] = null;
  		replace = true;

  		while (ancestor) {
  			if (nodes.indexOf(ancestor) > -1) {
  				replace = false;
  				nodes.splice(idx, 1);
  				break;
  			}
  			ancestor = ancestor.parent;
  		}

  		// If the node has been found to be unique, re-insert it.
  		if (replace) {
  			nodes[idx] = node;
  		}
  	}

  	return nodes;
  };

  // Source: http://dom.spec.whatwg.org/#dom-node-comparedocumentposition
  var POSITION = {
  	DISCONNECTED: 1,
  	PRECEDING: 2,
  	FOLLOWING: 4,
  	CONTAINS: 8,
  	CONTAINED_BY: 16
  };

  // Compare the position of one node against another node in any other document.
  // The return value is a bitmask with the following values:
  //
  // document order:
  // > There is an ordering, document order, defined on all the nodes in the
  // > document corresponding to the order in which the first character of the
  // > XML representation of each node occurs in the XML representation of the
  // > document after expansion of general entities. Thus, the document element
  // > node will be the first node. Element nodes occur before their children.
  // > Thus, document order orders element nodes in order of the occurrence of
  // > their start-tag in the XML (after expansion of entities). The attribute
  // > nodes of an element occur after the element and before its children. The
  // > relative order of attribute nodes is implementation-dependent./
  // Source:
  // http://www.w3.org/TR/DOM-Level-3-Core/glossary.html#dt-document-order
  //
  // @argument {Node} nodaA The first node to use in the comparison
  // @argument {Node} nodeB The second node to use in the comparison
  //
  // @return {Number} A bitmask describing the input nodes' relative position.
  //         See http://dom.spec.whatwg.org/#dom-node-comparedocumentposition for
  //         a description of these values.
  var comparePos = exports.compareDocumentPosition = function(nodeA, nodeB) {
  	var aParents = [];
  	var bParents = [];
  	var current, sharedParent, siblings, aSibling, bSibling, idx;

  	if (nodeA === nodeB) {
  		return 0;
  	}

  	current = nodeA;
  	while (current) {
  		aParents.unshift(current);
  		current = current.parent;
  	}
  	current = nodeB;
  	while (current) {
  		bParents.unshift(current);
  		current = current.parent;
  	}

  	idx = 0;
  	while (aParents[idx] === bParents[idx]) {
  		idx++;
  	}

  	if (idx === 0) {
  		return POSITION.DISCONNECTED;
  	}

  	sharedParent = aParents[idx - 1];
  	siblings = sharedParent.children;
  	aSibling = aParents[idx];
  	bSibling = bParents[idx];

  	if (siblings.indexOf(aSibling) > siblings.indexOf(bSibling)) {
  		if (sharedParent === nodeB) {
  			return POSITION.FOLLOWING | POSITION.CONTAINED_BY;
  		}
  		return POSITION.FOLLOWING;
  	} else {
  		if (sharedParent === nodeA) {
  			return POSITION.PRECEDING | POSITION.CONTAINS;
  		}
  		return POSITION.PRECEDING;
  	}
  };

  // Sort an array of nodes based on their relative position in the document and
  // remove any duplicate nodes. If the array contains nodes that do not belong
  // to the same document, sort order is unspecified.
  //
  // @argument {Array} nodes Array of DOM nodes
  //
  // @returns {Array} collection of unique nodes, sorted in document order
  exports.uniqueSort = function(nodes) {
  	var idx = nodes.length, node, position;

  	nodes = nodes.slice();

  	while (--idx > -1) {
  		node = nodes[idx];
  		position = nodes.indexOf(node);
  		if (position > -1 && position < idx) {
  			nodes.splice(idx, 1);
  		}
  	}
  	nodes.sort(function(a, b) {
  		var relative = comparePos(a, b);
  		if (relative & POSITION.PRECEDING) {
  			return -1;
  		} else if (relative & POSITION.FOLLOWING) {
  			return 1;
  		}
  		return 0;
  	});

  	return nodes;
  };
  });
  var helpers_1 = helpers.removeSubsets;
  var helpers_2 = helpers.compareDocumentPosition;
  var helpers_3 = helpers.uniqueSort;

  var domutils = createCommonjsModule(function (module) {
  var DomUtils = module.exports;

  [
  	stringify,
  	traversal,
  	manipulation,
  	querying,
  	legacy$2,
  	helpers
  ].forEach(function(ext){
  	Object.keys(ext).forEach(function(key){
  		DomUtils[key] = ext[key].bind(DomUtils);
  	});
  });
  });

  var boolbase = {
  	trueFunc: function trueFunc(){
  		return true;
  	},
  	falseFunc: function falseFunc(){
  		return false;
  	}
  };

  var parse_1 = createCommonjsModule(function (module, exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = parse;
  var reName = /^(?:\\([\da-f]{1,6}\s?|(\s)|.)|[\w\-\u00b0-\uFFFF])+/, reEscape = /\\([\da-f]{1,6}\s?|(\s)|.)/gi, 
  //modified version of https://github.com/jquery/sizzle/blob/master/src/sizzle.js#L87
  reAttr = /^\s*((?:\\.|[\w\u00b0-\uFFFF-])+)\s*(?:(\S?)=\s*(?:(['"])([^]*?)\3|(#?(?:\\.|[\w\u00b0-\uFFFF-])*)|)|)\s*(i)?\]/;
  var actionTypes = {
      undefined: "exists",
      "": "equals",
      "~": "element",
      "^": "start",
      $: "end",
      "*": "any",
      "!": "not",
      "|": "hyphen"
  };
  var Traversals = {
      ">": "child",
      "<": "parent",
      "~": "sibling",
      "+": "adjacent"
  };
  var attribSelectors = {
      "#": ["id", "equals"],
      ".": ["class", "element"]
  };
  //pseudos, whose data-property is parsed as well
  var unpackPseudos = new Set(["has", "not", "matches"]);
  var stripQuotesFromPseudos = new Set(["contains", "icontains"]);
  var quotes = new Set(['"', "'"]);
  //unescape function taken from https://github.com/jquery/sizzle/blob/master/src/sizzle.js#L152
  function funescape(_, escaped, escapedWhitespace) {
      var high = parseInt(escaped, 16) - 0x10000;
      // NaN means non-codepoint
      return high !== high || escapedWhitespace
          ? escaped
          : high < 0
              ? // BMP codepoint
                  String.fromCharCode(high + 0x10000)
              : // Supplemental Plane codepoint (surrogate pair)
                  String.fromCharCode((high >> 10) | 0xd800, (high & 0x3ff) | 0xdc00);
  }
  function unescapeCSS(str) {
      return str.replace(reEscape, funescape);
  }
  function isWhitespace(c) {
      return c === " " || c === "\n" || c === "\t" || c === "\f" || c === "\r";
  }
  function parse(selector, options) {
      var subselects = [];
      selector = parseSelector(subselects, selector + "", options);
      if (selector !== "") {
          throw new Error("Unmatched selector: " + selector);
      }
      return subselects;
  }
  function parseSelector(subselects, selector, options) {
      var tokens = [], sawWS = false;
      function getName() {
          var match = selector.match(reName);
          if (!match) {
              throw new Error("Expected name, found " + selector);
          }
          var sub = match[0];
          selector = selector.substr(sub.length);
          return unescapeCSS(sub);
      }
      function stripWhitespace(start) {
          while (isWhitespace(selector.charAt(start)))
              start++;
          selector = selector.substr(start);
      }
      function isEscaped(pos) {
          var slashCount = 0;
          while (selector.charAt(--pos) === "\\")
              slashCount++;
          return (slashCount & 1) === 1;
      }
      stripWhitespace(0);
      while (selector !== "") {
          var firstChar = selector.charAt(0);
          if (isWhitespace(firstChar)) {
              sawWS = true;
              stripWhitespace(1);
          }
          else if (firstChar in Traversals) {
              tokens.push({ type: Traversals[firstChar] });
              sawWS = false;
              stripWhitespace(1);
          }
          else if (firstChar === ",") {
              if (tokens.length === 0) {
                  throw new Error("Empty sub-selector");
              }
              subselects.push(tokens);
              tokens = [];
              sawWS = false;
              stripWhitespace(1);
          }
          else {
              if (sawWS) {
                  if (tokens.length > 0) {
                      tokens.push({ type: "descendant" });
                  }
                  sawWS = false;
              }
              if (firstChar === "*") {
                  selector = selector.substr(1);
                  tokens.push({ type: "universal" });
              }
              else if (firstChar in attribSelectors) {
                  var _a = attribSelectors[firstChar], name_1 = _a[0], action = _a[1];
                  selector = selector.substr(1);
                  tokens.push({
                      type: "attribute",
                      name: name_1,
                      action: action,
                      value: getName(),
                      ignoreCase: false
                  });
              }
              else if (firstChar === "[") {
                  selector = selector.substr(1);
                  var data = selector.match(reAttr);
                  if (!data) {
                      throw new Error("Malformed attribute selector: " + selector);
                  }
                  selector = selector.substr(data[0].length);
                  var name_2 = unescapeCSS(data[1]);
                  if (!options ||
                      ("lowerCaseAttributeNames" in options
                          ? options.lowerCaseAttributeNames
                          : !options.xmlMode)) {
                      name_2 = name_2.toLowerCase();
                  }
                  tokens.push({
                      type: "attribute",
                      name: name_2,
                      action: actionTypes[data[2]],
                      value: unescapeCSS(data[4] || data[5] || ""),
                      ignoreCase: !!data[6]
                  });
              }
              else if (firstChar === ":") {
                  if (selector.charAt(1) === ":") {
                      selector = selector.substr(2);
                      tokens.push({
                          type: "pseudo-element",
                          name: getName().toLowerCase()
                      });
                      continue;
                  }
                  selector = selector.substr(1);
                  var name_3 = getName().toLowerCase();
                  var data = null;
                  if (selector.charAt(0) === "(") {
                      if (unpackPseudos.has(name_3)) {
                          var quot = selector.charAt(1);
                          var quoted = quotes.has(quot);
                          selector = selector.substr(quoted ? 2 : 1);
                          data = [];
                          selector = parseSelector(data, selector, options);
                          if (quoted) {
                              if (selector.charAt(0) !== quot) {
                                  throw new Error("Unmatched quotes in :" + name_3);
                              }
                              else {
                                  selector = selector.substr(1);
                              }
                          }
                          if (selector.charAt(0) !== ")") {
                              throw new Error("Missing closing parenthesis in :" + name_3 + " (" + selector + ")");
                          }
                          selector = selector.substr(1);
                      }
                      else {
                          var pos = 1, counter = 1;
                          for (; counter > 0 && pos < selector.length; pos++) {
                              if (selector.charAt(pos) === "(" && !isEscaped(pos))
                                  counter++;
                              else if (selector.charAt(pos) === ")" &&
                                  !isEscaped(pos))
                                  counter--;
                          }
                          if (counter) {
                              throw new Error("Parenthesis not matched");
                          }
                          data = selector.substr(1, pos - 2);
                          selector = selector.substr(pos);
                          if (stripQuotesFromPseudos.has(name_3)) {
                              var quot = data.charAt(0);
                              if (quot === data.slice(-1) && quotes.has(quot)) {
                                  data = data.slice(1, -1);
                              }
                              data = unescapeCSS(data);
                          }
                      }
                  }
                  tokens.push({ type: "pseudo", name: name_3, data: data });
              }
              else if (reName.test(selector)) {
                  var name_4 = getName();
                  if (!options ||
                      ("lowerCaseTags" in options
                          ? options.lowerCaseTags
                          : !options.xmlMode)) {
                      name_4 = name_4.toLowerCase();
                  }
                  tokens.push({ type: "tag", name: name_4 });
              }
              else {
                  if (tokens.length &&
                      tokens[tokens.length - 1].type === "descendant") {
                      tokens.pop();
                  }
                  addToken(subselects, tokens);
                  return selector;
              }
          }
      }
      addToken(subselects, tokens);
      return selector;
  }
  function addToken(subselects, tokens) {
      if (subselects.length > 0 && tokens.length === 0) {
          throw new Error("Empty sub-selector");
      }
      subselects.push(tokens);
  }
  });

  unwrapExports(parse_1);

  var stringify_1 = createCommonjsModule(function (module, exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var actionTypes = {
      equals: "",
      element: "~",
      start: "^",
      end: "$",
      any: "*",
      not: "!",
      hyphen: "|"
  };
  var simpleSelectors = {
      child: " > ",
      parent: " < ",
      sibling: " ~ ",
      adjacent: " + ",
      descendant: " ",
      universal: "*"
  };
  function stringify(token) {
      return token.map(stringifySubselector).join(", ");
  }
  exports.default = stringify;
  function stringifySubselector(token) {
      return token.map(stringifyToken).join("");
  }
  function stringifyToken(token) {
      if (token.type in simpleSelectors)
          return simpleSelectors[token.type];
      if (token.type === "tag")
          return escapeName(token.name);
      if (token.type === "pseudo-element")
          return "::" + escapeName(token.name);
      if (token.type === "attribute") {
          if (token.action === "exists") {
              return "[" + escapeName(token.name) + "]";
          }
          if (token.name === "id" &&
              token.action === "equals" &&
              !token.ignoreCase) {
              return "#" + escapeName(token.value);
          }
          if (token.name === "class" &&
              token.action === "element" &&
              !token.ignoreCase) {
              return "." + escapeName(token.value);
          }
          var atributeName = escapeName(token.name);
          var action = actionTypes[token.action];
          var value = escapeName(token.value);
          var ignoreCase = token.ignoreCase ? "i" : "";
          return "[" + atributeName + action + "='" + value + "'" + ignoreCase + "]";
      }
      if (token.type === "pseudo") {
          if (token.data === null)
              return ":" + escapeName(token.name);
          if (typeof token.data === "string") {
              return ":" + escapeName(token.name) + "(" + token.data + ")";
          }
          return ":" + escapeName(token.name) + "(" + stringify(token.data) + ")";
      }
      throw new Error("Unknown type");
  }
  function escapeName(str) {
      //TODO
      return str;
  }
  });

  unwrapExports(stringify_1);

  var lib$2 = createCommonjsModule(function (module, exports) {
  function __export(m) {
      for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  __export(parse_1);
  var parse_1$1 = parse_1;
  exports.parse = parse_1$1.default;

  exports.stringify = stringify_1.default;
  });

  unwrapExports(lib$2);
  var lib_1$2 = lib$2.parse;
  var lib_2$2 = lib$2.stringify;

  var universal = 50;
  var tag = 30;
  var attribute = 1;
  var pseudo = 0;
  var descendant = -1;
  var child = -1;
  var parent = -1;
  var sibling = -1;
  var adjacent = -1;
  var procedure = {
  	universal: universal,
  	tag: tag,
  	attribute: attribute,
  	pseudo: pseudo,
  	descendant: descendant,
  	child: child,
  	parent: parent,
  	sibling: sibling,
  	adjacent: adjacent
  };

  var procedure$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    universal: universal,
    tag: tag,
    attribute: attribute,
    pseudo: pseudo,
    descendant: descendant,
    child: child,
    parent: parent,
    sibling: sibling,
    adjacent: adjacent,
    'default': procedure
  });

  var procedure$2 = getCjsExportFromNamespace(procedure$1);

  var sort = sortByProcedure;

  /*
  	sort the parts of the passed selector,
  	as there is potential for optimization
  	(some types of selectors are faster than others)
  */



  var attributes = {
      __proto__: null,
      exists: 10,
      equals: 8,
      not: 7,
      start: 6,
      end: 6,
      any: 5,
      hyphen: 4,
      element: 4
  };

  function sortByProcedure(arr) {
      var procs = arr.map(getProcedure);
      for (var i = 1; i < arr.length; i++) {
          var procNew = procs[i];

          if (procNew < 0) continue;

          for (var j = i - 1; j >= 0 && procNew < procs[j]; j--) {
              var token = arr[j + 1];
              arr[j + 1] = arr[j];
              arr[j] = token;
              procs[j + 1] = procs[j];
              procs[j] = procNew;
          }
      }
  }

  function getProcedure(token) {
      var proc = procedure$2[token.type];

      if (proc === procedure$2.attribute) {
          proc = attributes[token.action];

          if (proc === attributes.equals && token.name === "id") {
              //prefer ID selectors (eg. #ID)
              proc = 9;
          }

          if (token.ignoreCase) {
              //ignoreCase adds some overhead, prefer "normal" token
              //this is a binary operation, to ensure it's still an int
              proc >>= 1;
          }
      } else if (proc === procedure$2.pseudo) {
          if (!token.data) {
              proc = 3;
          } else if (token.name === "has" || token.name === "contains") {
              proc = 0; //expensive in any case
          } else if (token.name === "matches" || token.name === "not") {
              proc = 0;
              for (var i = 0; i < token.data.length; i++) {
                  //TODO better handling of complex selectors
                  if (token.data[i].length !== 1) continue;
                  var cur = getProcedure(token.data[i][0]);
                  //avoid executing :has or :contains
                  if (cur === 0) {
                      proc = 0;
                      break;
                  }
                  if (cur > proc) proc = cur;
              }
              if (token.data.length > 1 && proc > 0) proc -= 1;
          } else {
              proc = 1;
          }
      }
      return proc;
  }

  var falseFunc = boolbase.falseFunc;

  //https://github.com/slevithan/XRegExp/blob/master/src/xregexp.js#L469
  var reChars = /[-[\]{}()*+?.,\\^$|#\s]/g;

  /*
  	attribute selectors
  */
  var attributeRules = {
      __proto__: null,
      equals: function(next, data, options) {
          var name = data.name;
          var value = data.value;
          var adapter = options.adapter;

          if (data.ignoreCase) {
              value = value.toLowerCase();

              return function equalsIC(elem) {
                  var attr = adapter.getAttributeValue(elem, name);
                  return attr != null && attr.toLowerCase() === value && next(elem);
              };
          }

          return function equals(elem) {
              return adapter.getAttributeValue(elem, name) === value && next(elem);
          };
      },
      hyphen: function(next, data, options) {
          var name = data.name;
          var value = data.value;
          var len = value.length;
          var adapter = options.adapter;

          if (data.ignoreCase) {
              value = value.toLowerCase();

              return function hyphenIC(elem) {
                  var attr = adapter.getAttributeValue(elem, name);
                  return (
                      attr != null &&
                      (attr.length === len || attr.charAt(len) === "-") &&
                      attr.substr(0, len).toLowerCase() === value &&
                      next(elem)
                  );
              };
          }

          return function hyphen(elem) {
              var attr = adapter.getAttributeValue(elem, name);
              return (
                  attr != null &&
                  attr.substr(0, len) === value &&
                  (attr.length === len || attr.charAt(len) === "-") &&
                  next(elem)
              );
          };
      },
      element: function(next, data, options) {
          var name = data.name;
          var value = data.value;
          var adapter = options.adapter;

          if (/\s/.test(value)) {
              return falseFunc;
          }

          value = value.replace(reChars, "\\$&");

          var pattern = "(?:^|\\s)" + value + "(?:$|\\s)",
              flags = data.ignoreCase ? "i" : "",
              regex = new RegExp(pattern, flags);

          return function element(elem) {
              var attr = adapter.getAttributeValue(elem, name);
              return attr != null && regex.test(attr) && next(elem);
          };
      },
      exists: function(next, data, options) {
          var name = data.name;
          var adapter = options.adapter;

          return function exists(elem) {
              return adapter.hasAttrib(elem, name) && next(elem);
          };
      },
      start: function(next, data, options) {
          var name = data.name;
          var value = data.value;
          var len = value.length;
          var adapter = options.adapter;

          if (len === 0) {
              return falseFunc;
          }

          if (data.ignoreCase) {
              value = value.toLowerCase();

              return function startIC(elem) {
                  var attr = adapter.getAttributeValue(elem, name);
                  return attr != null && attr.substr(0, len).toLowerCase() === value && next(elem);
              };
          }

          return function start(elem) {
              var attr = adapter.getAttributeValue(elem, name);
              return attr != null && attr.substr(0, len) === value && next(elem);
          };
      },
      end: function(next, data, options) {
          var name = data.name;
          var value = data.value;
          var len = -value.length;
          var adapter = options.adapter;

          if (len === 0) {
              return falseFunc;
          }

          if (data.ignoreCase) {
              value = value.toLowerCase();

              return function endIC(elem) {
                  var attr = adapter.getAttributeValue(elem, name);
                  return attr != null && attr.substr(len).toLowerCase() === value && next(elem);
              };
          }

          return function end(elem) {
              var attr = adapter.getAttributeValue(elem, name);
              return attr != null && attr.substr(len) === value && next(elem);
          };
      },
      any: function(next, data, options) {
          var name = data.name;
          var value = data.value;
          var adapter = options.adapter;

          if (value === "") {
              return falseFunc;
          }

          if (data.ignoreCase) {
              var regex = new RegExp(value.replace(reChars, "\\$&"), "i");

              return function anyIC(elem) {
                  var attr = adapter.getAttributeValue(elem, name);
                  return attr != null && regex.test(attr) && next(elem);
              };
          }

          return function any(elem) {
              var attr = adapter.getAttributeValue(elem, name);
              return attr != null && attr.indexOf(value) >= 0 && next(elem);
          };
      },
      not: function(next, data, options) {
          var name = data.name;
          var value = data.value;
          var adapter = options.adapter;

          if (value === "") {
              return function notEmpty(elem) {
                  return !!adapter.getAttributeValue(elem, name) && next(elem);
              };
          } else if (data.ignoreCase) {
              value = value.toLowerCase();

              return function notIC(elem) {
                  var attr = adapter.getAttributeValue(elem, name);
                  return attr != null && attr.toLowerCase() !== value && next(elem);
              };
          }

          return function not(elem) {
              return adapter.getAttributeValue(elem, name) !== value && next(elem);
          };
      }
  };

  var attributes$1 = {
      compile: function(next, data, options) {
          if (options && options.strict && (data.ignoreCase || data.action === "not")) {
              throw new Error("Unsupported attribute selector");
          }
          return attributeRules[data.action](next, data, options);
      },
      rules: attributeRules
  };

  var parse_1$1 = parse;

  //following http://www.w3.org/TR/css3-selectors/#nth-child-pseudo

  //[ ['-'|'+']? INTEGER? {N} [ S* ['-'|'+'] S* INTEGER ]?
  var re_nthElement = /^([+\-]?\d*n)?\s*(?:([+\-]?)\s*(\d+))?$/;

  /*
  	parses a nth-check formula, returns an array of two numbers
  */
  function parse(formula){
  	formula = formula.trim().toLowerCase();

  	if(formula === "even"){
  		return [2, 0];
  	} else if(formula === "odd"){
  		return [2, 1];
  	} else {
  		var parsed = formula.match(re_nthElement);

  		if(!parsed){
  			throw new SyntaxError("n-th rule couldn't be parsed ('" + formula + "')");
  		}

  		var a;

  		if(parsed[1]){
  			a = parseInt(parsed[1], 10);
  			if(isNaN(a)){
  				if(parsed[1].charAt(0) === "-") a = -1;
  				else a = 1;
  			}
  		} else a = 0;

  		return [
  			a,
  			parsed[3] ? parseInt((parsed[2] || "") + parsed[3], 10) : 0
  		];
  	}
  }

  var compile_1 = compile;

  var trueFunc  = boolbase.trueFunc,
      falseFunc$1 = boolbase.falseFunc;

  /*
  	returns a function that checks if an elements index matches the given rule
  	highly optimized to return the fastest solution
  */
  function compile(parsed){
  	var a = parsed[0],
  	    b = parsed[1] - 1;

  	//when b <= 0, a*n won't be possible for any matches when a < 0
  	//besides, the specification says that no element is matched when a and b are 0
  	if(b < 0 && a <= 0) return falseFunc$1;

  	//when a is in the range -1..1, it matches any element (so only b is checked)
  	if(a ===-1) return function(pos){ return pos <= b; };
  	if(a === 0) return function(pos){ return pos === b; };
  	//when b <= 0 and a === 1, they match any element
  	if(a === 1) return b < 0 ? trueFunc : function(pos){ return pos >= b; };

  	//when a > 0, modulo can be used to check if there is a match
  	var bMod = b % a;
  	if(bMod < 0) bMod += a;

  	if(a > 1){
  		return function(pos){
  			return pos >= b && pos % a === bMod;
  		};
  	}

  	a *= -1; //make `a` positive

  	return function(pos){
  		return pos <= b && pos % a === bMod;
  	};
  }

  var nthCheck = function nthCheck(formula){
  	return compile_1(parse_1$1(formula));
  };

  var parse_1$2 = parse_1$1;
  var compile_1$1 = compile_1;
  nthCheck.parse = parse_1$2;
  nthCheck.compile = compile_1$1;

  /*
  	pseudo selectors

  	---

  	they are available in two forms:
  	* filters called when the selector
  	  is compiled and return a function
  	  that needs to return next()
  	* pseudos get called on execution
  	  they need to return a boolean
  */




  var trueFunc$1 = boolbase.trueFunc;
  var falseFunc$2 = boolbase.falseFunc;

  var checkAttrib = attributes$1.rules.equals;

  function getAttribFunc(name, value) {
      var data = { name: name, value: value };
      return function attribFunc(next, rule, options) {
          return checkAttrib(next, data, options);
      };
  }

  function getChildFunc(next, adapter) {
      return function(elem) {
          return !!adapter.getParent(elem) && next(elem);
      };
  }

  var filters = {
      contains: function(next, text, options) {
          var adapter = options.adapter;

          return function contains(elem) {
              return next(elem) && adapter.getText(elem).indexOf(text) >= 0;
          };
      },
      icontains: function(next, text, options) {
          var itext = text.toLowerCase();
          var adapter = options.adapter;

          return function icontains(elem) {
              return (
                  next(elem) &&
                  adapter
                      .getText(elem)
                      .toLowerCase()
                      .indexOf(itext) >= 0
              );
          };
      },

      //location specific methods
      "nth-child": function(next, rule, options) {
          var func = nthCheck(rule);
          var adapter = options.adapter;

          if (func === falseFunc$2) return func;
          if (func === trueFunc$1) return getChildFunc(next, adapter);

          return function nthChild(elem) {
              var siblings = adapter.getSiblings(elem);

              for (var i = 0, pos = 0; i < siblings.length; i++) {
                  if (adapter.isTag(siblings[i])) {
                      if (siblings[i] === elem) break;
                      else pos++;
                  }
              }

              return func(pos) && next(elem);
          };
      },
      "nth-last-child": function(next, rule, options) {
          var func = nthCheck(rule);
          var adapter = options.adapter;

          if (func === falseFunc$2) return func;
          if (func === trueFunc$1) return getChildFunc(next, adapter);

          return function nthLastChild(elem) {
              var siblings = adapter.getSiblings(elem);

              for (var pos = 0, i = siblings.length - 1; i >= 0; i--) {
                  if (adapter.isTag(siblings[i])) {
                      if (siblings[i] === elem) break;
                      else pos++;
                  }
              }

              return func(pos) && next(elem);
          };
      },
      "nth-of-type": function(next, rule, options) {
          var func = nthCheck(rule);
          var adapter = options.adapter;

          if (func === falseFunc$2) return func;
          if (func === trueFunc$1) return getChildFunc(next, adapter);

          return function nthOfType(elem) {
              var siblings = adapter.getSiblings(elem);

              for (var pos = 0, i = 0; i < siblings.length; i++) {
                  if (adapter.isTag(siblings[i])) {
                      if (siblings[i] === elem) break;
                      if (adapter.getName(siblings[i]) === adapter.getName(elem)) pos++;
                  }
              }

              return func(pos) && next(elem);
          };
      },
      "nth-last-of-type": function(next, rule, options) {
          var func = nthCheck(rule);
          var adapter = options.adapter;

          if (func === falseFunc$2) return func;
          if (func === trueFunc$1) return getChildFunc(next, adapter);

          return function nthLastOfType(elem) {
              var siblings = adapter.getSiblings(elem);

              for (var pos = 0, i = siblings.length - 1; i >= 0; i--) {
                  if (adapter.isTag(siblings[i])) {
                      if (siblings[i] === elem) break;
                      if (adapter.getName(siblings[i]) === adapter.getName(elem)) pos++;
                  }
              }

              return func(pos) && next(elem);
          };
      },

      //TODO determine the actual root element
      root: function(next, rule, options) {
          var adapter = options.adapter;

          return function(elem) {
              return !adapter.getParent(elem) && next(elem);
          };
      },

      scope: function(next, rule, options, context) {
          var adapter = options.adapter;

          if (!context || context.length === 0) {
              //equivalent to :root
              return filters.root(next, rule, options);
          }

          function equals(a, b) {
              if (typeof adapter.equals === "function") return adapter.equals(a, b);

              return a === b;
          }

          if (context.length === 1) {
              //NOTE: can't be unpacked, as :has uses this for side-effects
              return function(elem) {
                  return equals(context[0], elem) && next(elem);
              };
          }

          return function(elem) {
              return context.indexOf(elem) >= 0 && next(elem);
          };
      },

      //jQuery extensions (others follow as pseudos)
      checkbox: getAttribFunc("type", "checkbox"),
      file: getAttribFunc("type", "file"),
      password: getAttribFunc("type", "password"),
      radio: getAttribFunc("type", "radio"),
      reset: getAttribFunc("type", "reset"),
      image: getAttribFunc("type", "image"),
      submit: getAttribFunc("type", "submit"),

      //dynamic state pseudos. These depend on optional Adapter methods.
      hover: function(next, rule, options) {
          var adapter = options.adapter;

          if (typeof adapter.isHovered === 'function') {
              return function hover(elem) {
                  return next(elem) && adapter.isHovered(elem);
              };
          }

          return falseFunc$2;
      },
      visited: function(next, rule, options) {
          var adapter = options.adapter;

          if (typeof adapter.isVisited === 'function') {
              return function visited(elem) {
                  return next(elem) && adapter.isVisited(elem);
              };
          }

          return falseFunc$2;
      },
      active: function(next, rule, options) {
          var adapter = options.adapter;

          if (typeof adapter.isActive === 'function') {
              return function active(elem) {
                  return next(elem) && adapter.isActive(elem);
              };
          }

          return falseFunc$2;
      }
  };

  //helper methods
  function getFirstElement(elems, adapter) {
      for (var i = 0; elems && i < elems.length; i++) {
          if (adapter.isTag(elems[i])) return elems[i];
      }
  }

  //while filters are precompiled, pseudos get called when they are needed
  var pseudos = {
      empty: function(elem, adapter) {
          return !adapter.getChildren(elem).some(function(elem) {
              return adapter.isTag(elem) || elem.type === "text";
          });
      },

      "first-child": function(elem, adapter) {
          return getFirstElement(adapter.getSiblings(elem), adapter) === elem;
      },
      "last-child": function(elem, adapter) {
          var siblings = adapter.getSiblings(elem);

          for (var i = siblings.length - 1; i >= 0; i--) {
              if (siblings[i] === elem) return true;
              if (adapter.isTag(siblings[i])) break;
          }

          return false;
      },
      "first-of-type": function(elem, adapter) {
          var siblings = adapter.getSiblings(elem);

          for (var i = 0; i < siblings.length; i++) {
              if (adapter.isTag(siblings[i])) {
                  if (siblings[i] === elem) return true;
                  if (adapter.getName(siblings[i]) === adapter.getName(elem)) break;
              }
          }

          return false;
      },
      "last-of-type": function(elem, adapter) {
          var siblings = adapter.getSiblings(elem);

          for (var i = siblings.length - 1; i >= 0; i--) {
              if (adapter.isTag(siblings[i])) {
                  if (siblings[i] === elem) return true;
                  if (adapter.getName(siblings[i]) === adapter.getName(elem)) break;
              }
          }

          return false;
      },
      "only-of-type": function(elem, adapter) {
          var siblings = adapter.getSiblings(elem);

          for (var i = 0, j = siblings.length; i < j; i++) {
              if (adapter.isTag(siblings[i])) {
                  if (siblings[i] === elem) continue;
                  if (adapter.getName(siblings[i]) === adapter.getName(elem)) {
                      return false;
                  }
              }
          }

          return true;
      },
      "only-child": function(elem, adapter) {
          var siblings = adapter.getSiblings(elem);

          for (var i = 0; i < siblings.length; i++) {
              if (adapter.isTag(siblings[i]) && siblings[i] !== elem) return false;
          }

          return true;
      },

      //:matches(a, area, link)[href]
      link: function(elem, adapter) {
          return adapter.hasAttrib(elem, "href");
      },
      //TODO: :any-link once the name is finalized (as an alias of :link)

      //forms
      //to consider: :target

      //:matches([selected], select:not([multiple]):not(> option[selected]) > option:first-of-type)
      selected: function(elem, adapter) {
          if (adapter.hasAttrib(elem, "selected")) return true;
          else if (adapter.getName(elem) !== "option") return false;

          //the first <option> in a <select> is also selected
          var parent = adapter.getParent(elem);

          if (!parent || adapter.getName(parent) !== "select" || adapter.hasAttrib(parent, "multiple")) {
              return false;
          }

          var siblings = adapter.getChildren(parent);
          var sawElem = false;

          for (var i = 0; i < siblings.length; i++) {
              if (adapter.isTag(siblings[i])) {
                  if (siblings[i] === elem) {
                      sawElem = true;
                  } else if (!sawElem) {
                      return false;
                  } else if (adapter.hasAttrib(siblings[i], "selected")) {
                      return false;
                  }
              }
          }

          return sawElem;
      },
      //https://html.spec.whatwg.org/multipage/scripting.html#disabled-elements
      //:matches(
      //  :matches(button, input, select, textarea, menuitem, optgroup, option)[disabled],
      //  optgroup[disabled] > option),
      // fieldset[disabled] * //TODO not child of first <legend>
      //)
      disabled: function(elem, adapter) {
          return adapter.hasAttrib(elem, "disabled");
      },
      enabled: function(elem, adapter) {
          return !adapter.hasAttrib(elem, "disabled");
      },
      //:matches(:matches(:radio, :checkbox)[checked], :selected) (TODO menuitem)
      checked: function(elem, adapter) {
          return adapter.hasAttrib(elem, "checked") || pseudos.selected(elem, adapter);
      },
      //:matches(input, select, textarea)[required]
      required: function(elem, adapter) {
          return adapter.hasAttrib(elem, "required");
      },
      //:matches(input, select, textarea):not([required])
      optional: function(elem, adapter) {
          return !adapter.hasAttrib(elem, "required");
      },

      //jQuery extensions

      //:not(:empty)
      parent: function(elem, adapter) {
          return !pseudos.empty(elem, adapter);
      },
      //:matches(h1, h2, h3, h4, h5, h6)
      header: namePseudo(["h1", "h2", "h3", "h4", "h5", "h6"]),

      //:matches(button, input[type=button])
      button: function(elem, adapter) {
          var name = adapter.getName(elem);
          return (
              name === "button" || (name === "input" && adapter.getAttributeValue(elem, "type") === "button")
          );
      },
      //:matches(input, textarea, select, button)
      input: namePseudo(["input", "textarea", "select", "button"]),
      //input:matches(:not([type!='']), [type='text' i])
      text: function(elem, adapter) {
          var attr;
          return (
              adapter.getName(elem) === "input" &&
              (!(attr = adapter.getAttributeValue(elem, "type")) || attr.toLowerCase() === "text")
          );
      }
  };

  function namePseudo(names) {
      if (typeof Set !== "undefined") {
          // eslint-disable-next-line no-undef
          var nameSet = new Set(names);

          return function(elem, adapter) {
              return nameSet.has(adapter.getName(elem));
          };
      }

      return function(elem, adapter) {
          return names.indexOf(adapter.getName(elem)) >= 0;
      };
  }

  function verifyArgs(func, name, subselect) {
      if (subselect === null) {
          if (func.length > 2 && name !== "scope") {
              throw new Error("pseudo-selector :" + name + " requires an argument");
          }
      } else {
          if (func.length === 2) {
              throw new Error("pseudo-selector :" + name + " doesn't have any arguments");
          }
      }
  }

  //FIXME this feels hacky
  var re_CSS3 = /^(?:(?:nth|last|first|only)-(?:child|of-type)|root|empty|(?:en|dis)abled|checked|not)$/;

  var pseudos_1 = {
      compile: function(next, data, options, context) {
          var name = data.name;
          var subselect = data.data;
          var adapter = options.adapter;

          if (options && options.strict && !re_CSS3.test(name)) {
              throw new Error(":" + name + " isn't part of CSS3");
          }

          if (typeof filters[name] === "function") {
              return filters[name](next, subselect, options, context);
          } else if (typeof pseudos[name] === "function") {
              var func = pseudos[name];

              verifyArgs(func, name, subselect);

              if (func === falseFunc$2) {
                  return func;
              }

              if (next === trueFunc$1) {
                  return function pseudoRoot(elem) {
                      return func(elem, adapter, subselect);
                  };
              }

              return function pseudoArgs(elem) {
                  return func(elem, adapter, subselect) && next(elem);
              };
          } else {
              throw new Error("unmatched pseudo-class :" + name);
          }
      },
      filters: filters,
      pseudos: pseudos
  };

  /*
  	all available rules
  */
  var general = {
      __proto__: null,

      attribute: attributes$1.compile,
      pseudo: pseudos_1.compile,

      //tags
      tag: function(next, data, options) {
          var name = data.name;
          var adapter = options.adapter;

          return function tag(elem) {
              return adapter.getName(elem) === name && next(elem);
          };
      },

      //traversal
      descendant: function(next, data, options) {
          // eslint-disable-next-line no-undef
          var isFalseCache = typeof WeakSet !== "undefined" ? new WeakSet() : null;
          var adapter = options.adapter;

          return function descendant(elem) {
              var found = false;

              while (!found && (elem = adapter.getParent(elem))) {
                  if (!isFalseCache || !isFalseCache.has(elem)) {
                      found = next(elem);
                      if (!found && isFalseCache) {
                          isFalseCache.add(elem);
                      }
                  }
              }

              return found;
          };
      },
      _flexibleDescendant: function(next, data, options) {
          var adapter = options.adapter;

          // Include element itself, only used while querying an array
          return function descendant(elem) {
              var found = next(elem);

              while (!found && (elem = adapter.getParent(elem))) {
                  found = next(elem);
              }

              return found;
          };
      },
      parent: function(next, data, options) {
          if (options && options.strict) {
              throw new Error("Parent selector isn't part of CSS3");
          }

          var adapter = options.adapter;

          return function parent(elem) {
              return adapter.getChildren(elem).some(test);
          };

          function test(elem) {
              return adapter.isTag(elem) && next(elem);
          }
      },
      child: function(next, data, options) {
          var adapter = options.adapter;

          return function child(elem) {
              var parent = adapter.getParent(elem);
              return !!parent && next(parent);
          };
      },
      sibling: function(next, data, options) {
          var adapter = options.adapter;

          return function sibling(elem) {
              var siblings = adapter.getSiblings(elem);

              for (var i = 0; i < siblings.length; i++) {
                  if (adapter.isTag(siblings[i])) {
                      if (siblings[i] === elem) break;
                      if (next(siblings[i])) return true;
                  }
              }

              return false;
          };
      },
      adjacent: function(next, data, options) {
          var adapter = options.adapter;

          return function adjacent(elem) {
              var siblings = adapter.getSiblings(elem),
                  lastElement;

              for (var i = 0; i < siblings.length; i++) {
                  if (adapter.isTag(siblings[i])) {
                      if (siblings[i] === elem) break;
                      lastElement = siblings[i];
                  }
              }

              return !!lastElement && next(lastElement);
          };
      },
      universal: function(next) {
          return next;
      }
  };

  /*
  	compiles a selector to an executable function
  */

  var compile_1$2 = compile$1;

  var parse$1 = lib$2.parse;





  var trueFunc$2 = boolbase.trueFunc;
  var falseFunc$3 = boolbase.falseFunc;

  var filters$1 = pseudos_1.filters;

  function compile$1(selector, options, context) {
      var next = compileUnsafe(selector, options, context);
      return wrap(next, options);
  }

  function wrap(next, options) {
      var adapter = options.adapter;

      return function base(elem) {
          return adapter.isTag(elem) && next(elem);
      };
  }

  function compileUnsafe(selector, options, context) {
      var token = parse$1(selector, options);
      return compileToken(token, options, context);
  }

  function includesScopePseudo(t) {
      return (
          t.type === "pseudo" &&
          (t.name === "scope" ||
              (Array.isArray(t.data) &&
                  t.data.some(function(data) {
                      return data.some(includesScopePseudo);
                  })))
      );
  }

  var DESCENDANT_TOKEN = { type: "descendant" };
  var FLEXIBLE_DESCENDANT_TOKEN = { type: "_flexibleDescendant" };
  var SCOPE_TOKEN = { type: "pseudo", name: "scope" };
  var PLACEHOLDER_ELEMENT = {};

  //CSS 4 Spec (Draft): 3.3.1. Absolutizing a Scope-relative Selector
  //http://www.w3.org/TR/selectors4/#absolutizing
  function absolutize(token, options, context) {
      var adapter = options.adapter;

      //TODO better check if context is document
      var hasContext =
          !!context &&
          !!context.length &&
          context.every(function(e) {
              return e === PLACEHOLDER_ELEMENT || !!adapter.getParent(e);
          });

      token.forEach(function(t) {
          if (t.length > 0 && isTraversal(t[0]) && t[0].type !== "descendant") ; else if (hasContext && !(Array.isArray(t) ? t.some(includesScopePseudo) : includesScopePseudo(t))) {
              t.unshift(DESCENDANT_TOKEN);
          } else {
              return;
          }

          t.unshift(SCOPE_TOKEN);
      });
  }

  function compileToken(token, options, context) {
      token = token.filter(function(t) {
          return t.length > 0;
      });

      token.forEach(sort);

      var isArrayContext = Array.isArray(context);

      context = (options && options.context) || context;

      if (context && !isArrayContext) context = [context];

      absolutize(token, options, context);

      var shouldTestNextSiblings = false;

      var query = token
          .map(function(rules) {
              if (rules[0] && rules[1] && rules[0].name === "scope") {
                  var ruleType = rules[1].type;
                  if (isArrayContext && ruleType === "descendant") {
                      rules[1] = FLEXIBLE_DESCENDANT_TOKEN;
                  } else if (ruleType === "adjacent" || ruleType === "sibling") {
                      shouldTestNextSiblings = true;
                  }
              }
              return compileRules(rules, options, context);
          })
          .reduce(reduceRules, falseFunc$3);

      query.shouldTestNextSiblings = shouldTestNextSiblings;

      return query;
  }

  function isTraversal(t) {
      return procedure$2[t.type] < 0;
  }

  function compileRules(rules, options, context) {
      return rules.reduce(function(func, rule) {
          if (func === falseFunc$3) return func;

          if (!(rule.type in general)) {
              throw new Error("Rule type " + rule.type + " is not supported by css-select");
          }

          return general[rule.type](func, rule, options, context);
      }, (options && options.rootFunc) || trueFunc$2);
  }

  function reduceRules(a, b) {
      if (b === falseFunc$3 || a === trueFunc$2) {
          return a;
      }
      if (a === falseFunc$3 || b === trueFunc$2) {
          return b;
      }

      return function combine(elem) {
          return a(elem) || b(elem);
      };
  }

  function containsTraversal(t) {
      return t.some(isTraversal);
  }

  //:not, :has and :matches have to compile selectors
  //doing this in lib/pseudos.js would lead to circular dependencies,
  //so we add them here
  filters$1.not = function(next, token, options, context) {
      var opts = {
          xmlMode: !!(options && options.xmlMode),
          strict: !!(options && options.strict),
          adapter: options.adapter
      };

      if (opts.strict) {
          if (token.length > 1 || token.some(containsTraversal)) {
              throw new Error("complex selectors in :not aren't allowed in strict mode");
          }
      }

      var func = compileToken(token, opts, context);

      if (func === falseFunc$3) return next;
      if (func === trueFunc$2) return falseFunc$3;

      return function not(elem) {
          return !func(elem) && next(elem);
      };
  };

  filters$1.has = function(next, token, options) {
      var adapter = options.adapter;
      var opts = {
          xmlMode: !!(options && options.xmlMode),
          strict: !!(options && options.strict),
          adapter: adapter
      };

      //FIXME: Uses an array as a pointer to the current element (side effects)
      var context = token.some(containsTraversal) ? [PLACEHOLDER_ELEMENT] : null;

      var func = compileToken(token, opts, context);

      if (func === falseFunc$3) return falseFunc$3;
      if (func === trueFunc$2) {
          return function hasChild(elem) {
              return adapter.getChildren(elem).some(adapter.isTag) && next(elem);
          };
      }

      func = wrap(func, options);

      if (context) {
          return function has(elem) {
              return next(elem) && ((context[0] = elem), adapter.existsOne(func, adapter.getChildren(elem)));
          };
      }

      return function has(elem) {
          return next(elem) && adapter.existsOne(func, adapter.getChildren(elem));
      };
  };

  filters$1.matches = function(next, token, options, context) {
      var opts = {
          xmlMode: !!(options && options.xmlMode),
          strict: !!(options && options.strict),
          rootFunc: next,
          adapter: options.adapter
      };

      return compileToken(token, opts, context);
  };

  compile$1.compileToken = compileToken;
  compile$1.compileUnsafe = compileUnsafe;
  compile$1.Pseudos = pseudos_1;

  var cssSelect = CSSselect;


  var falseFunc$4 = boolbase.falseFunc;


  function wrapCompile(func) {
      return function addAdapter(selector, options, context) {
          options = options || {};
          options.adapter = options.adapter || domutils;

          return func(selector, options, context);
      };
  }

  var compile$2 = wrapCompile(compile_1$2);
  var compileUnsafe$1 = wrapCompile(compile_1$2.compileUnsafe);

  function getSelectorFunc(searchFunc) {
      return function select(query, elems, options) {
          options = options || {};
          options.adapter = options.adapter || domutils;

          if (typeof query !== "function") {
              query = compileUnsafe$1(query, options, elems);
          }
          if (query.shouldTestNextSiblings) {
              elems = appendNextSiblings((options && options.context) || elems, options.adapter);
          }
          if (!Array.isArray(elems)) elems = options.adapter.getChildren(elems);
          else elems = options.adapter.removeSubsets(elems);
          return searchFunc(query, elems, options);
      };
  }

  function getNextSiblings(elem, adapter) {
      var siblings = adapter.getSiblings(elem);
      if (!Array.isArray(siblings)) return [];
      siblings = siblings.slice(0);
      while (siblings.shift() !== elem);
      return siblings;
  }

  function appendNextSiblings(elems, adapter) {
      // Order matters because jQuery seems to check the children before the siblings
      if (!Array.isArray(elems)) elems = [elems];
      var newElems = elems.slice(0);

      for (var i = 0, len = elems.length; i < len; i++) {
          var nextSiblings = getNextSiblings(newElems[i], adapter);
          newElems.push.apply(newElems, nextSiblings);
      }
      return newElems;
  }

  var selectAll = getSelectorFunc(function selectAll(query, elems, options) {
      return query === falseFunc$4 || !elems || elems.length === 0 ? [] : options.adapter.findAll(query, elems);
  });

  var selectOne = getSelectorFunc(function selectOne(query, elems, options) {
      return query === falseFunc$4 || !elems || elems.length === 0 ? null : options.adapter.findOne(query, elems);
  });

  function is(elem, query, options) {
      options = options || {};
      options.adapter = options.adapter || domutils;
      return (typeof query === "function" ? query : compile$2(query, options))(elem);
  }

  /*
  	the exported interface
  */
  function CSSselect(query, elems, options) {
      return selectAll(query, elems, options);
  }

  CSSselect.compile = compile$2;
  CSSselect.filters = compile_1$2.Pseudos.filters;
  CSSselect.pseudos = compile_1$2.Pseudos.pseudos;

  CSSselect.selectAll = selectAll;
  CSSselect.selectOne = selectOne;

  CSSselect.is = is;

  //legacy methods (might be removed)
  CSSselect.parse = compile$2;
  CSSselect.iterate = selectAll;

  //hooks
  CSSselect._compileUnsafe = compileUnsafe$1;
  CSSselect._compileToken = compile_1$2.compileToken;

  var tagtypes = createCommonjsModule(function (module, exports) {
  Object.defineProperty(exports, "__esModule", { value: true });

  function isTag(node) {
      return lib.isTag(node);
  }
  exports.isTag = isTag;
  function isCDATA(node) {
      return "cdata" /* CDATA */ === node.type;
  }
  exports.isCDATA = isCDATA;
  function isText(node) {
      return node.type === "text" /* Text */;
  }
  exports.isText = isText;
  function isComment(node) {
      return node.type === "comment" /* Comment */;
  }
  exports.isComment = isComment;
  function hasChildren(node) {
      return Object.prototype.hasOwnProperty.call(node, "children");
  }
  exports.hasChildren = hasChildren;
  });

  unwrapExports(tagtypes);
  var tagtypes_1 = tagtypes.isTag;
  var tagtypes_2 = tagtypes.isCDATA;
  var tagtypes_3 = tagtypes.isText;
  var tagtypes_4 = tagtypes.isComment;
  var tagtypes_5 = tagtypes.hasChildren;

  var helpers$1 = createCommonjsModule(function (module, exports) {
  Object.defineProperty(exports, "__esModule", { value: true });

  /**
   * Given an array of nodes, remove any member that is contained by another.
   *
   * @param nodes — Nodes to filter.
   */
  function removeSubsets(nodes) {
      var idx = nodes.length;
      // Check if each node (or one of its ancestors) is already contained in the
      // array.
      while (--idx >= 0) {
          var node = nodes[idx];
          // Remove the node if it is not unique.
          // We are going through the array from the end, so we only
          // have to check nodes that preceed the node under consideration in the array.
          if (idx > 0 && nodes.lastIndexOf(node, idx - 1) >= 0) {
              nodes.splice(idx, 1);
              continue;
          }
          for (var ancestor = node.parent; ancestor; ancestor = ancestor.parent) {
              if (nodes.indexOf(ancestor) > -1) {
                  nodes.splice(idx, 1);
                  break;
              }
          }
      }
      return nodes;
  }
  exports.removeSubsets = removeSubsets;
  /***
   * Compare the position of one node against another node in any other document.
   * The return value is a bitmask with the following values:
   *
   * document order:
   * > There is an ordering, document order, defined on all the nodes in the
   * > document corresponding to the order in which the first character of the
   * > XML representation of each node occurs in the XML representation of the
   * > document after expansion of general entities. Thus, the document element
   * > node will be the first node. Element nodes occur before their children.
   * > Thus, document order orders element nodes in order of the occurrence of
   * > their start-tag in the XML (after expansion of entities). The attribute
   * > nodes of an element occur after the element and before its children. The
   * > relative order of attribute nodes is implementation-dependent./
   *
   * Source:
   * http://www.w3.org/TR/DOM-Level-3-Core/glossary.html#dt-document-order
   * @argument nodaA The first node to use in the comparison
   * @argument nodeB The second node to use in the comparison
   *
   * @return A bitmask describing the input nodes' relative position.
   *
   *        See http://dom.spec.whatwg.org/#dom-node-comparedocumentposition for
   *        a description of these values.
   */
  function compareDocumentPosition(nodeA, nodeB) {
      var aParents = [];
      var bParents = [];
      if (nodeA === nodeB) {
          return 0;
      }
      var current = tagtypes.hasChildren(nodeA) ? nodeA : nodeA.parent;
      while (current) {
          aParents.unshift(current);
          current = current.parent;
      }
      current = tagtypes.hasChildren(nodeB) ? nodeB : nodeB.parent;
      while (current) {
          bParents.unshift(current);
          current = current.parent;
      }
      var idx = 0;
      while (aParents[idx] === bParents[idx]) {
          idx++;
      }
      if (idx === 0) {
          return 1 /* DISCONNECTED */;
      }
      var sharedParent = aParents[idx - 1];
      var siblings = sharedParent.children;
      var aSibling = aParents[idx];
      var bSibling = bParents[idx];
      if (siblings.indexOf(aSibling) > siblings.indexOf(bSibling)) {
          if (sharedParent === nodeB) {
              return 4 /* FOLLOWING */ | 16 /* CONTAINED_BY */;
          }
          return 4 /* FOLLOWING */;
      }
      else {
          if (sharedParent === nodeA) {
              return 2 /* PRECEDING */ | 8 /* CONTAINS */;
          }
          return 2 /* PRECEDING */;
      }
  }
  exports.compareDocumentPosition = compareDocumentPosition;
  /***
   * Sort an array of nodes based on their relative position in the document and
   * remove any duplicate nodes. If the array contains nodes that do not belong
   * to the same document, sort order is unspecified.
   *
   * @argument nodes Array of DOM nodes
   * @returns collection of unique nodes, sorted in document order
   */
  function uniqueSort(nodes) {
      nodes = nodes.filter(function (node, i, arr) { return !arr.includes(node, i + 1); });
      nodes.sort(function (a, b) {
          var relative = compareDocumentPosition(a, b);
          if (relative & 2 /* PRECEDING */) {
              return -1;
          }
          else if (relative & 4 /* FOLLOWING */) {
              return 1;
          }
          return 0;
      });
      return nodes;
  }
  exports.uniqueSort = uniqueSort;
  });

  unwrapExports(helpers$1);
  var helpers_1$1 = helpers$1.removeSubsets;
  var helpers_2$1 = helpers$1.compareDocumentPosition;
  var helpers_3$1 = helpers$1.uniqueSort;

  function getTypeName(node) {
    if (node.tag === ReactTypeOfWork.HostText) {
      return '<Text>';
    }

    if (node.tag === ReactTypeOfWork.Fragment) {
      return '<Fragment>';
    }

    if (node.tag === ReactTypeOfWork.SuspenseComponent) {
      return '<Suspense>';
    }

    if (node.tag === ReactTypeOfWork.LazyComponent) {
      debugger;
      return '<Lazy>';
    }

    if (node.tag === ReactTypeOfWork.HostRoot) {
      // Implicit and we're not targeting directly
      return '';
    } // node.tag === ForwardRef: node.type.render is the wrapped component


    var typeName = node.type ? node.type.type || node.type.render || node.type : '';

    if (typeName.displayName) {
      return "<".concat(typeName.displayName.replace(/[()]/g, '_'), ">");
    } else if (typeof typeName === 'function') {
      return "<".concat(typeName.name || 'Anonymous', ">");
    }

    return typeName;
  }
  function getDisplayName(node) {
    if (node.tag === ReactTypeOfWork.HostRoot) {
      return 'Root';
    }

    if (node.tag === ReactTypeOfWork.HostText) {
      return 'Text';
    }

    if (node.tag === ReactTypeOfWork.Fragment) {
      return 'Fragment';
    }

    if (node.tag === ReactTypeOfWork.SuspenseComponent) {
      return 'Suspense';
    }

    if (node.tag === ReactTypeOfWork.LazyComponent) {
      return 'Lazy';
    } // node.tag === ForwardRef: node.type.render is the wrapped component\


    var typeName = node.type ? node.type.type || node.type.render || node.type : '';

    if (typeName.displayName) {
      return typeName.displayName;
    } else if (typeof typeName === 'function') {
      return typeName.name || 'Anonymous';
    }

    return typeName;
  }
  function childOfType(node, parent) {
    var typeName = getTypeName(node);
    var ofType = [];

    if (!parent) {
      return;
    }

    var current = parent.child;

    while (current) {
      if (typeName === getTypeName(current)) {
        ofType.push(current);
      }

      current = current.sibling;
    }

    if (ofType.length === 1) {
      return undefined;
    }

    return {
      ofType: ofType,
      index: ofType.indexOf(node) + 1
    };
  }

  function mapSelectNode(selectNode) {
    var _selectNode$fiber = selectNode.fiber,
        fiber = _selectNode$fiber === void 0 ? {} : _selectNode$fiber;

    if (fiber.tag === ReactTypeOfWork.FunctionalComponent) {
      var _ref;

      return _ref = {}, _defineProperty(_ref, Symbol.toStringTag, 'SelectNode'), _defineProperty(_ref, "displayName", selectNode.displayName), _defineProperty(_ref, "props", fiber.memoizedProps), _defineProperty(_ref, "_reactInternalFiber", fiber), _ref;
    }

    return fiber.stateNode || selectNode;
  }

  var adapter = {
    isTag: function isTag(node) {
      return node.tag === ReactTypeOfWork.FunctionalComponent || node.tag === ReactTypeOfWork.FunctionalComponentLazy || node.tag === ReactTypeOfWork.ClassComponent || node.tag === ReactTypeOfWork.ClassComponentLazy || node.tag === ReactTypeOfWork.MemoComponent || node.tag === ReactTypeOfWork.SimpleMemoComponent || node.tag === ReactTypeOfWork.SuspenseComponent || node.tag === ReactTypeOfWork.SuspenseListComponent || // || node.tag === ReactTypeOfWork.IndeterminateComponent
      node.tag === ReactTypeOfWork.HostRoot || node.tag === ReactTypeOfWork.HostPortal || node.tag === ReactTypeOfWork.HostComponent || // || node.tag === ReactTypeOfWork.HostText
      node.tag === ReactTypeOfWork.Fragment || node.tag === ReactTypeOfWork.DehydratedFragment || // || node.tag === ReactTypeOfWork.Mode
      // || node.tag === ReactTypeOfWork.ContextProvider
      // || node.tag === ReactTypeOfWork.ContextConsumer
      node.tag === ReactTypeOfWork.ForwardRef || node.tag === ReactTypeOfWork.ForwardRefLazy // || node.tag === ReactTypeOfWork.Profiler
      // || node.tag === ReactTypeOfWork.PlaceholderComponent
      ;
    },
    getName: function getName(elem) {
      return elem.typeName;
    },
    hasAttrib: function hasAttrib(elem, name) {
      var _elem$fiber = elem.fiber,
          key = _elem$fiber.key,
          memoizedProps = _elem$fiber.memoizedProps,
          stateNode = _elem$fiber.stateNode;

      if (name === 'key') {
        return key != null;
      }

      if (memoizedProps && memoizedProps[name] != null) {
        return true;
      }

      if (elem.fiber.tag === ReactTypeOfWork.HostRoot || stateNode === null) {
        return false;
      }

      if (stateNode.containerInfo) {
        return stateNode.containerInfo.hasAttribute(name);
      }

      if (stateNode.hasAttribute) {
        return stateNode.hasAttribute(name);
      }

      if (stateNode.props) {
        return stateNode.props[name] != null;
      }

      throw new Error('Unknown node');
    },
    getAttributeValue: function getAttributeValue(elem, name) {
      var _elem$fiber2 = elem.fiber,
          key = _elem$fiber2.key,
          memoizedProps = _elem$fiber2.memoizedProps,
          stateNode = _elem$fiber2.stateNode;

      if (name === 'key') {
        return key;
      }

      if (memoizedProps && memoizedProps[name] != null) {
        return "".concat(memoizedProps[name]);
      }

      if (elem.fiber.tag === ReactTypeOfWork.HostRoot || stateNode === null) {
        return undefined;
      }

      if (stateNode.containerInfo) {
        return stateNode.containerInfo.getAttribute(name);
      }

      if (stateNode.getAttribute) {
        return stateNode.getAttribute(name);
      }

      if (stateNode.props) {
        return "".concat(stateNode.props[name]);
      }

      throw new Error('Unknown node');
    },
    getParent: function getParent(node) {
      return node.parent;
    },
    getChildren: function getChildren(node) {
      return node.children;
    },
    getSiblings: function getSiblings(node) {
      return node.parent && node.parent.children;
    },

    /*
     * Get the text content of the node, and its children if it has any.
     */
    getText: function getText(node) {
      // string;
      throw new Error('Not Impl');
    },
    removeSubsets: helpers_1$1,
    existsOne: function existsOne(test, elems) {
      return !!this.findOne(elems);
    },
    findAll: function findAll(test, elems) {
      var result = [];
      var stack = elems.slice();

      while (stack.length) {
        var elem = stack.shift();
        if (!this.isTag(elem)) continue;

        if (elem.children && elem.children.length > 0) {
          stack.unshift.apply(stack, elem.children);
        }

        if (test(elem)) result.push(mapSelectNode(elem));
      }

      return result;
    },
    findOne: function findOne(test, elems) {
      var elem = null;

      for (var i = 0, l = elems.length; i < l && !elem; i++) {
        if (!this.isTag(elems[i])) {
          continue;
        } else if (test(elems[i])) {
          elem = mapSelectNode(elems[i]);
        } else if (elems[i].children.length > 0) {
          elem = this.findOne(test, elems[i].children);
        }
      }

      return elem;
    },

    /**
        The adapter can also optionally include an equals method, if your DOM
        structure needs a custom equality test to compare two objects which refer
        to the same underlying node. If not provided, `css-select` will fall back to
        `a === b`.
      */
    equals: function equals(a, b) {
      console.log(a);
      return a.stateNode === b.stateNode;
    }
  };

  function SelectNode(fiber, parent) {
    this.typeName = getTypeName(fiber).replace(/[<>]/g, '_');
    this.displayName = getDisplayName(fiber);
    this.tag = fiber.tag;
    this.fiber = fiber;
    this.parent = parent;
    this.children = [];
  }

  function componentDOMNodes(component) {
    if (!component) {
      return [];
    }

    if (component.cloneNode && component.nodeType) {
      // This is a DOM now (probably...)
      return [component];
    }

    var fiber = component._reactInternalFiber || component.fiber || component.constructor.name === 'FiberNode' && component;

    if (fiber.tag === ReactTypeOfWork.HostComponent) {
      return [fiber.stateNode];
    }

    var children = [];
    var child = fiber.child;

    while (child) {
      children = children.concat(componentDOMNodes(child));
      child = child.sibling;
    }

    return children;
  }
  function generateQueryTree(scope) {
    var roots = fiberRoots(); // Find roots that are not a child of another

    var topRoots = roots.filter(function (testing) {
      var current = testing.current.stateNode.containerInfo;
      return !roots.find(function (needle) {
        return needle !== testing && needle.containerInfo.contains(current);
      });
    });
    return topRoots.map(function (root) {
      if (scope) {
        var scopeDom = componentDOMNodes(scope);

        if (scopeDom.find(function (scopeDom) {
          return scopeDom.contains(root.containerInfo);
        })) {
          // Scope is a superset of this root, remove all filtering
          scope = undefined;
        } else if (!scopeDom.find(function (scopeDom) {
          return root.containerInfo.contains(scopeDom);
        })) {
          // DOM Scope and both are unrelated in DOM structure
          return;
        }
      }

      var current = root.current.stateNode.containerInfo;
      var childRoots = roots.filter(function (needle) {
        return needle !== root && current.contains(needle.containerInfo);
      });
      var treeNode = generateTreeNode(scope, root.current, undefined, childRoots); // Record host components for all parents of the react
      // root, filtering document from the iteration

      while (current && current.parentNode) {
        var currentTree = treeNode;
        treeNode = new SelectNode({
          tag: ReactTypeOfWork.HostComponent,
          type: current.tagName.toLowerCase(),
          stateNode: current
        });
        currentTree.parent = treeNode;
        treeNode.children.push(currentTree);
        current = current.parentNode;
      }

      return treeNode;
    }).filter(Boolean);
  }

  function generateTreeNode(scope, fiber, parent, roots) {
    if (!fiber) {
      return;
    }

    if (scope) {
      if (scope._reactInternalFiber !== fiber && scope !== fiber.stateNode && scope.stateNode !== fiber.stateNode) {
        var child = fiber.child;

        while (child) {
          var _ret = generateTreeNode(scope, child, parent, roots);

          if (_ret) {
            return _ret;
          }

          child = child.sibling;
        }

        return undefined;
      }
    }

    var ret = new SelectNode(fiber, parent);

    if (parent) {
      parent.children.push(ret);
    }

    generateTreeNode(undefined, fiber.child, ret, roots);

    if (fiber.tag === ReactTypeOfWork.HostComponent && roots.length) {
      // Check if this is a host of another react rendering context or
      // if we contain the rendering context and non of our children
      // claimed it
      var rootsToClaim = roots.filter(function (child) {
        return child.containerInfo === fiber.stateNode || fiber.stateNode.contains(child.containerInfo);
      });
      rootsToClaim.forEach(function (childRoot) {
        roots.splice(roots.indexOf(childRoot), 1);
        generateTreeNode(undefined, childRoot.current, ret, roots);
      });
    }

    generateTreeNode(undefined, fiber.sibling, parent, roots);
    return ret;
  }

  function generateFullDomMap() {
    var domMap = {
      totalNodes: 0
    };
    fiberRoots().map(function (root) {
      generateDomMap(root.current, [], domMap);
    });
    return domMap;
  }

  function generateDomMap(node, path, into, parent) {
    var typeName = getTypeName(node);
    var ofType = childOfType(node, parent);
    var instanceSelector = '';

    if (node.key) {
      instanceSelector = "[key=".concat(JSON.stringify(node.key), "]");
    } else if (ofType) {
      instanceSelector = ":nth-of-type(".concat(ofType.index, ")");
    }

    var thisPath = typeName ? path.concat({
      type: typeName,
      ofType: ofType,
      selector: "".concat(typeName).concat(instanceSelector)
    }) : path;

    if (typeName) {
      if (!into[typeName]) {
        into[typeName] = [];
      }

      into[typeName].push({
        node: node,
        parent: parent,
        path: thisPath
      });
      into.totalNodes += 1;
    }

    if (node.child) {
      generateDomMap(node.child, thisPath, into, node);
    }

    if (node.sibling) {
      generateDomMap(node.sibling, path, into, parent);
    }

    return into;
  }

  function generatePath(hostNode) {
    // Use the React DOM to generate selector, if possible.
    var path;

    var component = findFiber(hostNode) || hostNode._reactInternalFiber;

    if (component) {
      var domMap = generateFullDomMap();
      var typeName = getTypeName(component);
      var mapped = domMap[typeName].find(function (mapItem) {
        return mapItem.node.stateNode === component.stateNode;
      });
      path = mapped.path.reverse().filter(function (_ref, index) {
        var type = _ref.type,
            selector = _ref.selector,
            ofType = _ref.ofType;
        return !index || /^</.test(selector) || ofType;
      }).map(function (_ref2) {
        var type = _ref2.type,
            selector = _ref2.selector;
        return [selector, domMap[type].length];
      });
      var singleElement = path.findIndex(function (_ref3) {
        var _ref4 = _slicedToArray(_ref3, 2),
            name = _ref4[0],
            count = _ref4[1];

        return /^</.test(name) && count === 1;
      });

      if (singleElement >= 0) {
        path = path.slice(0, singleElement + 1);
      }

      return path.map(function (_ref5) {
        var _ref6 = _slicedToArray(_ref5, 1),
            name = _ref6[0];

        return name;
      }).reverse().join(' ');
    }
  }

  function querySelector(selector, scope) {
    try {
      var roots = generateQueryTree(scope);
      selector = selector.replace(/<(.*?)>/g, '_$1_');
      var reactComponent = cssSelect.selectOne(selector, roots, {
        adapter: adapter,
        xmlMode: true
      });

      if (reactComponent) {
        return reactComponent;
      }
    } catch (err) {
      var toThrow = new Error("Error Evaluating ".concat(selector, ": ").concat(err.message));
      toThrow.stack = err.stack;
      throw toThrow;
    }

    try {
      return (scope || document).querySelector(selector) || undefined;
    } catch (err) {
      /* nop */
    }
  }
  function querySelectorAll(selector, scope) {
    try {
      var roots = generateQueryTree(scope);
      selector = selector.replace(/<(.*?)>/g, '_$1_');
      var reactComponents = cssSelect.selectAll(selector, roots, {
        adapter: adapter,
        xmlMode: true
      });

      if (reactComponents.length) {
        return reactComponents;
      }
    } catch (err) {
      var toThrow = new Error("Error Evaluating ".concat(selector, ": ").concat(err.message));
      toThrow.stack = err.stack;
      throw toThrow;
    }

    try {
      return (scope || document).querySelectorAll(selector);
    } catch (err) {
      /* nop */
    }

    return [];
  }
  function dumpTree(scope) {
    function printNode(node, depth) {
      var padding = '  '.repeat(depth);

      if (node.children.length) {
        return "".concat(padding, "<").concat(node.displayName, ">\n").concat(node.children.map(function (child) {
          return printNode(child, depth + 1);
        }).join(''), "\n").concat(padding, "</").concat(node.displayName, ">\n");
      } else {
        return "".concat(padding, "<").concat(node.displayName, "/>\n");
      }
    }

    return generateQueryTree(scope).map(function (root) {
      return printNode(root, 0);
    });
  }

  exports.componentDOMNodes = componentDOMNodes;
  exports.dumpTree = dumpTree;
  exports.generatePath = generatePath;
  exports.querySelector = querySelector;
  exports.querySelectorAll = querySelectorAll;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
