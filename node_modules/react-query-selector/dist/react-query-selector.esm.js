import cssSelect from 'css-select';
import { removeSubsets } from 'domutils/lib/helpers';

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
}

function _iterableToArrayLimit(arr, i) {
  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(n);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function findFiber(hostNode) {
  var hook = window.__REACT_DEVTOOLS_GLOBAL_HOOK__;
  var renderers = hook.renderers ? Array.from(hook.renderers.values()) : Object.values(hook._renderers);
  return renderers.reduce(function (prev, renderer) {
    return prev || renderer.findFiberByHostInstance(hostNode);
  }, undefined);
}
function fiberRoots() {
  var _ref2;

  var hook = window.__REACT_DEVTOOLS_GLOBAL_HOOK__;

  if (hook.renderers) {
    var _ref;
    return (_ref = []).concat.apply(_ref, _toConsumableArray(Array.from(hook.renderers.keys()).map(function (renderer) {
      return Array.from(hook.getFiberRoots(renderer));
    })));
  }

  return (_ref2 = []).concat.apply(_ref2, _toConsumableArray(Object.values(hook._fiberRoots).map(function (root) {
    return Array.from(root);
  })));
}
var ReactTypeOfWork;

function setupReactDom(_ref3) {
  var version = _ref3.version;

  // **********************************************************
  // The section below is copy-pasted from files in React DevTools repo.
  // Keep it in sync, and add version guards if it changes.
  // https://github.com/facebook/react-devtools/blob/master/backend/attachRendererFiber.js
  // **********************************************************
  // The section below is copy-pasted from files in React repo.
  // Keep it in sync, and add version guards if it changes.
  // **********************************************************
  if (!version.startsWith('16.')) {
    throw new Error('Only react 16 is supported');
  }

  var versionNumber = parseFloat(version.replace(/^16\./, ''));

  if (versionNumber >= 6.0) {
    ReactTypeOfWork = {
      FunctionalComponent: 0,
      ClassComponent: 1,
      IndeterminateComponent: 2,
      HostRoot: 3,
      HostPortal: 4,
      HostComponent: 5,
      HostText: 6,
      Fragment: 7,
      Mode: 8,
      ContextConsumer: 9,
      ContextProvider: 10,
      ForwardRef: 11,
      Profiler: 12,
      SuspenseComponent: 13,
      MemoComponent: 14,
      SimpleMemoComponent: 15,
      LazyComponent: 16,
      IncompleteClassComponent: 17,
      // Warn tracked here, but may not not necessarily implemented
      // correctly as these are new and unstable APIs. May need to
      // be revisited in the future.
      DehydratedFragment: 18,
      SuspenseListComponent: 19,
      FundamentalComponent: 20,
      ScopeComponent: 21,
      CoroutineComponent: -1,
      // Removed
      CoroutineHandlerPhase: -1,
      // Removed
      YieldComponent: -1 // Removed

    };
  } else if (versionNumber >= 4.3) {
    ReactTypeOfWork = {
      FunctionalComponent: 0,
      FunctionalComponentLazy: 1,
      ClassComponent: 2,
      ClassComponentLazy: 3,
      IndeterminateComponent: 4,
      HostRoot: 5,
      HostPortal: 6,
      HostComponent: 7,
      HostText: 8,
      Fragment: 9,
      Mode: 10,
      ContextConsumer: 11,
      ContextProvider: 12,
      ForwardRef: 13,
      ForwardRefLazy: 14,
      Profiler: 15,
      PlaceholderComponent: 16
    };
  } else {
    ReactTypeOfWork = {
      IndeterminateComponent: 0,
      FunctionalComponent: 1,
      FunctionalComponentLazy: -1,
      // Doesn't exist yet
      ClassComponent: 2,
      ClassComponentLazy: -1,
      // Doesn't exist yet
      HostRoot: 3,
      HostPortal: 4,
      HostComponent: 5,
      HostText: 6,
      CoroutineComponent: 7,
      CoroutineHandlerPhase: 8,
      YieldComponent: 9,
      Fragment: 10,
      Mode: 11,
      ContextConsumer: 12,
      ContextProvider: 13,
      ForwardRef: 14,
      ForwardRefLazy: -1,
      // Doesn't exist yet
      Profiler: 15,
      Placeholder: 16
    };
  }
}

if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined') {
  Object.values(__REACT_DEVTOOLS_GLOBAL_HOOK__.renderers || __REACT_DEVTOOLS_GLOBAL_HOOK__._renderers).forEach(setupReactDom);

  __REACT_DEVTOOLS_GLOBAL_HOOK__.on('renderer', function (_ref4) {
    var renderer = _ref4.renderer;
    return setupReactDom(renderer);
  });
} else {
  // Provide our own hook implementation if not running in a devtools environment
  var hook;
  window.__REACT_DEVTOOLS_GLOBAL_HOOK__ = hook = {
    renderers: [],
    _fiberRoots: [],
    getFiberRoots: function getFiberRoots(rendererId) {
      return hook._fiberRoots[rendererId];
    },
    inject: function inject(instance) {
      hook.renderers.push(instance);

      hook._fiberRoots.push([]);

      setupReactDom(instance);
      return hook.renderers.length - 1;
    },
    onCommitFiberRoot: function onCommitFiberRoot(rendererId, root) {
      var mountedRoots = hook._fiberRoots[rendererId];
      var current = root.current;
      var isKnownRoot = mountedRoots.includes(root);
      var isUnmounting = current.memoizedState == null || current.memoizedState.element == null; // Keep track of mounted roots so we can hydrate when DevTools connect.

      if (!isKnownRoot && !isUnmounting) {
        hook._fiberRoots[rendererId].push(root);
      } else if (isKnownRoot && isUnmounting) {
        hook.onCommitFiberUnmount(rendererId, root);
      }
    },
    onCommitFiberUnmount: function onCommitFiberUnmount(rendererId, root) {
      hook._fiberRoots[rendererId] = hook._fiberRoots[rendererId].filter(function (current) {
        return current !== root;
      });
    },
    supportsFiber: true
  };
}

function getTypeName(node) {
  if (node.tag === ReactTypeOfWork.HostText) {
    return '<Text>';
  }

  if (node.tag === ReactTypeOfWork.Fragment) {
    return '<Fragment>';
  }

  if (node.tag === ReactTypeOfWork.SuspenseComponent) {
    return '<Suspense>';
  }

  if (node.tag === ReactTypeOfWork.LazyComponent) {
    debugger;
    return '<Lazy>';
  }

  if (node.tag === ReactTypeOfWork.HostRoot) {
    // Implicit and we're not targeting directly
    return '';
  } // node.tag === ForwardRef: node.type.render is the wrapped component


  var typeName = node.type ? node.type.type || node.type.render || node.type : '';

  if (typeName.displayName) {
    return "<".concat(typeName.displayName.replace(/[()]/g, '_'), ">");
  } else if (typeof typeName === 'function') {
    return "<".concat(typeName.name || 'Anonymous', ">");
  }

  return typeName;
}
function getDisplayName(node) {
  if (node.tag === ReactTypeOfWork.HostRoot) {
    return 'Root';
  }

  if (node.tag === ReactTypeOfWork.HostText) {
    return 'Text';
  }

  if (node.tag === ReactTypeOfWork.Fragment) {
    return 'Fragment';
  }

  if (node.tag === ReactTypeOfWork.SuspenseComponent) {
    return 'Suspense';
  }

  if (node.tag === ReactTypeOfWork.LazyComponent) {
    return 'Lazy';
  } // node.tag === ForwardRef: node.type.render is the wrapped component\


  var typeName = node.type ? node.type.type || node.type.render || node.type : '';

  if (typeName.displayName) {
    return typeName.displayName;
  } else if (typeof typeName === 'function') {
    return typeName.name || 'Anonymous';
  }

  return typeName;
}
function childOfType(node, parent) {
  var typeName = getTypeName(node);
  var ofType = [];

  if (!parent) {
    return;
  }

  var current = parent.child;

  while (current) {
    if (typeName === getTypeName(current)) {
      ofType.push(current);
    }

    current = current.sibling;
  }

  if (ofType.length === 1) {
    return undefined;
  }

  return {
    ofType: ofType,
    index: ofType.indexOf(node) + 1
  };
}

function mapSelectNode(selectNode) {
  var _selectNode$fiber = selectNode.fiber,
      fiber = _selectNode$fiber === void 0 ? {} : _selectNode$fiber;

  if (fiber.tag === ReactTypeOfWork.FunctionalComponent) {
    var _ref;

    return _ref = {}, _defineProperty(_ref, Symbol.toStringTag, 'SelectNode'), _defineProperty(_ref, "displayName", selectNode.displayName), _defineProperty(_ref, "props", fiber.memoizedProps), _defineProperty(_ref, "_reactInternalFiber", fiber), _ref;
  }

  return fiber.stateNode || selectNode;
}

var adapter = {
  isTag: function isTag(node) {
    return node.tag === ReactTypeOfWork.FunctionalComponent || node.tag === ReactTypeOfWork.FunctionalComponentLazy || node.tag === ReactTypeOfWork.ClassComponent || node.tag === ReactTypeOfWork.ClassComponentLazy || node.tag === ReactTypeOfWork.MemoComponent || node.tag === ReactTypeOfWork.SimpleMemoComponent || node.tag === ReactTypeOfWork.SuspenseComponent || node.tag === ReactTypeOfWork.SuspenseListComponent || // || node.tag === ReactTypeOfWork.IndeterminateComponent
    node.tag === ReactTypeOfWork.HostRoot || node.tag === ReactTypeOfWork.HostPortal || node.tag === ReactTypeOfWork.HostComponent || // || node.tag === ReactTypeOfWork.HostText
    node.tag === ReactTypeOfWork.Fragment || node.tag === ReactTypeOfWork.DehydratedFragment || // || node.tag === ReactTypeOfWork.Mode
    // || node.tag === ReactTypeOfWork.ContextProvider
    // || node.tag === ReactTypeOfWork.ContextConsumer
    node.tag === ReactTypeOfWork.ForwardRef || node.tag === ReactTypeOfWork.ForwardRefLazy // || node.tag === ReactTypeOfWork.Profiler
    // || node.tag === ReactTypeOfWork.PlaceholderComponent
    ;
  },
  getName: function getName(elem) {
    return elem.typeName;
  },
  hasAttrib: function hasAttrib(elem, name) {
    var _elem$fiber = elem.fiber,
        key = _elem$fiber.key,
        memoizedProps = _elem$fiber.memoizedProps,
        stateNode = _elem$fiber.stateNode;

    if (name === 'key') {
      return key != null;
    }

    if (memoizedProps && memoizedProps[name] != null) {
      return true;
    }

    if (elem.fiber.tag === ReactTypeOfWork.HostRoot || stateNode === null) {
      return false;
    }

    if (stateNode.containerInfo) {
      return stateNode.containerInfo.hasAttribute(name);
    }

    if (stateNode.hasAttribute) {
      return stateNode.hasAttribute(name);
    }

    if (stateNode.props) {
      return stateNode.props[name] != null;
    }

    throw new Error('Unknown node');
  },
  getAttributeValue: function getAttributeValue(elem, name) {
    var _elem$fiber2 = elem.fiber,
        key = _elem$fiber2.key,
        memoizedProps = _elem$fiber2.memoizedProps,
        stateNode = _elem$fiber2.stateNode;

    if (name === 'key') {
      return key;
    }

    if (memoizedProps && memoizedProps[name] != null) {
      return "".concat(memoizedProps[name]);
    }

    if (elem.fiber.tag === ReactTypeOfWork.HostRoot || stateNode === null) {
      return undefined;
    }

    if (stateNode.containerInfo) {
      return stateNode.containerInfo.getAttribute(name);
    }

    if (stateNode.getAttribute) {
      return stateNode.getAttribute(name);
    }

    if (stateNode.props) {
      return "".concat(stateNode.props[name]);
    }

    throw new Error('Unknown node');
  },
  getParent: function getParent(node) {
    return node.parent;
  },
  getChildren: function getChildren(node) {
    return node.children;
  },
  getSiblings: function getSiblings(node) {
    return node.parent && node.parent.children;
  },

  /*
   * Get the text content of the node, and its children if it has any.
   */
  getText: function getText(node) {
    // string;
    throw new Error('Not Impl');
  },
  removeSubsets: removeSubsets,
  existsOne: function existsOne(test, elems) {
    return !!this.findOne(elems);
  },
  findAll: function findAll(test, elems) {
    var result = [];
    var stack = elems.slice();

    while (stack.length) {
      var elem = stack.shift();
      if (!this.isTag(elem)) continue;

      if (elem.children && elem.children.length > 0) {
        stack.unshift.apply(stack, elem.children);
      }

      if (test(elem)) result.push(mapSelectNode(elem));
    }

    return result;
  },
  findOne: function findOne(test, elems) {
    var elem = null;

    for (var i = 0, l = elems.length; i < l && !elem; i++) {
      if (!this.isTag(elems[i])) {
        continue;
      } else if (test(elems[i])) {
        elem = mapSelectNode(elems[i]);
      } else if (elems[i].children.length > 0) {
        elem = this.findOne(test, elems[i].children);
      }
    }

    return elem;
  },

  /**
      The adapter can also optionally include an equals method, if your DOM
      structure needs a custom equality test to compare two objects which refer
      to the same underlying node. If not provided, `css-select` will fall back to
      `a === b`.
    */
  equals: function equals(a, b) {
    console.log(a);
    return a.stateNode === b.stateNode;
  }
};

function SelectNode(fiber, parent) {
  this.typeName = getTypeName(fiber).replace(/[<>]/g, '_');
  this.displayName = getDisplayName(fiber);
  this.tag = fiber.tag;
  this.fiber = fiber;
  this.parent = parent;
  this.children = [];
}

function componentDOMNodes(component) {
  if (!component) {
    return [];
  }

  if (component.cloneNode && component.nodeType) {
    // This is a DOM now (probably...)
    return [component];
  }

  var fiber = component._reactInternalFiber || component.fiber || component.constructor.name === 'FiberNode' && component;

  if (fiber.tag === ReactTypeOfWork.HostComponent) {
    return [fiber.stateNode];
  }

  var children = [];
  var child = fiber.child;

  while (child) {
    children = children.concat(componentDOMNodes(child));
    child = child.sibling;
  }

  return children;
}
function generateQueryTree(scope) {
  var roots = fiberRoots(); // Find roots that are not a child of another

  var topRoots = roots.filter(function (testing) {
    var current = testing.current.stateNode.containerInfo;
    return !roots.find(function (needle) {
      return needle !== testing && needle.containerInfo.contains(current);
    });
  });
  return topRoots.map(function (root) {
    if (scope) {
      var scopeDom = componentDOMNodes(scope);

      if (scopeDom.find(function (scopeDom) {
        return scopeDom.contains(root.containerInfo);
      })) {
        // Scope is a superset of this root, remove all filtering
        scope = undefined;
      } else if (!scopeDom.find(function (scopeDom) {
        return root.containerInfo.contains(scopeDom);
      })) {
        // DOM Scope and both are unrelated in DOM structure
        return;
      }
    }

    var current = root.current.stateNode.containerInfo;
    var childRoots = roots.filter(function (needle) {
      return needle !== root && current.contains(needle.containerInfo);
    });
    var treeNode = generateTreeNode(scope, root.current, undefined, childRoots); // Record host components for all parents of the react
    // root, filtering document from the iteration

    while (current && current.parentNode) {
      var currentTree = treeNode;
      treeNode = new SelectNode({
        tag: ReactTypeOfWork.HostComponent,
        type: current.tagName.toLowerCase(),
        stateNode: current
      });
      currentTree.parent = treeNode;
      treeNode.children.push(currentTree);
      current = current.parentNode;
    }

    return treeNode;
  }).filter(Boolean);
}

function generateTreeNode(scope, fiber, parent, roots) {
  if (!fiber) {
    return;
  }

  if (scope) {
    if (scope._reactInternalFiber !== fiber && scope !== fiber.stateNode && scope.stateNode !== fiber.stateNode) {
      var child = fiber.child;

      while (child) {
        var _ret = generateTreeNode(scope, child, parent, roots);

        if (_ret) {
          return _ret;
        }

        child = child.sibling;
      }

      return undefined;
    }
  }

  var ret = new SelectNode(fiber, parent);

  if (parent) {
    parent.children.push(ret);
  }

  generateTreeNode(undefined, fiber.child, ret, roots);

  if (fiber.tag === ReactTypeOfWork.HostComponent && roots.length) {
    // Check if this is a host of another react rendering context or
    // if we contain the rendering context and non of our children
    // claimed it
    var rootsToClaim = roots.filter(function (child) {
      return child.containerInfo === fiber.stateNode || fiber.stateNode.contains(child.containerInfo);
    });
    rootsToClaim.forEach(function (childRoot) {
      roots.splice(roots.indexOf(childRoot), 1);
      generateTreeNode(undefined, childRoot.current, ret, roots);
    });
  }

  generateTreeNode(undefined, fiber.sibling, parent, roots);
  return ret;
}

function generateFullDomMap() {
  var domMap = {
    totalNodes: 0
  };
  fiberRoots().map(function (root) {
    generateDomMap(root.current, [], domMap);
  });
  return domMap;
}

function generateDomMap(node, path, into, parent) {
  var typeName = getTypeName(node);
  var ofType = childOfType(node, parent);
  var instanceSelector = '';

  if (node.key) {
    instanceSelector = "[key=".concat(JSON.stringify(node.key), "]");
  } else if (ofType) {
    instanceSelector = ":nth-of-type(".concat(ofType.index, ")");
  }

  var thisPath = typeName ? path.concat({
    type: typeName,
    ofType: ofType,
    selector: "".concat(typeName).concat(instanceSelector)
  }) : path;

  if (typeName) {
    if (!into[typeName]) {
      into[typeName] = [];
    }

    into[typeName].push({
      node: node,
      parent: parent,
      path: thisPath
    });
    into.totalNodes += 1;
  }

  if (node.child) {
    generateDomMap(node.child, thisPath, into, node);
  }

  if (node.sibling) {
    generateDomMap(node.sibling, path, into, parent);
  }

  return into;
}

function generatePath(hostNode) {
  // Use the React DOM to generate selector, if possible.
  var path;

  var component = findFiber(hostNode) || hostNode._reactInternalFiber;

  if (component) {
    var domMap = generateFullDomMap();
    var typeName = getTypeName(component);
    var mapped = domMap[typeName].find(function (mapItem) {
      return mapItem.node.stateNode === component.stateNode;
    });
    path = mapped.path.reverse().filter(function (_ref, index) {
      var type = _ref.type,
          selector = _ref.selector,
          ofType = _ref.ofType;
      return !index || /^</.test(selector) || ofType;
    }).map(function (_ref2) {
      var type = _ref2.type,
          selector = _ref2.selector;
      return [selector, domMap[type].length];
    });
    var singleElement = path.findIndex(function (_ref3) {
      var _ref4 = _slicedToArray(_ref3, 2),
          name = _ref4[0],
          count = _ref4[1];

      return /^</.test(name) && count === 1;
    });

    if (singleElement >= 0) {
      path = path.slice(0, singleElement + 1);
    }

    return path.map(function (_ref5) {
      var _ref6 = _slicedToArray(_ref5, 1),
          name = _ref6[0];

      return name;
    }).reverse().join(' ');
  }
}

function querySelector(selector, scope) {
  try {
    var roots = generateQueryTree(scope);
    selector = selector.replace(/<(.*?)>/g, '_$1_');
    var reactComponent = cssSelect.selectOne(selector, roots, {
      adapter: adapter,
      xmlMode: true
    });

    if (reactComponent) {
      return reactComponent;
    }
  } catch (err) {
    var toThrow = new Error("Error Evaluating ".concat(selector, ": ").concat(err.message));
    toThrow.stack = err.stack;
    throw toThrow;
  }

  try {
    return (scope || document).querySelector(selector) || undefined;
  } catch (err) {
    /* nop */
  }
}
function querySelectorAll(selector, scope) {
  try {
    var roots = generateQueryTree(scope);
    selector = selector.replace(/<(.*?)>/g, '_$1_');
    var reactComponents = cssSelect.selectAll(selector, roots, {
      adapter: adapter,
      xmlMode: true
    });

    if (reactComponents.length) {
      return reactComponents;
    }
  } catch (err) {
    var toThrow = new Error("Error Evaluating ".concat(selector, ": ").concat(err.message));
    toThrow.stack = err.stack;
    throw toThrow;
  }

  try {
    return (scope || document).querySelectorAll(selector);
  } catch (err) {
    /* nop */
  }

  return [];
}
function dumpTree(scope) {
  function printNode(node, depth) {
    var padding = '  '.repeat(depth);

    if (node.children.length) {
      return "".concat(padding, "<").concat(node.displayName, ">\n").concat(node.children.map(function (child) {
        return printNode(child, depth + 1);
      }).join(''), "\n").concat(padding, "</").concat(node.displayName, ">\n");
    } else {
      return "".concat(padding, "<").concat(node.displayName, "/>\n");
    }
  }

  return generateQueryTree(scope).map(function (root) {
    return printNode(root, 0);
  });
}

export { componentDOMNodes, dumpTree, generatePath, querySelector, querySelectorAll };
